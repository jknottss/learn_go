1
00:00:00,000 --> 00:00:05,655
[БЕЗ_ЗВУКА] В видео,

2
00:00:05,655 --> 00:00:09,830
посвященному упаковке-распаковке
формата JSON,

3
00:00:09,830 --> 00:00:17,041
мы видели пример,
как пакет работает с структурой,

4
00:00:17,041 --> 00:00:22,022
с полями структуры во время
выполнения программы.

5
00:00:22,022 --> 00:00:28,168
При этом в Go нет возможности пройтись

6
00:00:28,168 --> 00:00:33,160
по полям структуры просто в цикле,
используя оператор for.

7
00:00:33,160 --> 00:00:35,925
Каким образом это реализовано?

8
00:00:35,925 --> 00:00:41,660
На самом деле есть два подхода к
работе с динамическими значениями.

9
00:00:41,660 --> 00:00:44,814
Первый подход — это рефлексия,

10
00:00:44,814 --> 00:00:50,879
и рефлексия позволяет оперировать
со структурами, либо с какими-то

11
00:00:50,879 --> 00:00:55,890
другими объектами и типами программы
прямо во время выполнения.

12
00:00:55,890 --> 00:01:00,886
Давайте посмотрим это на примере.

13
00:01:00,886 --> 00:01:07,900
Итак, у нас есть структура user,
для которой вызывается PrintReflect.

14
00:01:07,900 --> 00:01:13,567
Что делает PrintReflect?

15
00:01:13,567 --> 00:01:19,250
PrintReflect просто проходится по
всем полям структуры и выводит имя

16
00:01:19,250 --> 00:01:25,620
этого поля, его тип,
его значение и теги, если они есть.

17
00:01:25,620 --> 00:01:30,480
Итак, для начала я получаю

18
00:01:30,480 --> 00:01:34,472
объект из пакета рефлексии,

19
00:01:34,472 --> 00:01:41,137
которая представляет собой нашу структуру.

20
00:01:41,137 --> 00:01:42,080
Вот.

21
00:01:42,080 --> 00:01:46,541
После этого я могу, например,
получить количество полей,

22
00:01:46,541 --> 00:01:52,100
которые есть у этой структуры,
и вывести их на экран.

23
00:01:52,100 --> 00:01:57,610
Дальше я просто начинаю в
цикле обходить эти поля.

24
00:01:57,610 --> 00:02:03,744
Я получаю значение этого поля, получаю тип

25
00:02:03,744 --> 00:02:09,780
этого поля и вывожу их всех на экран.

26
00:02:09,780 --> 00:02:14,570
Имя поля, тип поля,

27
00:02:14,570 --> 00:02:20,704
значение этого поля (в данный
момент у данной структуры) и тег.

28
00:02:20,704 --> 00:02:21,516
Вот.

29
00:02:21,516 --> 00:02:24,280
Давайте запустим.

30
00:02:24,280 --> 00:02:32,330
[ЗВУК] Итак,

31
00:02:32,330 --> 00:02:36,040
метод структура user имеет четыре поля.

32
00:02:36,040 --> 00:02:42,178
ID типа int, значение 42 и без тега.

33
00:02:42,178 --> 00:02:48,620
RealName string с каким-то значением тега,
логин и флаги.

34
00:02:48,620 --> 00:02:52,830
Это простой пример,

35
00:02:52,830 --> 00:02:56,869
который просто выводит
какую-то информацию на экран,

36
00:02:56,869 --> 00:03:01,470
но при помощи рефлексии
можно делать гораздо больше.

37
00:03:01,470 --> 00:03:06,100
В следующем видео мы рассмотрим

38
00:03:06,100 --> 00:03:10,310
более практическое применение с

39
00:03:10,310 --> 00:03:15,460
присваиванием в поля
структуры каких-то значений.

40
00:03:15,460 --> 00:03:21,020
Допустим, у нас есть какой-то
формат упаковки данных.

41
00:03:21,020 --> 00:03:25,290
JSON мы брать не будем,
он довольно нетривиален в парсинге.

42
00:03:25,290 --> 00:03:32,731
Мы будем парсить просто бинарные данные,
упакованные при помощи функции pack.

43
00:03:32,731 --> 00:03:36,640
Эта функция есть во многих языках,

44
00:03:36,640 --> 00:03:41,240
она копирует то значение,
которое есть прямо в бинарные данные.

45
00:03:41,240 --> 00:03:46,419
Вот у меня есть вызов perl

46
00:03:46,419 --> 00:03:52,827
функции pack, где я пакую целое число,

47
00:03:52,827 --> 00:03:56,786
строчку, еще один раз целое число.

48
00:03:56,786 --> 00:04:05,070
Строчка запакована в виде
длины и потом значения.

49
00:04:05,070 --> 00:04:09,039
Ну и все.

50
00:04:09,039 --> 00:04:15,383
Вот байтовое представление того,
что он мне запаковал.

51
00:04:15,383 --> 00:04:21,920
Это int, это длина строки,
это сама строка, и еще один int.

52
00:04:21,920 --> 00:04:29,072
И я хочу теперь иметь динамические...

53
00:04:29,072 --> 00:04:34,410
распаковывать такие бинарные
данные в структуру.

54
00:04:34,410 --> 00:04:41,830
И вот это я реализую при
помощи рефлексии сейчас.

55
00:04:41,830 --> 00:04:48,790
Итак, основная наша функция UnpackReflect.

56
00:04:48,790 --> 00:04:50,850
Что она делает и как она это делает?

57
00:04:50,850 --> 00:04:55,450
Ну, я, конечно же, получаю ридер,

58
00:04:55,450 --> 00:05:00,568
чтобы читать,
и из бинарных данных вот data,

59
00:05:00,568 --> 00:05:06,410
которая мне передается, довольно удобно,
они по одному байтику смещались в слайсе.

60
00:05:06,410 --> 00:05:11,970
Дальше я получаю

61
00:05:11,970 --> 00:05:17,700
внутреннюю структуру из
рефлексии и иду по полям.

62
00:05:17,700 --> 00:05:25,275
Итак, я получаю значение, тип,
ну у меня есть тег unpack,

63
00:05:25,275 --> 00:05:29,920
что не надо использовать
это для распаковки.

64
00:05:29,920 --> 00:05:35,289
Поэтому если я вдруг встречаю,
что в теге есть тег unpack и,

65
00:05:35,289 --> 00:05:38,870
более того, он равен минусу,

66
00:05:38,870 --> 00:05:43,551
то это поле я просто пропускаю,
мне оно не нужно.

67
00:05:43,551 --> 00:05:46,761
Дальше у меня есть тип поля.

68
00:05:46,761 --> 00:05:52,181
По нему я сделаю просто switch и реализую

69
00:05:52,181 --> 00:05:56,570
всего лишь два значения, int и строка.

70
00:05:56,570 --> 00:06:03,660
Итак, тип int,
то есть kind возвращает внутреннее

71
00:06:03,660 --> 00:06:09,753
тоже представление типа reflect int.

72
00:06:09,753 --> 00:06:11,707
Что я теперь делаю?

73
00:06:11,707 --> 00:06:13,129
Я вижу, что это int.

74
00:06:13,129 --> 00:06:21,317
Значит, мне нужно распаковать
четыре байта из того, что есть.

75
00:06:21,317 --> 00:06:25,321
Я создаю временную переменную.

76
00:06:25,321 --> 00:06:31,354
Распаковываю, читаю в нее данные

77
00:06:31,354 --> 00:06:38,400
из буфера при помощи бинарного encoding.

78
00:06:38,400 --> 00:06:45,970
И после этого дела я уже
устанавливаю в значение, ValueField,

79
00:06:45,970 --> 00:06:52,220
я устанавливаю

80
00:06:52,220 --> 00:07:01,008
представление через рефлексию тех данных,
которые мне нужны.

81
00:07:01,008 --> 00:07:01,880
Отлично.

82
00:07:01,880 --> 00:07:03,152
Int мы распаковали.

83
00:07:03,152 --> 00:07:04,141
Теперь строка.

84
00:07:04,141 --> 00:07:08,600
Строка у нас чуть более сложная структура,
она имеет длину и сами данные.

85
00:07:08,600 --> 00:07:14,679
Сначала я распаковываю длину,
используя временную переменную,

86
00:07:14,679 --> 00:07:17,665
теперь я создаю slice byte,

87
00:07:17,665 --> 00:07:22,740
для того чтобы в него что-то прочитать.

88
00:07:22,740 --> 00:07:26,940
Читаю в него данные.

89
00:07:26,940 --> 00:07:31,470
И присваиваю внутрь значение.

90
00:07:31,470 --> 00:07:36,080
В значение этого

91
00:07:36,080 --> 00:07:41,095
поля структуры.

92
00:07:41,095 --> 00:07:45,760
А если мне повстречается какой-то
неизвестный тип, то я просто ругаюсь.

93
00:07:45,760 --> 00:07:53,250
[ЗВУК] Давайте посмотрим на то,
что получилось и как оно заработало.

94
00:07:53,250 --> 00:08:02,360
[ЗВУК] Ура.

95
00:08:02,360 --> 00:08:07,640
У меня была пустая структура,
я распаковал в нее значение ID.

96
00:08:07,640 --> 00:08:11,290
RealName я пропустил,
из-за того что тег-структура сказала,

97
00:08:11,290 --> 00:08:12,860
не надо это распаковывать.

98
00:08:12,860 --> 00:08:18,220
Распаковал логин и распаковал флаги.

99
00:08:18,220 --> 00:08:21,845
Вот.

100
00:08:21,845 --> 00:08:28,560
Это пример работы с динамическими
данными через рефлексию.

101
00:08:28,560 --> 00:08:33,590
Какой минус есть у этого?

102
00:08:33,590 --> 00:08:35,068
У него?

103
00:08:35,068 --> 00:08:39,484
Дело в том, что вы, получается,

104
00:08:39,484 --> 00:08:44,600
должны каждый раз в runtime, во время
выполнения работы программы, создавать еще

105
00:08:44,600 --> 00:08:50,295
какие-то дополнительные объекты, объекты
пакета рефлексии, и проходиться по ним.

106
00:08:50,295 --> 00:08:53,268
То есть это какие-то вычисления
во время работы программы,

107
00:08:53,268 --> 00:08:58,358
то есть оно все-таки не
проходит совсем бесплатно.

108
00:08:58,358 --> 00:09:03,550
Есть второй способ для работы
с динамическими значениями.

109
00:09:03,550 --> 00:09:09,742
У него есть свои недостатки,
и называется он кодогенерация.

110
00:09:09,742 --> 00:09:12,940
Рассмотрим его мы в следующем видео.