1
00:00:00,000 --> 00:00:05,365
[БЕЗ_ЗВУКА] В этом

2
00:00:05,365 --> 00:00:10,514
видео мы поговорим про
кодогенерацию — это второй способ

3
00:00:10,514 --> 00:00:15,916
работать с какими-то динамическими
значениями и что-то с ними делать.

4
00:00:15,916 --> 00:00:19,424
В отличие от рефлексии кодогенерация,

5
00:00:19,424 --> 00:00:23,810
она не выполняется в
процессе работы программы.

6
00:00:23,810 --> 00:00:29,490
Кодогенерацией занимается вообще
отдельная программа, которая,

7
00:00:29,490 --> 00:00:34,822
как следует из названия,
генерирует код для нужных действий,

8
00:00:34,822 --> 00:00:40,481
который потом выполняется
уже в процессе работы.

9
00:00:40,481 --> 00:00:42,930
Как это работает?

10
00:00:42,930 --> 00:00:47,929
Итак, перед нами уже знакомый вам код,

11
00:00:47,929 --> 00:00:50,890
который распаковывает бинарные данные.

12
00:00:50,890 --> 00:00:54,755
Если в прошлый раз мы вызывали функцию,

13
00:00:54,755 --> 00:01:00,620
куда передавали структуру, то сейчас
мы вызываем метод этой структуры.

14
00:01:00,620 --> 00:01:05,190
Но почему-то ругается: метода нет.

15
00:01:05,190 --> 00:01:08,520
Где этот должен быть метод?

16
00:01:08,520 --> 00:01:13,588
Тут у нас пусто,
тут только определение самой структуры.

17
00:01:13,588 --> 00:01:19,486
Метод должен быть вот здесь,
его сгенерирует вот эта вот программа.

18
00:01:19,486 --> 00:01:22,650
Сначала я покажу, как это работает.

19
00:01:22,650 --> 00:01:30,920
[ШУМ] Я бы выполнил вот такую команду.

20
00:01:30,920 --> 00:01:37,190
В процессе работы программы
она разбирает исходник,

21
00:01:37,190 --> 00:01:44,332
что-то там смотрит,
что-то там делает и пишет код.

22
00:01:44,332 --> 00:01:48,350
Пишет код как раз в файл,

23
00:01:48,350 --> 00:01:53,590
в отдельный файл.

24
00:01:53,590 --> 00:01:56,352
То есть это метод Unpack
для этой структуры,

25
00:01:56,352 --> 00:01:58,830
который работает с бинарными данными.

26
00:01:58,830 --> 00:02:03,054
И тут вызывается уже не тот код в цикле,

27
00:02:03,054 --> 00:02:07,250
который видели вы видели в рефлексии,

28
00:02:07,250 --> 00:02:11,050
а уже готовый код для каждого поля.

29
00:02:11,050 --> 00:02:15,390
Что тут внутри происходит?

30
00:02:15,390 --> 00:02:19,183
И вообще, почему это возможно?

31
00:02:19,183 --> 00:02:27,184
Дело в том,
что программа на Go собирается программой,

32
00:02:27,184 --> 00:02:32,339
которая написана на Go, то есть
компилятор Go написан теперь уже на Go.

33
00:02:32,339 --> 00:02:38,612
Это значит, что нам доступны все
средства компилятора, все средства

34
00:02:38,612 --> 00:02:45,350
обхода абстрактного синтаксического дерева
и все нужные библиотеки для работы с ним.

35
00:02:45,350 --> 00:02:51,404
Теперь давайте залезем внутрь программы,

36
00:02:51,404 --> 00:02:54,640
которая сгенерировала этот код
и я расскажу, как оно работает.

37
00:02:54,640 --> 00:03:02,362
Итак, кодегенерация

38
00:03:02,362 --> 00:03:09,241
— это процесс написания программы,
которая генерирует другую программу.

39
00:03:09,241 --> 00:03:13,850
Не пытайтесь сразу понять все,
что я вам расскажу сейчас,

40
00:03:13,850 --> 00:03:18,750
просто посмотрите и пускай в
вашей картине мира появится

41
00:03:18,750 --> 00:03:23,047
сам факт того, что так можно было.

42
00:03:23,047 --> 00:03:29,110
Итак, сначала я задам несколько шаблонов,

43
00:03:29,110 --> 00:03:34,585
при помощи которых

44
00:03:34,585 --> 00:03:39,626
я вообще генерирую код,
то есть мне нужно туда передать

45
00:03:39,626 --> 00:03:44,390
имя и все — и оно уже создаст
какой-то текст на выходе.

46
00:03:44,390 --> 00:03:48,280
Не буду на этом останавливаться,
пойдем дальше.

47
00:03:48,280 --> 00:03:54,804
Итак, я при помощи

48
00:03:54,804 --> 00:04:01,578
вот этих вот компонентов, я сначала

49
00:04:01,578 --> 00:04:06,510
попробую распарсить исходный код, который
передан мне первым аргументов в программу.

50
00:04:06,510 --> 00:04:11,014
И буду записывать его в файл,

51
00:04:11,014 --> 00:04:16,810
который создам [НЕРАЗБОРЧИВО]
второго аргумента.

52
00:04:16,810 --> 00:04:18,231
Итак, начнем.

53
00:04:18,231 --> 00:04:23,720
Сначала я запишу имя пакета в этот файл
— там пустые строчки — и необходимые

54
00:04:23,720 --> 00:04:28,684
мне импорты, то есть запишу файл руками.

55
00:04:28,684 --> 00:04:33,402
Потом начну перебирать синтаксическое
дерево в поиске нужной мне

56
00:04:33,402 --> 00:04:35,940
вообще структуры, того, что я вообще ищу.

57
00:04:35,940 --> 00:04:41,034
Итак, сначала объявление общего вида,

58
00:04:41,034 --> 00:04:45,122
то есть там может быть не
обязательно объявление,

59
00:04:45,122 --> 00:04:49,300
там может быть импорт какой-то
или еще что-то другое.

60
00:04:49,300 --> 00:04:54,401
И теперь я начну по ним проходиться.

61
00:04:54,401 --> 00:04:58,163
Итак, у меня есть объявление — это
может быть объявление типа, константы,

62
00:04:58,163 --> 00:05:04,270
переменной, — я иду по этим переменным,
если они мне не нужны, я скипаю.

63
00:05:04,270 --> 00:05:09,390
Теперь я смотрю, если это структура
— если не структура, тоже скипаю.

64
00:05:09,390 --> 00:05:14,420
Теперь я скипаю структуру,
если у нее нет комментов.

65
00:05:14,420 --> 00:05:17,067
Почему я так делаю?

66
00:05:17,067 --> 00:05:18,630
Смотрите.

67
00:05:18,630 --> 00:05:23,858
Вот у меня у структуры я пометил
комментарием специальным,

68
00:05:23,858 --> 00:05:27,250
что мне нужно генерировать
для этой структуры что-то.

69
00:05:27,250 --> 00:05:31,240
И еще пометил каким-то
тегом поле структуры.

70
00:05:31,240 --> 00:05:35,452
Итак, если у структуры нет комментариев,
я ее скипаю.

71
00:05:35,452 --> 00:05:39,593
Вот, например, структура Avatar —
у нее нет комментариев никаких,

72
00:05:39,593 --> 00:05:42,790
относящихся к ней,
и я не буду для нее ничего генерировать.

73
00:05:42,790 --> 00:05:47,480
Дальше я смотрю все комментарии,

74
00:05:47,480 --> 00:05:51,324
и если я встречаю нужный мне комментарий,
я ставлю флаг.

75
00:05:51,324 --> 00:05:55,317
Если вдруг флага нет,
я не продолжаю обработку дальше,

76
00:05:55,317 --> 00:05:58,630
я просто перехожу к следующему объявлению.

77
00:05:58,630 --> 00:06:04,544
Хорошо, теперь непосредственно
начался процесс

78
00:06:04,544 --> 00:06:11,520
генерации кода для этой
структуры и ее полей.

79
00:06:11,520 --> 00:06:15,991
Так, немножко информации, что я делаю.

80
00:06:15,991 --> 00:06:21,993
Я, вообще, создаю функцию: func,

81
00:06:21,993 --> 00:06:26,039
это входящая переменная, тип и Unpack.

82
00:06:26,039 --> 00:06:29,243
Дальше внутри этой функции я создаю ридер,

83
00:06:29,243 --> 00:06:32,540
и теперь я пройдусь по
полям этой структуры.

84
00:06:32,540 --> 00:06:37,693
То есть, несмотря на то что
это не рантайм, я могу я могу

85
00:06:37,693 --> 00:06:43,120
распарсить этот исходный код, точнее,
он уже распаршен, когда я здесь.

86
00:06:43,120 --> 00:06:45,688
И я могу итерироваться по полям.

87
00:06:45,688 --> 00:06:46,520
Отлично.

88
00:06:46,520 --> 00:06:51,295
Так, сначала посмотрим тег
структуры — вдруг он там есть.

89
00:06:51,295 --> 00:06:56,012
И там есть cgen на минус, то есть не
надо — я дальше не пойду, значит,

90
00:06:56,012 --> 00:06:57,890
это поле можно пропустить.

91
00:06:57,890 --> 00:07:01,378
Теперь у меня есть имя поля и тип поля.

92
00:07:01,378 --> 00:07:03,560
Пишем, что мы делаем.

93
00:07:03,560 --> 00:07:05,764
Смотрим, какой тип.

94
00:07:05,764 --> 00:07:11,340
Если это int, я генерирую код
для шаблона распаковки int,

95
00:07:11,340 --> 00:07:18,830
если это строчка,
я генерирую распаковку строчки.

96
00:07:18,830 --> 00:07:22,299
А если какое-то новое поле,

97
00:07:22,299 --> 00:07:26,985
то я просто ругаюсь и завершаю программу.

98
00:07:26,985 --> 00:07:31,250
Отлично, теперь я говорю,
что ошибки нет, закрываю функцию,

99
00:07:31,250 --> 00:07:36,540
пишу пустую строку и в общем все,
то есть вот моя программа отработала.

100
00:07:36,540 --> 00:07:38,695
Что она писала во время выполнения?

101
00:07:38,695 --> 00:07:40,160
Я ведь там втыкал debug.

102
00:07:40,160 --> 00:07:45,140
Итак, импорт мне нужен, я его пропускаю.

103
00:07:45,140 --> 00:07:47,506
Я нашел структуру, отлично.

104
00:07:47,506 --> 00:07:54,140
Структуру я генерирую метод Unpack,
генерирую код для распаковки полей.

105
00:07:54,140 --> 00:07:59,658
То есть вот это то,
что уже пошло в работу.

106
00:07:59,658 --> 00:08:03,125
Дальше там были какие-то другие вещи,

107
00:08:03,125 --> 00:08:06,740
структура Avatar комментов не имеет,
поэтому я ее пропущу.

108
00:08:06,740 --> 00:08:11,563
Объявление переменной мне тоже
не интересно, я ее тоже пропущу,

109
00:08:11,563 --> 00:08:14,500
это не объявление типа, который я ищу.

110
00:08:14,500 --> 00:08:21,000
И объявление функции, короче, мне тоже
не интересно, поэтому я ее тоже пропущу.

111
00:08:21,000 --> 00:08:22,997
И посмотрим на код.

112
00:08:22,997 --> 00:08:29,413
Вот код, который мне сгенерировался
для распаковки ID, поля ID.

113
00:08:29,413 --> 00:08:35,038
Я тут ставлю уже сразу, в поле
присваиваю — не через магию рефлексии,

114
00:08:35,038 --> 00:08:39,466
чего-то там, чего-то там, какие-то
структуры и прочее что-то сложное.

115
00:08:39,466 --> 00:08:43,483
В Login присваиваю строку — как вы
помните, строка распаковывается сначала ее

116
00:08:43,483 --> 00:08:48,025
длина, а потом сами данные — и флаги.

117
00:08:48,025 --> 00:08:55,555
Теперь неплохо бы это запустить и убедить,
что работает.

118
00:08:55,555 --> 00:08:56,281
Ура!

119
00:08:56,281 --> 00:09:01,275
Раньше функции Unpack не было,
программа даже не компилировалась.

120
00:09:01,275 --> 00:09:05,390
Теперь она скомпилировалась.

121
00:09:05,390 --> 00:09:08,277
И все нормально распаковалось.

122
00:09:08,277 --> 00:09:09,930
ID распаковался.

123
00:09:09,930 --> 00:09:14,750
RealName не нужно распаковывать,
потому что там есть метка, что пропустить.

124
00:09:14,750 --> 00:09:18,220
Login распаковался и
флаги тоже распаковались.

125
00:09:18,220 --> 00:09:19,076
Отлично!

126
00:09:19,076 --> 00:09:24,220
То есть я написал программу,
которая пишет другую программу.

127
00:09:24,220 --> 00:09:28,090
Это не то чтобы близко к
искусственному интеллекту,

128
00:09:28,090 --> 00:09:32,080
но применяется это достаточно широко.

129
00:09:32,080 --> 00:09:35,510
Во-первых, это применяется компилятором.

130
00:09:35,510 --> 00:09:40,970
Во-вторых, довольно много синтаксических
анализаторов используют такой подход.

131
00:09:40,970 --> 00:09:48,694
В-третьих, вы можете сгенерировать для
какого-то упаковщика-распаковщика код,

132
00:09:48,694 --> 00:09:54,547
который будет работать не при
помощи рефлексии в рантайме,

133
00:09:54,547 --> 00:10:01,681
а сгенерирует вам код,
который будет работать быстрее.

134
00:10:01,681 --> 00:10:06,850
В чем минус кодогенерации
по сравнению с рефлексией?

135
00:10:06,850 --> 00:10:10,602
Я напомню, что минус рефлексии в том,

136
00:10:10,602 --> 00:10:15,623
что вы выполняете какую-то дополнительную

137
00:10:15,623 --> 00:10:20,631
работу за счет создания структуры
рефлексии и прочего — выполняете

138
00:10:20,631 --> 00:10:26,142
какую-то дополнительную работу в рантайме.

139
00:10:26,142 --> 00:10:31,918
В кодогенерации вы не
выполняете дополнительную

140
00:10:31,918 --> 00:10:37,531
работу в рантайме,
потому что у вас уже готовый код,

141
00:10:37,531 --> 00:10:41,373
однако в данном случае
недостатком является то,

142
00:10:41,373 --> 00:10:47,130
что вам нужно писать программу
отдельную и отдельно ее отлаживать,

143
00:10:47,130 --> 00:10:52,820
что иногда бывает довольно нетривиально.

144
00:10:52,820 --> 00:10:58,049
Кодогенерацию хорошо использовать,
если у вас какая-то очень большая,

145
00:10:58,049 --> 00:11:06,360
очень интенсивная нагрузка, и вы хотите
оптимизировать какие-то горячие участки.

146
00:11:06,360 --> 00:11:10,780
И раз уже мы заговорили
про горячие участки,

147
00:11:10,780 --> 00:11:18,207
то в следующем видео мы рассмотрим
вопрос о профилировании и сравним,

148
00:11:18,207 --> 00:11:23,686
что быстрее: функция Unpack
через рефлексию или Unpack,

149
00:11:23,686 --> 00:11:26,170
которая получилась кодогенерацией?