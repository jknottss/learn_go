1
00:00:00,000 --> 00:00:06,001
[БЕЗ СЛОВ] В

2
00:00:06,001 --> 00:00:11,830
предыдущем видео мы рассмотрели каким
образом мы можем сравнить два подхода,

3
00:00:11,830 --> 00:00:17,143
каких-то два кода,
какой из них быстрее, и мы узнали,

4
00:00:17,143 --> 00:00:22,459
что подход с кодогенерацией будет быстрее,
подхода с рефлексией.

5
00:00:22,459 --> 00:00:26,810
Мы пользовались флагом
benchmem у бенчмарка,

6
00:00:26,810 --> 00:00:30,678
и в этом видео мы поговорим о том,

7
00:00:30,678 --> 00:00:35,080
как посмотреть не просто
какой вариант быстрее,

8
00:00:35,080 --> 00:00:39,390
а за счет чего какой-то
вариант быстрее или медленнее.

9
00:00:39,390 --> 00:00:47,780
В Go вы можете снять
профиль либо процессора,

10
00:00:47,780 --> 00:00:52,280
используя директиву cpuprofile и путь

11
00:00:52,280 --> 00:00:56,889
куда складировать данные,

12
00:00:56,889 --> 00:01:00,578
либо профилирование памяти.

13
00:01:00,578 --> 00:01:03,799
Причем, я указал rate 1,

14
00:01:03,799 --> 00:01:10,200
то есть фактически
регистрировать в каждую локацию.

15
00:01:10,200 --> 00:01:14,920
Вы можете использовать либо и CPU,
и память вместе, либо по отдельности.

16
00:01:14,920 --> 00:01:19,446
Я использую вместе для того,
чтобы он мне их построил.

17
00:01:19,446 --> 00:01:21,190
Сейчас я это запущу.

18
00:01:21,190 --> 00:01:25,790
Итак, я запустил.

19
00:01:25,790 --> 00:01:33,166
Видно, как по-прежнему, что кодогенерация
будет быстрее практически в два раза.

20
00:01:33,166 --> 00:01:35,780
Теперь я хочу посмотреть, почему.

21
00:01:35,780 --> 00:01:42,966
Когда я снял профиль, теперь мне нужно
его каким-то образом проанализировать.

22
00:01:42,966 --> 00:01:45,650
В Go для этого есть инструмент,
называется pprof.

23
00:01:45,650 --> 00:01:50,538
Запускается он таким
образом: go tool pprof,

24
00:01:50,538 --> 00:01:53,337
ваш выполняемый файл.

25
00:01:53,337 --> 00:01:57,476
Если вы собираете его через test,

26
00:01:57,476 --> 00:02:03,134
то вот он таким образом собрался:
test.exe и путь к профилировщику.

27
00:02:03,134 --> 00:02:04,370
Начнем мы с CPU.

28
00:02:04,370 --> 00:02:12,098
[БЕЗ СЛОВ] Запустился pprof.

29
00:02:12,098 --> 00:02:16,970
Сначала давайте посмотрим на топ операции,
которые выполнялись.

30
00:02:16,970 --> 00:02:24,886
Ну, тут только runtime,
то есть чисто сам runtime Go.

31
00:02:24,886 --> 00:02:31,669
Тут нет наших операций,
они не были достаточно быстрые.

32
00:02:31,669 --> 00:02:36,285
Но я могу ввести нужную мне

33
00:02:36,285 --> 00:02:40,250
функцию и посмотреть,
что именно там, где занимало время.

34
00:02:40,250 --> 00:02:46,507
Я знаю мою функцию,
она называется Unpack, точнее их там две.

35
00:02:46,507 --> 00:02:52,854
Я использую команду list и ввожу
функцию Unpack, и теперь мне

36
00:02:52,854 --> 00:02:58,058
вывелись на экран те места,

37
00:02:58,058 --> 00:03:02,398
где было сколько-либо много

38
00:03:02,398 --> 00:03:08,190
задействовано CPU времени.

39
00:03:08,190 --> 00:03:15,740
Посмотрим сначала UnpackBin,
это кодогенерация.

40
00:03:15,740 --> 00:03:20,340
Вот где, что тут тратило время.

41
00:03:20,340 --> 00:03:25,157
В основном, конечно,
это чтение бинарных данных затрачивается,

42
00:03:25,157 --> 00:03:29,460
ну, и преобразование слайса byte в строке.

43
00:03:29,460 --> 00:03:33,480
А если мы посмотрим рефлексию,

44
00:03:33,480 --> 00:03:38,791
то мы не только тратим время
на чтение бинарных данных,

45
00:03:38,791 --> 00:03:45,440
но еще и на их установку вот здесь,
и вот тут тоже.

46
00:03:45,440 --> 00:03:49,146
Но по коду иногда бывает ковыряться не
очень много, хочется как-то и с высоты

47
00:03:49,146 --> 00:03:54,480
птичьего полета обозревать свою программу,
свои владения и смотреть, что там как.

48
00:03:54,480 --> 00:03:59,345
Для этого pprof может
строить уже картинку с

49
00:03:59,345 --> 00:04:04,589
графиком в любом нужном вам формате, либо
вы можете запустить ее прямо из pprof.

50
00:04:04,589 --> 00:04:07,089
Делается это: команда web, enter.

51
00:04:07,089 --> 00:04:12,570
У меня открылся браузер,
и теперь видны фактически все кишки.

52
00:04:12,570 --> 00:04:15,129
У меня не очень много горячих мест.

53
00:04:15,129 --> 00:04:21,110
На самом деле все горячие места занимают
runtime и операции, там, с памятью.

54
00:04:21,110 --> 00:04:25,190
Но, тем не менее,
тут можно найти мои программы.

55
00:04:25,190 --> 00:04:26,439
Вот отлично!

56
00:04:26,439 --> 00:04:30,610
Смотрите, вот test, вот BenchmarkCodegen.

57
00:04:30,610 --> 00:04:35,350
Так, 0.17, а вот BenchmarkReflect, 0.25,

58
00:04:35,350 --> 00:04:39,610
и дальше мы уже можем смотреть,
где тут что выделяется.

59
00:04:39,610 --> 00:04:43,290
Например, UnpackReflect,

60
00:04:43,290 --> 00:04:48,050
они все выделяли какие-то новые объекты,
все читали,

61
00:04:48,050 --> 00:04:52,538
но вот Reflect куда-то ушел,
ушел, ушел, ушел...

62
00:04:52,538 --> 00:04:56,550
куда-то ушел в runtime.

63
00:04:56,550 --> 00:05:01,150
Таким образом, вы можете найти нужное

64
00:05:01,150 --> 00:05:05,290
узкое место и попробовать
его оптимизировать.

65
00:05:05,290 --> 00:05:09,160
Но это профиль CPU, давайте теперь
посмотрим на профиль памяти.

66
00:05:09,160 --> 00:05:16,360
Указываем mem.out.

67
00:05:16,360 --> 00:05:19,654
В профиле памяти несколько разных режимов.

68
00:05:19,654 --> 00:05:24,393
Тут можно посмотреть место, которое в
данный момент занимает либо по количеству

69
00:05:24,393 --> 00:05:29,740
объектов, либо по самой памяти либо места,
где были совершены больше всего локаций.

70
00:05:29,740 --> 00:05:36,655
Вот например, если я введу сразу, то в
данный момент в основном занимает runtime,

71
00:05:36,655 --> 00:05:42,145
и, более того, я больше всего
вижу снятие самого хипа тут,

72
00:05:42,145 --> 00:05:46,771
но если я посмотрю на аллокации, alloc...

73
00:05:46,771 --> 00:05:53,533
это команда alloc_space,
где были произведены аллокации.

74
00:05:53,533 --> 00:05:58,469
Теперь смотрим top, и уже в top
я вижу свои функции: UnpackBin,

75
00:05:58,469 --> 00:06:02,371
UnpackReflect, Codegen, BenchmarkReflect.

76
00:06:02,371 --> 00:06:08,244
Теперь я опять могу использовать
команду list и посмотреть Unpack,

77
00:06:08,244 --> 00:06:10,190
где было выделение.

78
00:06:10,190 --> 00:06:15,160
Как всегда Reader с
присваиваемой переменной

79
00:06:15,160 --> 00:06:19,200
и выделение слайса byte для чтения.

80
00:06:19,200 --> 00:06:24,534
string — конвертация слайса byte в строку,
ну, и так далее.

81
00:06:24,534 --> 00:06:27,880
Это кодогенерация, а вот reflect.

82
00:06:27,880 --> 00:06:34,264
То есть помимо того, что я читаю,
вот тут еще много выделено памяти.

83
00:06:34,264 --> 00:06:35,227
Что это такое?

84
00:06:35,227 --> 00:06:36,789
Это присвоение в поле.

85
00:06:36,789 --> 00:06:40,157
То есть я не сразу
присваиваю в поле структуры,

86
00:06:40,157 --> 00:06:43,450
а должен провести это через reflect.Value.

87
00:06:43,450 --> 00:06:45,819
Ну и тоже слайс byte.

88
00:06:45,819 --> 00:06:52,149
Точно так же как и CPU,
мы можем посмотреть на это в виде web.

89
00:06:52,149 --> 00:06:52,760
Web.

90
00:06:52,760 --> 00:06:56,287
И тут мы уже можем увидеть
чуть-чуть побольше.

91
00:06:56,287 --> 00:07:03,113
Смотрите, тут уже все-таки наша программа
в этих местах выделила больше памяти.

92
00:07:03,113 --> 00:07:08,910
Посмотрим, UnpackReflect и UnpackBin
— они оба используют binary.Read,

93
00:07:08,910 --> 00:07:12,243
оба выделяют строку, но вот Reflect,

94
00:07:12,243 --> 00:07:16,149
в ряд с reflect еще тратит
на reflect.(*rtype).Field,

95
00:07:16,149 --> 00:07:19,697
reflect.(*structType).Field, то
есть это вот он,

96
00:07:19,697 --> 00:07:24,340
вот как раз overhead, который
накладывает Reflect на ваши оперции.

97
00:07:24,340 --> 00:07:29,010
Здесь его наглядно видно.

98
00:07:29,010 --> 00:07:33,570
Так, это было alloc_space,

99
00:07:33,570 --> 00:07:40,290
а теперь давайте посмотрим,
где именно сами объекты выделялись.

100
00:07:40,290 --> 00:07:46,137
[БЕЗ СЛОВ] [БЕЗ

101
00:07:46,137 --> 00:07:53,422
СЛОВ] [БЕЗ СЛОВ] Ну,

102
00:07:53,422 --> 00:07:57,783
по-прежнему мы видим, что там же,

103
00:07:57,783 --> 00:08:01,650
хотя на первом месте выделяется
создание новой строки.

104
00:08:01,650 --> 00:08:09,580
Также давайте посмотрим
по-прежнему нашу функцию Unpack.

105
00:08:09,580 --> 00:08:11,254
Ну и где были объекты?

106
00:08:11,254 --> 00:08:17,308
Вот здесь объекты, вот здесь много
было выделено, ну, и также вот тут.

107
00:08:17,308 --> 00:08:19,000
О, всего одна!

108
00:08:19,000 --> 00:08:22,720
Всего один объект выделяется
на данном Unpack.

109
00:08:22,720 --> 00:08:25,762
Это очень мощный инструмент исследования.

110
00:08:25,762 --> 00:08:29,834
Вы можете глубоко-глубоко
зарыться туда и при помощи него

111
00:08:29,834 --> 00:08:33,558
оптимизировать вашу программу так,
как вам надо.

112
00:08:33,558 --> 00:08:36,385
Ну, и давайте под конец посмотрим web.

113
00:08:36,385 --> 00:08:41,320
Ну, и опять web уже AllocObject],
где какие объекты были выделены.

114
00:08:41,320 --> 00:08:48,060
Смотрите, вот UnpackBin, то есть метод,
который был получен кодогенерацией.

115
00:08:48,060 --> 00:08:53,454
Он всего лишь выделяет строку,
ну и считает бинарные данные.

116
00:08:53,454 --> 00:08:58,040
А вот метод, который распаковывает
данные через Reflect.

117
00:08:58,040 --> 00:09:00,696
Он не только читает бинарные данные,

118
00:09:00,696 --> 00:09:05,490
но еще и использует
конвертацию в пустой интерфейс,

119
00:09:05,490 --> 00:09:11,682
вот этот вот кусок: runtime.convT2E,
ну, и структуры Reflect:

120
00:09:11,682 --> 00:09:16,820
reflect.(*rtype).Field и
reflect.(*structType).Field.

121
00:09:16,820 --> 00:09:22,592
Вот тут тоже видно overhead,
который накладывает Reflect,

122
00:09:22,592 --> 00:09:28,240
и именно из-за чего Reflect медленнее,
чем кодогенерация.

123
00:09:28,240 --> 00:09:32,910
pprof — очень мощный инструмент.

124
00:09:32,910 --> 00:09:37,380
Я dам рассказываю только про очень
мощные инструменты в Go, других там нет.

125
00:09:37,380 --> 00:09:40,880
Вы можете использовать либо для бенчмарка.

126
00:09:40,880 --> 00:09:47,080
Более того, вы можете снимать дампы
памяти и дампы профилирования процессора

127
00:09:47,080 --> 00:09:52,600
прямо с работающей программы,
но это мы будем рассматривать отдельно.