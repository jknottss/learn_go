1
00:00:00,000 --> 00:00:08,524
[БЕЗ_ЗВУКА] Говоря о
тестировании какого-то кода,

2
00:00:08,524 --> 00:00:12,970
очень важным является вопрос
покрытия кода тестами.

3
00:00:12,970 --> 00:00:14,440
Что это значит?

4
00:00:14,440 --> 00:00:20,540
Мы можем написать довольно много разных
случаев тестирования, разных данных,

5
00:00:20,540 --> 00:00:26,293
но мы не знаем, какое количество реального
кода будут покрывать эти вызовы.

6
00:00:26,293 --> 00:00:28,858
В разных языках это решается по-разному.

7
00:00:28,858 --> 00:00:33,382
Где-то есть встроенные инструменты,
где-то это внешние инструменты,

8
00:00:33,382 --> 00:00:34,840
где-то их нет вообще.

9
00:00:34,840 --> 00:00:42,675
В Go подсчет покрытия тестами
встроен прямо в само тестирование.

10
00:00:42,675 --> 00:00:45,478
Давайте посмотрим, как это работает.

11
00:00:45,478 --> 00:00:49,572
Итак, у нас есть код,
есть какая-то структура User,

12
00:00:49,572 --> 00:00:52,370
есть какой-то список этих юзеров,

13
00:00:52,370 --> 00:00:58,142
и есть функция получения юзера.

14
00:00:58,142 --> 00:01:00,428
Что она делает?

15
00:01:00,428 --> 00:01:04,780
Она пытается получить этого
юзера по ключу из map'ки.

16
00:01:04,780 --> 00:01:08,923
Если он там есть, то она возвращает,

17
00:01:08,923 --> 00:01:15,980
распаковывает json и возвращает уже
непосредственно этого юзера как структуру.

18
00:01:15,980 --> 00:01:20,840
Если нет, то она ругается,
что такого пользователя нет.

19
00:01:20,840 --> 00:01:27,840
В случае, если не получилось распаковать
json, то тоже возвращается ошибка.

20
00:01:27,840 --> 00:01:30,942
Теперь давайте посмотрим на тест.

21
00:01:30,942 --> 00:01:32,174
Итак, тест User.

22
00:01:32,174 --> 00:01:34,870
У нас есть некоторое количество тестов.

23
00:01:34,870 --> 00:01:39,260
Один из них закоммутирован,
позже я покажу, почему.

24
00:01:39,260 --> 00:01:44,436
Итак, у нас есть тест ok с ключом ok.

25
00:01:44,436 --> 00:01:47,940
Он возвращает какого-то юзера,
и ошибки у него нет.

26
00:01:47,940 --> 00:01:49,188
IsError.

27
00:01:49,188 --> 00:01:53,910
Второй тест должен нам вернуть ошибку,

28
00:01:53,910 --> 00:01:58,510
и при этом юзера не вернут,
то есть это тест на какую-то ошибку.

29
00:01:58,510 --> 00:02:04,048
Вот после этого мы пройдем уже по
самим тестам, их будем получать.

30
00:02:04,048 --> 00:02:06,357
Но сам код тут не очень важен.

31
00:02:06,357 --> 00:02:09,200
Важно, как мы его будем запускать.

32
00:02:09,200 --> 00:02:16,360
Если мы запустим просто go test,

33
00:02:16,360 --> 00:02:22,150
то мы увидим, что наш тест прошел,
действительно, ничего не упало.

34
00:02:22,150 --> 00:02:26,301
Но вопрос покрытия непонятен.

35
00:02:26,301 --> 00:02:33,474
Для того чтобы читалось покрытие,
есть опция cover.

36
00:02:33,474 --> 00:02:34,890
Отлично.

37
00:02:34,890 --> 00:02:44,140
Наш тест прошел,
при этом покрытие всего 85 %.

38
00:02:44,140 --> 00:02:48,510
Хорошо, теперь мы узнали, что у нас
какая-то часть нашего кода не покрыта.

39
00:02:48,510 --> 00:02:52,880
То есть нашими тестами этот
код не был вызван никогда.

40
00:02:52,880 --> 00:02:55,202
Как это посмотреть?

41
00:02:55,202 --> 00:03:01,360
Ну, конечно, есть опция для того,
чтобы построить отчет по этому.

42
00:03:01,360 --> 00:03:07,980
Вы можете видеть ее на экране:
go tool cover, html указываем...

43
00:03:07,980 --> 00:03:12,624
Нет, go test coverprofile,

44
00:03:12,624 --> 00:03:17,480
мы строим непосредственно
вывод для отчета.

45
00:03:17,480 --> 00:03:18,226
Строим.

46
00:03:18,226 --> 00:03:19,719
Он нам записался.

47
00:03:19,719 --> 00:03:24,884
Теперь запускаем go tool cover,
указываем файл для отчета,

48
00:03:24,884 --> 00:03:31,460
из которого ему читать данные, и html,
куда ему записать отчет, уже в html форме.

49
00:03:31,460 --> 00:03:33,415
Запускаем.

50
00:03:33,415 --> 00:03:37,150
Вот так выглядит отчет.

51
00:03:37,150 --> 00:03:43,160
Зеленым отмечен тот код,
который запускается.

52
00:03:43,160 --> 00:03:48,970
То есть весь случай, когда у нас
данные найдены, они запускаются.

53
00:03:48,970 --> 00:03:55,872
При этом у нас запускается случай,
когда мы не смогли распаковать json.

54
00:03:55,872 --> 00:04:00,931
Однако вот эта строчка, красная,
она не запускается, потому что мы

55
00:04:00,931 --> 00:04:06,850
никогда не передавали туда данные,
которых нет в мапе с пользователями.

56
00:04:06,850 --> 00:04:08,740
Надо это исправить.

57
00:04:08,740 --> 00:04:12,140
Возьмем наш тест.

58
00:04:12,140 --> 00:04:16,948
И возьмем третий тест-кейс,
который пытается запросить данные по ключу

59
00:04:16,948 --> 00:04:21,251
not_exist, которого нет в нашей мапе.

60
00:04:21,251 --> 00:04:23,750
И теперь запустим.

61
00:04:23,750 --> 00:04:27,547
Мы раскомментировали эту строчку.

62
00:04:27,547 --> 00:04:31,002
Теперь запускаем тест сразу
с построением профиля.

63
00:04:31,002 --> 00:04:31,629
Отлично.

64
00:04:31,629 --> 00:04:32,820
100 % профиля.

65
00:04:32,820 --> 00:04:35,730
Построим отчет.

66
00:04:35,730 --> 00:04:38,640
Отчет построен.

67
00:04:38,640 --> 00:04:39,541
Обновим.

68
00:04:39,541 --> 00:04:43,850
Теперь видно,
что эта строчка тоже запускалась.

69
00:04:43,850 --> 00:04:48,432
Давайте для примера
попробуем убрать случай,

70
00:04:48,432 --> 00:04:51,540
когда мы не можем распаковать json.

71
00:04:51,540 --> 00:04:57,867
Закомментируем вот эту строчку, сохраним,
еще раз построим тест с отчетом.

72
00:04:57,867 --> 00:04:59,670
Опять 87 %.

73
00:04:59,670 --> 00:05:01,480
Строим отчет.

74
00:05:01,480 --> 00:05:06,380
И теперь видим, что случай,

75
00:05:06,380 --> 00:05:11,597
когда какая-то ошибка нам вернулась,
то он не выполнился.

76
00:05:11,597 --> 00:05:15,195
Причем обратите внимание, if выполнился,

77
00:05:15,195 --> 00:05:21,010
потому что мы действительно проверяли,
что ошибка не равна nil.

78
00:05:21,010 --> 00:05:25,380
А вот то, что уже внутри этого,
не выполнилось.

79
00:05:25,380 --> 00:05:31,177
Это значит, что это условие никогда не
отрабатывало во время наших тестов.

80
00:05:31,177 --> 00:05:36,706
Вопрос покрытия лучше всего доводить

81
00:05:36,706 --> 00:05:41,110
до очень приемлемого уровня.

82
00:05:41,110 --> 00:05:43,865
Не всегда стоит стремиться к 100 %,

83
00:05:43,865 --> 00:05:48,377
однако если вы делаете какие-то
системные утилиты, более того,

84
00:05:48,377 --> 00:05:52,903
системные lib'ы, или какие-то
пакеты для других разработчиков,

85
00:05:52,903 --> 00:05:58,120
то есть не само бизнес-приложение,
то покрытие

86
00:05:58,120 --> 00:06:03,149
у него лучше стараться делать
максимально возможным.

87
00:06:03,149 --> 00:06:09,220
Это очень сильно уменьшит количество
багов, которые вам будут сообщать.