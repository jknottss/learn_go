1
00:00:00,000 --> 00:00:05,235
http-серверов, http-лиснеров
в разных рутинах.

2
00:00:05,235 --> 00:00:11,499
В прошлом видео мы сделали две реализации
распаковки бинарных данных через рефлексию

3
00:00:11,499 --> 00:00:16,650
и через кодогенерацию, но мы так и не
выяснили, какой из этих вариантов быстрее.

4
00:00:16,650 --> 00:00:22,140
В этом видео я расскажу,
каким образом можно делать бенчмарки

5
00:00:22,140 --> 00:00:27,800
кода и смотреть,
какой из вариантов быстрее.

6
00:00:27,800 --> 00:00:32,873
Итак, бенчмарки в Go лежат
рядом с тестами, то есть в

7
00:00:32,873 --> 00:00:38,963
пакете с суффиксом test,
вы можете видеть test.

8
00:00:38,963 --> 00:00:45,030
Начинаются бенчмарки, функция бенчмарка
начинается с суффикса Benchmark,

9
00:00:45,030 --> 00:00:50,070
куда передается testing B,

10
00:00:50,070 --> 00:00:55,110
в котором вы должны сделать цикл,
что пока меньше

11
00:00:55,110 --> 00:01:00,880
количества итераций,
которые хочет бенчмарк.

12
00:01:00,880 --> 00:01:06,160
После этого он выведет вам
красивую картинку с цифрами.

13
00:01:06,160 --> 00:01:11,982
Давайте запустим тот
код для кодогенерации,

14
00:01:11,982 --> 00:01:15,220
который использует функцию
unpack и для рефлексии,

15
00:01:15,220 --> 00:01:19,367
который использует функцию UnpackReflect.

16
00:01:19,367 --> 00:01:22,838
Запускаем, запускаем так: go test -bench.

17
00:01:22,838 --> 00:01:25,780
Bench — это значит нужно делать бенчмарк.

18
00:01:25,780 --> 00:01:30,590
Точка...

19
00:01:30,590 --> 00:01:36,581
там можно написать регулярное выражение,
чтобы пробенчмаркить не вообще все

20
00:01:36,581 --> 00:01:42,080
функции, которые есть у файла,
а только некоторые из них, например, одну.

21
00:01:42,080 --> 00:01:46,671
Дальше файл, который мы хотим запустить.

22
00:01:46,671 --> 00:01:48,040
Запускаем.

23
00:01:48,040 --> 00:01:54,777
Итак, вариант с кодогенерацией,

24
00:01:54,777 --> 00:01:59,413
одна операция заняла 1000 наносекунд и

25
00:01:59,413 --> 00:02:03,768
успело выполниться 1 миллион итераций.

26
00:02:03,768 --> 00:02:08,638
Вариант с рефлектом: одна
операция занимает 2500

27
00:02:08,638 --> 00:02:13,340
наносекунд и успела
выполниться 500 000 итераций.

28
00:02:13,340 --> 00:02:18,141
То есть, грубо можно говорить,
что вариант с

29
00:02:18,141 --> 00:02:23,260
кодогенерацией вдвое быстрее,
чем вариант с рефлексией.

30
00:02:23,260 --> 00:02:24,405
Но это не все.

31
00:02:24,405 --> 00:02:30,530
Помимо того что мы можем посмотреть
просто скорость выполнения итераций,

32
00:02:30,530 --> 00:02:34,341
мы можем попросить ещё делать
замеры использования памяти.

33
00:02:34,341 --> 00:02:36,910
Делается это при помощи ключа benchmem.

34
00:02:36,910 --> 00:02:42,920
[БЕЗ СЛОВ] Итак,

35
00:02:42,920 --> 00:02:47,735
вариант с кодогенерацией тратит

36
00:02:47,735 --> 00:02:51,741
176 байт на одну операцию,

37
00:02:51,741 --> 00:02:55,654
делает 11 аллокаций памяти за операцию.

38
00:02:55,654 --> 00:03:00,667
Вариант с рефлексией делает
432 байта на операцию,

39
00:03:00,667 --> 00:03:05,130
памяти тратит, и делает аж 22 аллокации.

40
00:03:05,130 --> 00:03:09,878
Понятно, что вариант с
кодогенерацией получается двое

41
00:03:09,878 --> 00:03:12,960
лучше и по скорости и по
использованию памяти.

42
00:03:12,960 --> 00:03:17,775
Окей, это круто.

43
00:03:17,775 --> 00:03:21,658
Если кодогенерация такая крутая вещь,
что сразу напрашивается вопрос,

44
00:03:21,658 --> 00:03:26,260
а давайте сделаем кодогенерацию для json.

45
00:03:26,260 --> 00:03:32,860
Ну, это приложение очень хорошее, поэтому
в mail.ru мы сделали такую кодогенерацию,

46
00:03:32,860 --> 00:03:36,940
назвали пакет easyjson,
вы можете скачать его на GitHub,

47
00:03:36,940 --> 00:03:41,642
и получили впечатляющий
рост производительности.

48
00:03:41,642 --> 00:03:43,630
Давайте я его запущу.

49
00:03:43,630 --> 00:03:52,860
[БЕЗ СЛОВ] Окей.

50
00:03:52,860 --> 00:03:57,710
Раз, два,

51
00:03:57,710 --> 00:04:01,005
три, четыре.

52
00:04:01,005 --> 00:04:04,744
Отлично, сделали бенчмарки.

53
00:04:04,744 --> 00:04:12,529
Итого: декодирование стандартным способом
у нас занимает 4000 наносекунды,

54
00:04:12,529 --> 00:04:16,467
делает 320 байт на операцию,

55
00:04:16,467 --> 00:04:20,580
тратит памяти,
делает 6 аллокаций на операцию.

56
00:04:20,580 --> 00:04:27,054
Декодирование при помощи easyjson
тратит 834 наносекунды на операцию,

57
00:04:27,054 --> 00:04:32,740
делает всего 16 байт на операцию,
тратит памяти, и делает 2 аллокации.

58
00:04:32,740 --> 00:04:38,890
Кодирование, то есть стерилизация,
маршелинг json стандартными способами

59
00:04:38,890 --> 00:04:44,290
тратит 1800 наносекунд на операцию,

60
00:04:44,290 --> 00:04:49,081
занимает 328 байт памяти на операцию,

61
00:04:49,081 --> 00:04:52,288
делает 3 аллокации памяти.

62
00:04:52,288 --> 00:04:57,880
При этом encoding, используя easyjson,
тратит всего 544 наносекунды,

63
00:04:57,880 --> 00:05:04,367
тратит в 3 раза меньше

64
00:05:04,367 --> 00:05:09,354
памяти и в 3 раза меньше аллокаций памяти.

65
00:05:09,354 --> 00:05:12,730
То есть, если смотреть чисто по скорости,

66
00:05:12,730 --> 00:05:17,660
то декодирование в 4 раза быстрее,

67
00:05:17,660 --> 00:05:22,030
и стерилизация,

68
00:05:22,030 --> 00:05:25,820
то есть encoding,
тоже почти в 4 раза быстрее.

69
00:05:25,820 --> 00:05:30,677
Поэтому, если вам нужен очень быстрый
упаковщик распаковщик json и это у

70
00:05:30,677 --> 00:05:34,860
вас узкое место,
то вы знаете, где его искать.

71
00:05:34,860 --> 00:05:39,420
Хорошо, давайте посмотрим теперь
ещё какие-нибудь примеры.

72
00:05:39,420 --> 00:05:44,860
Есть пример для поиска вхождения
какого-то слова в строке.

73
00:05:44,860 --> 00:05:52,426
У нас есть браузер, какой-то браузер,
и мы делаем 3 бенчмарка.

74
00:05:52,426 --> 00:05:58,690
Первый бенчмарк — мы каждый раз
компилируем регулярку при каждом вызове,

75
00:05:58,690 --> 00:06:02,899
то есть на каждую операцию
создается новая регулярка.

76
00:06:02,899 --> 00:06:08,417
Второй вариант — мы прикомпилировали
регулярку вот здесь,

77
00:06:08,417 --> 00:06:12,790
и на каждой итерации мы просто

78
00:06:12,790 --> 00:06:17,220
вызываем функцию матчинга на
прикомпилированной регулярке.

79
00:06:17,220 --> 00:06:24,210
И в третьем варианте мы просто вызываем
функцию contains из пакета strings.

80
00:06:24,210 --> 00:06:27,490
Давайте посмотрим, кто быстрее.

81
00:06:27,490 --> 00:06:33,635
[БЕЗ СЛОВ]

82
00:06:33,635 --> 00:06:40,224
Итого, судя

83
00:06:40,224 --> 00:06:46,114
по скорости и количеству итераций,
быстрее всего просто

84
00:06:46,114 --> 00:06:52,035
contains из пакета strings,
потом идет прикомпилированная регулярка,

85
00:06:52,035 --> 00:06:56,047
она успела сделать аж
10 миллионов операций,

86
00:06:56,047 --> 00:07:01,395
и совсем позади них идет
неприкомпилированная

87
00:07:01,395 --> 00:07:06,447
регулярка, которую мы
каждый раз компилируем.

88
00:07:06,447 --> 00:07:12,665
Посмотрите, она значительно отстает
от всех других показателей.

89
00:07:12,665 --> 00:07:17,306
Поэтому, если вдруг вы делаете
компиляцию регулярки каждый раз,

90
00:07:17,306 --> 00:07:19,610
остановитесь, это не очень хорошо.

91
00:07:19,610 --> 00:07:25,820
Давайте рассмотрим еще один вариант,

92
00:07:25,820 --> 00:07:29,360
еще один пример.

93
00:07:29,360 --> 00:07:36,320
У нас есть просто добавление
каких-то данных в слайс.

94
00:07:36,320 --> 00:07:40,760
В первом варианте мы создаем пустой слайс,
вообще пустой,

95
00:07:40,760 --> 00:07:44,790
и начинаем добавлять туда данные.

96
00:07:44,790 --> 00:07:48,985
Во втором варианте мы
создаем также слайс пустой,

97
00:07:48,985 --> 00:07:52,640
однако мы сразу создаем
capacity у того слайса.

98
00:07:52,640 --> 00:07:54,099
В чём разница?

99
00:07:54,099 --> 00:07:58,820
В первом случае мы создаем
сначала пустой слайс,

100
00:07:58,820 --> 00:08:03,755
и с каждой итерацией мы
добавляем туда значение.

101
00:08:03,755 --> 00:08:08,048
Чтобы вместить все значения,
ему нужно увеличивать слайс,

102
00:08:08,048 --> 00:08:14,298
то есть создавать новый слайс, копировать
туда данные, тем самым его расширяя.

103
00:08:14,298 --> 00:08:19,555
Получается 1, 2, 3,
4 — мы расширяем слайс несколько раз.

104
00:08:19,555 --> 00:08:23,606
При этом в преаллоцированном
варианте мы сразу указываем,

105
00:08:23,606 --> 00:08:27,970
что создай нам, пожалуйста,
большой слайс, большой capacity.

106
00:08:27,970 --> 00:08:35,090
Давайте посмотрим, что быстрее и почему.

107
00:08:35,090 --> 00:08:42,210
О!

108
00:08:42,210 --> 00:08:45,840
Смотрите, 327 операций,

109
00:08:45,840 --> 00:08:50,880
327 наносекунд на одну
операцию при пустом слайсе,

110
00:08:50,880 --> 00:08:55,920
248 байт на операцию и целых 5 аллокаций.

111
00:08:55,920 --> 00:09:00,660
При этом вариант с
преаллоцированным слайсом успел

112
00:09:00,660 --> 00:09:06,062
выполнить аж 100 миллионов операций,
потому что он тратит всего 19 наносекунд

113
00:09:06,062 --> 00:09:11,315
на операцию и делает 0 аллокаций.

114
00:09:11,315 --> 00:09:15,870
Поэтому преаллоцировать сразу нужный
объем в слайсе, это очень хорошо.

115
00:09:15,870 --> 00:09:20,765
В этом примере мы познакомились с тем,

116
00:09:20,765 --> 00:09:25,240
как вообще сравнивать бенчмарки,
как смотреть, какой из вариантов лучше.

117
00:09:25,240 --> 00:09:28,474
Однако из него непонятно,

118
00:09:28,474 --> 00:09:33,376
что именно тормозит,
что именно занимает время,

119
00:09:33,376 --> 00:09:37,410
что именно тратит память,
что именно делает аллокация памяти.

120
00:09:37,410 --> 00:09:43,567
В Go есть средства для того,
чтобы посмотреть это, для того,

121
00:09:43,567 --> 00:09:48,710
чтобы залезть внутрь и посмотреть
какую-то более детальную информацию.

122
00:09:48,710 --> 00:09:51,130
И это как раз тема следующего видео.