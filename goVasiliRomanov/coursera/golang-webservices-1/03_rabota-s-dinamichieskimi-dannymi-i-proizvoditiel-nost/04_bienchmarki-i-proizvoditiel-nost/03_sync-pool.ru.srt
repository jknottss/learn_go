1
00:00:00,000 --> 00:00:05,890
[БЕЗ_ЗВУКА] В

2
00:00:05,890 --> 00:00:11,176
примерах с распаковкой
бинарных данных мы видели,

3
00:00:11,176 --> 00:00:16,820
что пример с рефлексией, он медленней,
в нем больше аллокаций памяти,

4
00:00:16,820 --> 00:00:19,800
и он в целом требует больше
памяти на одну операцию.

5
00:00:19,800 --> 00:00:23,462
Это видно на экране.

6
00:00:23,462 --> 00:00:30,145
Рефлексия и кодогенерация.

7
00:00:30,145 --> 00:00:34,790
Возникает это потому,
что рантайму go нужно выделить память

8
00:00:34,790 --> 00:00:38,710
в данном случае каждый
раз на каждую операцию.

9
00:00:38,710 --> 00:00:43,274
Выделение памяти — на самом
деле это достаточно дорогая

10
00:00:43,274 --> 00:00:46,640
операция по сравнению со всем остальным.

11
00:00:46,640 --> 00:00:52,407
И иногда хочется не выделять
новую память каждый раз,

12
00:00:52,407 --> 00:00:55,550
а переиспользовать какой-то пул памяти,

13
00:00:55,550 --> 00:00:59,120
чтобы там уже были
приаллоцированные объекты.

14
00:00:59,120 --> 00:01:00,922
Это будет быстрее.

15
00:01:00,922 --> 00:01:06,330
В go есть инструмент для этого,
называется он sync.Pool.

16
00:01:06,330 --> 00:01:11,000
Посмотрим код.

17
00:01:11,000 --> 00:01:15,670
Итак, sync.Pool находится в пакете sync.

18
00:01:15,670 --> 00:01:20,380
Вот у нас есть тест,
у нас есть какая-то структура,

19
00:01:20,380 --> 00:01:26,970
где довольно много полей, то есть она
занимает достаточно много места в памяти.

20
00:01:26,970 --> 00:01:30,941
Есть какая-то тестовая структура
уже с заполненными данными,

21
00:01:30,941 --> 00:01:32,680
экземпляр этой структуры.

22
00:01:32,680 --> 00:01:35,143
Вот.
И какой-то список, да?

23
00:01:35,143 --> 00:01:37,980
Чтобы еще данных было еще побольше.

24
00:01:37,980 --> 00:01:43,566
Теперь рассмотрим первый тест,

25
00:01:43,566 --> 00:01:49,870
когда мы будем каждый раз
аллоцировать новые данные.

26
00:01:49,870 --> 00:01:54,672
Мы будем сериализовать этот

27
00:01:54,672 --> 00:01:59,510
набор структур, Pages, просто в json.

28
00:01:59,510 --> 00:02:04,460
В случае, если мы будем каждый
раз его аллоцировать с нуля,

29
00:02:04,460 --> 00:02:11,771
то мы будем каждый раз выделять
слайс байт на 64 байта вот здесь,

30
00:02:11,771 --> 00:02:16,680
создавать буфер, куда мы будем писать.

31
00:02:16,680 --> 00:02:23,140
После этого мы создадим json Encoder,
который умеет писать в тот буфер,

32
00:02:23,140 --> 00:02:26,930
который мы ему передадим,
ну и он делает Encode.

33
00:02:26,930 --> 00:02:31,353
То есть каждая операция,
каждая операция...

34
00:02:31,353 --> 00:02:35,000
Причем мы запускаем тест параллельно,

35
00:02:35,000 --> 00:02:39,715
то есть несколько тестов
будут идти одновременно.

36
00:02:39,715 --> 00:02:48,389
На каждую операцию, на каждый запуск этого
теста будет выделение памяти, каждый раз.

37
00:02:48,389 --> 00:02:52,782
Теперь рассмотрим вариант с пулом.

38
00:02:52,782 --> 00:02:58,410
Мы объявили переменную dataPool.

39
00:02:58,410 --> 00:03:03,100
dataPool — это в общем
экземпляр структуры sync.Pool,

40
00:03:03,100 --> 00:03:06,860
в нем есть только одна функция — New.

41
00:03:06,860 --> 00:03:13,292
Она возвращает нам новый объект,
если вдруг его не было уже в пуле.

42
00:03:13,292 --> 00:03:17,310
Ну, нам же нужно когда-то
инициализировать его.

43
00:03:17,310 --> 00:03:19,489
Мы должны всегда возврващать interface.

44
00:03:19,489 --> 00:03:22,520
Ну, потому что все-таки это
универсальный инструмент.

45
00:03:22,520 --> 00:03:25,697
Итак, мы просто возвращаем bytes.

46
00:03:25,697 --> 00:03:32,360
Фактически это то же самое, что мы делаем
при аллокации в рассмотренном тесте.

47
00:03:32,360 --> 00:03:34,895
Я это выделил, можно видеть.

48
00:03:34,895 --> 00:03:36,844
Это одна и та же строка.

49
00:03:36,844 --> 00:03:42,060
Вот.
Теперь тест, который

50
00:03:42,060 --> 00:03:47,042
не аллоцирует данные заново,
а берет их из пула.

51
00:03:47,042 --> 00:03:49,981
Итак, фактически это тот же самый код,

52
00:03:49,981 --> 00:03:53,795
в котором добавились несколько строк: раз,
два и три.

53
00:03:53,795 --> 00:03:57,643
Первая строка,
мы в ней раньше аллоцировали данные,

54
00:03:57,643 --> 00:04:01,075
а теперь мы обращаемся к пулу,
получаем элемент,

55
00:04:01,075 --> 00:04:05,397
и этот элемент сразу же преобразуем
к нужному нам типу, потому что там

56
00:04:05,397 --> 00:04:10,195
возвращается пустой interface,
просто так мы использовать его не можем.

57
00:04:10,195 --> 00:04:10,804
Хорошо.

58
00:04:10,804 --> 00:04:11,880
Получили Pool.

59
00:04:11,880 --> 00:04:16,500
Эта строка осталась без изменений,
мы по-прежнему сериализуем в него.

60
00:04:16,500 --> 00:04:19,656
Теперь идет отличие.

61
00:04:19,656 --> 00:04:26,700
Мы сбрасываем эти данные: мы их нигде
не использовали, мы их поэтому...

62
00:04:26,700 --> 00:04:31,700
тот слайс байт,
мы просто его сбрасываем: data.Reset.

63
00:04:31,700 --> 00:04:37,360
И возвращаем данные в
пул обратно: Put(data).

64
00:04:37,360 --> 00:04:39,796
Какой вариант быстрее?

65
00:04:39,796 --> 00:04:42,120
Ну давайте запускать.

66
00:04:42,120 --> 00:04:42,791
Так.

67
00:04:42,791 --> 00:04:48,710
Запускаем сразу с тестированием
памяти и смотрим.

68
00:04:48,710 --> 00:04:53,890
Вариант с аллокациями и вариант с пулом.

69
00:04:53,890 --> 00:04:58,646
Обратите внимание: вариант с аллокациями,
с новыми аллокациями,

70
00:04:58,646 --> 00:05:01,480
делает пять аллокаций на операцию.

71
00:05:01,480 --> 00:05:05,370
Вариант с пулом делает всего
две аллокации на операцию.

72
00:05:05,370 --> 00:05:12,019
При этом вариант с пулом тратит
всего 40 байт на операцию,

73
00:05:12,019 --> 00:05:18,390
а вариант с новыми аллокациями
тратит почти килобайт на операцию.

74
00:05:18,390 --> 00:05:21,560
Тысячу байт.

75
00:05:21,560 --> 00:05:27,721
За счет того, что мы держим данные в пуле,

76
00:05:27,721 --> 00:05:31,410
то есть нам не приходится
каждый раз их аллоцировать,

77
00:05:31,410 --> 00:05:34,866
у нас есть какое-то количество
приаллоцированных данных.

78
00:05:34,866 --> 00:05:38,860
Если они нам нужны, мы их оттуда берем,
используем и кладем обратно.

79
00:05:38,860 --> 00:05:42,364
Это гораздо выгоднее,
чем выделять память каждый раз,

80
00:05:42,364 --> 00:05:46,760
чтобы она потом была
убрана сборщиком мусора.

81
00:05:46,760 --> 00:05:48,631
Это просто эффективнее.

82
00:05:48,631 --> 00:05:52,911
Поэтому если вдруг у вас случаются случаи,
что вам нужно либо

83
00:05:52,911 --> 00:05:57,904
аллоцировать очень много структур,
либо же вам нужно аллоцировать много,

84
00:05:57,904 --> 00:06:02,770
там, слайс байт, куда вы что-то пишете
и потом сохраняете и выкидываете,

85
00:06:02,770 --> 00:06:07,688
то очень хорошим шагом будет
использовать sync.Pool.

86
00:06:07,688 --> 00:06:13,030
Он очень здорово экономит память,
и в целом инструмент это полезный.

87
00:06:13,030 --> 00:06:15,616
Конечно, sync.Pool — это не панацея.

88
00:06:15,616 --> 00:06:20,419
Вы не можете контролировать количество
объектов там, вы не можете контролировать,

89
00:06:20,419 --> 00:06:23,540
когда эти объекты действительно
очистятся сборщиком мусора.

90
00:06:23,540 --> 00:06:28,620
Да, вы вообще не контролируете там ничего,
кроме функции создания нового объекта.

91
00:06:28,620 --> 00:06:33,070
Когда очистить,
уже определяет garbage collector.

92
00:06:33,070 --> 00:06:37,620
Но в целом он очень эффективен.