[БЕЗ_ЗВУКА] Говоря о
тестировании какого-то кода, очень важным является вопрос
покрытия кода тестами. Что это значит? Мы можем написать довольно много разных
случаев тестирования, разных данных, но мы не знаем, какое количество реального
кода будут покрывать эти вызовы. В разных языках это решается по-разному. Где-то есть встроенные инструменты,
где-то это внешние инструменты, где-то их нет вообще. В Go подсчет покрытия тестами
встроен прямо в само тестирование. Давайте посмотрим, как это работает. Итак, у нас есть код,
есть какая-то структура User, есть какой-то список этих юзеров, и есть функция получения юзера. Что она делает? Она пытается получить этого
юзера по ключу из map'ки. Если он там есть, то она возвращает, распаковывает json и возвращает уже
непосредственно этого юзера как структуру. Если нет, то она ругается,
что такого пользователя нет. В случае, если не получилось распаковать
json, то тоже возвращается ошибка. Теперь давайте посмотрим на тест. Итак, тест User. У нас есть некоторое количество тестов. Один из них закоммутирован,
позже я покажу, почему. Итак, у нас есть тест ok с ключом ok. Он возвращает какого-то юзера,
и ошибки у него нет. IsError. Второй тест должен нам вернуть ошибку, и при этом юзера не вернут,
то есть это тест на какую-то ошибку. Вот после этого мы пройдем уже по
самим тестам, их будем получать. Но сам код тут не очень важен. Важно, как мы его будем запускать. Если мы запустим просто go test, то мы увидим, что наш тест прошел,
действительно, ничего не упало. Но вопрос покрытия непонятен. Для того чтобы читалось покрытие,
есть опция cover. Отлично. Наш тест прошел,
при этом покрытие всего 85 %. Хорошо, теперь мы узнали, что у нас
какая-то часть нашего кода не покрыта. То есть нашими тестами этот
код не был вызван никогда. Как это посмотреть? Ну, конечно, есть опция для того,
чтобы построить отчет по этому. Вы можете видеть ее на экране:
go tool cover, html указываем... Нет, go test coverprofile, мы строим непосредственно
вывод для отчета. Строим. Он нам записался. Теперь запускаем go tool cover,
указываем файл для отчета, из которого ему читать данные, и html,
куда ему записать отчет, уже в html форме. Запускаем. Вот так выглядит отчет. Зеленым отмечен тот код,
который запускается. То есть весь случай, когда у нас
данные найдены, они запускаются. При этом у нас запускается случай,
когда мы не смогли распаковать json. Однако вот эта строчка, красная,
она не запускается, потому что мы никогда не передавали туда данные,
которых нет в мапе с пользователями. Надо это исправить. Возьмем наш тест. И возьмем третий тест-кейс,
который пытается запросить данные по ключу not_exist, которого нет в нашей мапе. И теперь запустим. Мы раскомментировали эту строчку. Теперь запускаем тест сразу
с построением профиля. Отлично. 100 % профиля. Построим отчет. Отчет построен. Обновим. Теперь видно,
что эта строчка тоже запускалась. Давайте для примера
попробуем убрать случай, когда мы не можем распаковать json. Закомментируем вот эту строчку, сохраним,
еще раз построим тест с отчетом. Опять 87 %. Строим отчет. И теперь видим, что случай, когда какая-то ошибка нам вернулась,
то он не выполнился. Причем обратите внимание, if выполнился, потому что мы действительно проверяли,
что ошибка не равна nil. А вот то, что уже внутри этого,
не выполнилось. Это значит, что это условие никогда не
отрабатывало во время наших тестов. Вопрос покрытия лучше всего доводить до очень приемлемого уровня. Не всегда стоит стремиться к 100 %, однако если вы делаете какие-то
системные утилиты, более того, системные lib'ы, или какие-то
пакеты для других разработчиков, то есть не само бизнес-приложение,
то покрытие у него лучше стараться делать
максимально возможным. Это очень сильно уменьшит количество
багов, которые вам будут сообщать.