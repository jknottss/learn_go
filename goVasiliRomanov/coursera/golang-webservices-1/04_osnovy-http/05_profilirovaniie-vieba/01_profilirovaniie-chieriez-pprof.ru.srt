1
00:00:00,000 --> 00:00:05,891
[БЕЗ_ЗВУКА] В

2
00:00:05,891 --> 00:00:10,225
этом видео мы рассмотрим применение
профилировщика pprof для

3
00:00:10,225 --> 00:00:14,840
поиска горячих мест в уже работающей
программе под боевой нагрузкой.

4
00:00:14,840 --> 00:00:19,070
Профилировщик можно подключить,

5
00:00:19,070 --> 00:00:22,466
как обработчики каких-то URL-ов,

6
00:00:22,466 --> 00:00:27,780
по которым мы можем снять либо
профиль CPU, либо хип-дамп памяти.

7
00:00:27,780 --> 00:00:31,605
Выполняется это посредством подключения...

8
00:00:31,605 --> 00:00:34,798
импортирования пакета net/http/pprof.

9
00:00:34,798 --> 00:00:37,990
Поскольку мы не будем к
нему обращаться никак,

10
00:00:37,990 --> 00:00:42,630
то нужно написать префикс и
использовать пустую переменную.

11
00:00:42,630 --> 00:00:46,804
Сам пакет только
регистрирует некоторые свои

12
00:00:46,804 --> 00:00:51,058
обработчики в глобальном
обработчике функций.

13
00:00:51,058 --> 00:00:52,891
Вот HandleFunc, вот так.

14
00:00:52,891 --> 00:00:56,090
Ну теперь давайте
рассмотрим нашу программу.

15
00:00:56,090 --> 00:01:00,389
У нас есть какая-то структура,
есть обработчик запроса,

16
00:01:00,389 --> 00:01:05,552
который просто создает в цикле
структуру и после приводит

17
00:01:05,552 --> 00:01:10,260
ее к текстовому виду, к строке, и эту

18
00:01:10,260 --> 00:01:15,300
строку конкатенирует к общему результату,
который потом выводится наверх.

19
00:01:15,300 --> 00:01:17,035
Выглядит это вот так.

20
00:01:17,035 --> 00:01:20,880
То есть много-много-много каких-то данных.

21
00:01:20,880 --> 00:01:28,770
Теперь для того,
чтобы снять хип-дамп и профиль CPU,

22
00:01:28,770 --> 00:01:32,875
нам нужно дернуть URL-ы debug/pprof/heap и

23
00:01:32,875 --> 00:01:38,142
debug/pprof/profile для снятия CPU,

24
00:01:38,142 --> 00:01:42,725
при этом мы можем указать
в параметре seconds,

25
00:01:42,725 --> 00:01:46,756
за сколько времени мы
хотим снять профиль CPU.

26
00:01:46,756 --> 00:01:50,331
Далее, используя pprof, саму команду,

27
00:01:50,331 --> 00:01:54,275
мы можем построить .svg файл
по полученным результатам.

28
00:01:54,275 --> 00:01:57,445
То есть это уже не обязательно
делать под боевой нагрузкой.

29
00:01:57,445 --> 00:02:01,198
Мы можем снять хип-дамп
или профиль процессора,

30
00:02:01,198 --> 00:02:04,448
увести это туда, где никакой нагрузки нет,

31
00:02:04,448 --> 00:02:09,040
где это не затронет пользователей, и там
уже строить, и там уже искать узкие места.

32
00:02:09,040 --> 00:02:12,140
Давайте попробуем это запустить.

33
00:02:12,140 --> 00:02:18,189
Итак, у меня запущена программа,
у меня готов к запуску файл,

34
00:02:18,189 --> 00:02:25,168
сейчас я подам нагрузку через
стандартную утилиту ab для бенчмарка.

35
00:02:25,168 --> 00:02:29,441
Запускаем, снимаем стек-трейс.

36
00:02:29,441 --> 00:02:32,107
Три, четыре, пять.

37
00:02:32,107 --> 00:02:33,228
Отлично.

38
00:02:33,228 --> 00:02:35,600
Стек-трейс поднят.

39
00:02:35,600 --> 00:02:37,618
Нагрузку отключили.

40
00:02:37,618 --> 00:02:44,110
Теперь давайте посмотрим, как выглядят
результаты, и что мы там можем найти.

41
00:02:44,110 --> 00:02:47,582
Итак, у нас есть несколько файлов.

42
00:02:47,582 --> 00:02:51,977
cpu — это профиль CPU,
и mem_ao — это количество

43
00:02:51,977 --> 00:02:56,816
аллоцированных объектов, то есть в
каких местах у нас были аллокации.

44
00:02:56,816 --> 00:02:57,780
Начнем с cpu.

45
00:02:57,780 --> 00:03:01,820
Давайте для начала начнем наш профиль,
наш обработчик.

46
00:03:01,820 --> 00:03:03,970
Ага, вот он: main.handle.

47
00:03:03,970 --> 00:03:07,850
Он по CPU работал 3,76 секунды.

48
00:03:07,850 --> 00:03:08,890
И что он делал?

49
00:03:08,890 --> 00:03:12,970
То есть далее мы можем посмотреть,
куда ушло от него время.

50
00:03:12,970 --> 00:03:16,268
Итак, 3,59 секунды ушло на Sprintf,

51
00:03:16,268 --> 00:03:21,315
и 2,97 секунды ушло на конкатенацию строк.

52
00:03:21,315 --> 00:03:24,920
Sprintf — что он делает, Sprintf?

53
00:03:24,920 --> 00:03:29,259
Он внутри,
ему нужно пройти через interface и через

54
00:03:29,259 --> 00:03:34,110
reflect и привести это к строке.

55
00:03:34,110 --> 00:03:39,065
То есть это как раз CPU-intensive,
CPU нагрузка.

56
00:03:39,065 --> 00:03:44,478
А concatstring, ну,
давайте посмотрим на наш код.

57
00:03:44,478 --> 00:03:46,620
Вот concatstring.

58
00:03:46,620 --> 00:03:52,085
То есть нам надо выделить строку,

59
00:03:52,085 --> 00:03:56,430
добавить ее еще к строке, то есть
каждый раз у нас получается аллокация.

60
00:03:56,430 --> 00:04:00,670
Это достаточно тяжелая операция, если
очень долго так делать, это невыгодно.

61
00:04:00,670 --> 00:04:04,031
А давайте посмотрим теперь, что по памяти.

62
00:04:04,031 --> 00:04:05,889
Найдем наш обработчик.

63
00:04:05,889 --> 00:04:07,750
Вот он, main.handle.

64
00:04:07,750 --> 00:04:10,563
И где были основные выделения?

65
00:04:10,563 --> 00:04:17,550
Вот выделение строки, выделение строки
и runtime — это создание новой строки.

66
00:04:17,550 --> 00:04:24,500
Теперь Printf,
вот основную память ел Printf.

67
00:04:24,500 --> 00:04:29,520
Sprintf, вот он тоже выделял строку

68
00:04:29,520 --> 00:04:34,190
и внутри он делал структуры из пакета

69
00:04:34,190 --> 00:04:38,860
reflect.(*structType).Field для того,
чтобы по ним как-то пройтись и посчитать.

70
00:04:38,860 --> 00:04:41,601
Ну и тоже он выделял память.

71
00:04:41,601 --> 00:04:47,159
То есть используя этот граф,
мы можем хотя бы найти, в каких местах,

72
00:04:47,159 --> 00:04:52,770
где у нас есть горячие места,
их даже визуально видно.

73
00:04:52,770 --> 00:04:57,795
То есть это очень мощный инструмент для
отладки программ в продакшене без того,

74
00:04:57,795 --> 00:05:01,530
чтобы пытаться создать такого
рода нагрузку синтетически.