[БЕЗ СЛОВ] Если рассматривать граф, который получается через pprof,
например, граф аллокации памяти, либо же граф использования процессора, то мы видим,
что происходило с высоты птичьего полета. Но иногда нам хочется посмотреть,
а как развивались события. То есть не что получилось в итоге,
в целом, а как оно именно шло в
процессе работы программы: где были затыки, когда случались аллокации, когда случалась остановка
на сборку мусора. В Go опять-таки есть для этого инструмент,
называется он трассировка, и в данном примере мы его рассмотрим. Наша программа в данном случае не имеет очень большого значения, у нас есть какая-то структура,
какой-то результат, мы много раз эту структуру сериализуем
в json и добавляем как строку. На этом же примере мы рассматривали pprof. Единственное что,
я установил тут количество процессоров, которые может использовать программа на 4,
просто чтобы оно всё помещалось у меня на экране уже в обзоре трассировки. Сначала давайте это запустим. Так, терминал 1. Запустили программу. Как она выглядит? Вот выглядит она примерно вот так. То есть просто вывод
какого-то текста на экраны, то есть довольно много разных аллокаций. Хорошо. Запустили программу. Теперь запустим benchmark,
у меня есть для этого отдельный терминал. Запустили инертный Apache benchmark,
он нам начал создавать какую-то нагрузку. Теперь соберем трассировку
за восемь секунд. Раз, два, три, четыре. Хорошо, трассировку собрали, benchmark остановили. Теперь запускаем, используя go tool trace,
запускаем http-сервер, который позволит нам визуализировать
результат этой трассировки. Итак, go tool trace, указываем http, на
каком порту нам разворачивать этот сервер. Указываем бинарник наш и,
собственно, дам с данными, непосредственно с трассировкой,
которые мы собрали с работающей программы. Я отдельно еще раз обращу ваше внимание,
что такого рода трассировку вы можете снять с
работающей в бою программе, работающей в продакшне
программе под нагрузкой, снять трассировку и уже разбираться с ней, уже отлаживать ее на своей
разработческой машине, уже никак не влияя на продакшн. Да, конечно, трассировка все-таки
немножко замедляет время работы, однако снять несколько секунд
трассировки это вполне допустимо, и вы вряд ли умрете от этого. Хорошо. Теперь запускаем трассировку. Какое-то время она будет анализировать,
этот trace, он немаленький получается. Для визуализации Chrome у меня отжирает
полтора гигабайта памяти этого дела. Итак, вот нам открылся этот
сервер с трассировкой. Мы можем посмотреть за различные периоды, что происходило,
и собрать какую-то другую статистику. Для начала давайте посмотрим просто,
что происходило в программе. Опять-таки какое-то время он будет думать. Импортируется. Я не врал вам про полтора
гигабайта памяти. Так. Отлично, мы дождались. Хорошо, вот перед нами
общий экран трассировки. Слева, обратите внимание,
идет некая информация Heap'а, сколько у нас памяти было задействовано,
количество горутин, которые у нас одновременно работали,
количество системных тредов, в которых работали эти горутины. Дальше у нас идет еще информация,
сеть, syscalls и процессоры. Proc — это как раз-таки системное ядро, в котором крутятся наши треды,
а в тредах крутятся наши горутины. Ну сверху тут совсем ничего не видно,
потому что это информация аж за четыре секунды, и теперь давайте
попробуем приблизить, zoom. Вот у нас есть какое-то пустое
пространство, вот здесь, приблизим вот туда. В это время мы не работали,
а что у нас происходило? А происходила у нас сборка мусора. Обратите внимание, в GC есть что-то,
есть сборка, а работы никакой нет. Попробуем GC, прокрутим вниз. Да, GC. Теперь, если покликать в различные места,
например, что происходило вот здесь,
это не видно, нужно еще приблизить. Тут прямо видно,
какая горутина выполнялась. Если еще развернуть, и еще, и теперь покрутить вбок, то вот тут можно заметить, что происходили sysread'ы,
а вот здесь на этом этапе, давайте еще приблизим,
а вот на этом этапе, где-то вот здесь,
происходила сериализация json'а. Но в основном у меня
получается попадать... Да, отлично! Происходила сериализаци json'а. Да, вот мы дошли и входим в json. Вот он. Если идти дальше, то мы будем видеть
все выделения памяти и прочее. Если прокрутить немножко вбок,
можно заметить SWEEP. SWEEP — это инструмент garbage
collector'а, который работает с памятью. Я не буду в это углубляться. Вот, то есть в целом вы можете посмотреть, что происходило во время
работы вашей горутины и куда, более того,
на каких процессах она выполнялась. Тут есть разные приходы. Да, это тоже не панацея, но при помощи этого инструмента тоже
можно получить какую-то информацию, если вдруг у вас есть нет понимания,
что происходит в вашей программе. Когда случались паузы вообще на всю
программу, сколько они занимают, сколько занимают и работают
отдельные горутины. К сожалению или к счастью, в Go нельзя
пометить отдельную горутину именем, но тем не менее,
используя этот инструмент, мы можем посмотреть,
какая горутина сколько времени работала. Ну вот, например, у нас есть здесь список,
откроем какой-то список, тут тоже есть довольно много информации,
сколько горутина ждала, чего и как. Ну вот, например,
откроем какую-нибудь, ну вот эту. Да, вот работа нашей горутины. А смотрите, вот мы начали, что тут происходит? Вот мы начали. Ага. Непосредственно main handle,
потом видим какое-то пустое место, то есть горутина эта не работала наша. Потом она поработала еще немножко. Это опять-таки наша горутина. То есть вот в это время
работали другие горутины, то есть мы поймали выделение памяти,
что дальше? Еще выделения памяти. Что дальше? Давайте дальше прокрутим. И вот еще, тут уже прямо много. О, json! Приближаем, приближаем, приближаем. Вот здесь мы можем видеть,
что json и скорее всего вот тут, и тут тоже json,
и вот здесь json, и вот здесь. Вот это все крупное —
это сериализация в json. И выделение памяти,
то есть конкатенация к строке. Ну вот garbage collection. То есть мы прямо видим, что где работало. Да, это вам не поможет поймать некоторые утечки памяти,
которые хорошо видны в pprof'е. Но какое-то понимание работы в вашей
программе вам этот инструмент даст. Скажу честно, мне в работе пока
не приходилось им пользоваться, все мои нужды полностью
удовлетворял стандартный pprof. И все, что надо, я находил там. Однако если вы начинающий разработчик и
вам очень хочется залезть прямо в кишки вашей программе и посмотреть,
когда что работало, то это очень полезный
инструмент для изучения.