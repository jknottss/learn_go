1
00:00:00,000 --> 00:00:09,372
[БЕЗ СЛОВ] Если рассматривать граф,

2
00:00:09,372 --> 00:00:14,216
который получается через pprof,
например, граф аллокации памяти,

3
00:00:14,216 --> 00:00:17,967
либо же граф использования процессора,

4
00:00:17,967 --> 00:00:22,799
то мы видим,
что происходило с высоты птичьего полета.

5
00:00:22,799 --> 00:00:27,962
Но иногда нам хочется посмотреть,
а как развивались события.

6
00:00:27,962 --> 00:00:31,612
То есть не что получилось в итоге,
в целом,

7
00:00:31,612 --> 00:00:36,597
а как оно именно шло в
процессе работы программы: где

8
00:00:36,597 --> 00:00:40,875
были затыки, когда случались аллокации,

9
00:00:40,875 --> 00:00:46,140
когда случалась остановка
на сборку мусора.

10
00:00:46,140 --> 00:00:51,063
В Go опять-таки есть для этого инструмент,
называется он трассировка,

11
00:00:51,063 --> 00:00:53,570
и в данном примере мы его рассмотрим.

12
00:00:53,570 --> 00:00:59,420
Наша программа в данном случае

13
00:00:59,420 --> 00:01:05,250
не имеет очень большого значения,

14
00:01:05,250 --> 00:01:09,989
у нас есть какая-то структура,
какой-то результат,

15
00:01:09,989 --> 00:01:15,075
мы много раз эту структуру сериализуем
в json и добавляем как строку.

16
00:01:15,075 --> 00:01:17,990
На этом же примере мы рассматривали pprof.

17
00:01:17,990 --> 00:01:25,121
Единственное что,
я установил тут количество процессоров,

18
00:01:25,121 --> 00:01:31,553
которые может использовать программа на 4,
просто чтобы оно всё помещалось

19
00:01:31,553 --> 00:01:36,594
у меня на экране уже в обзоре трассировки.

20
00:01:36,594 --> 00:01:39,710
Сначала давайте это запустим.

21
00:01:39,710 --> 00:01:42,298
Так, терминал 1.

22
00:01:42,298 --> 00:01:45,350
Запустили программу.

23
00:01:45,350 --> 00:01:46,978
Как она выглядит?

24
00:01:46,978 --> 00:01:50,040
Вот выглядит она примерно вот так.

25
00:01:50,040 --> 00:01:52,469
То есть просто вывод
какого-то текста на экраны,

26
00:01:52,469 --> 00:01:54,510
то есть довольно много разных аллокаций.

27
00:01:54,510 --> 00:01:55,504
Хорошо.

28
00:01:55,504 --> 00:01:57,990
Запустили программу.

29
00:01:57,990 --> 00:02:04,100
Теперь запустим benchmark,
у меня есть для этого отдельный терминал.

30
00:02:04,100 --> 00:02:10,320
Запустили инертный Apache benchmark,
он нам начал создавать какую-то нагрузку.

31
00:02:10,320 --> 00:02:16,250
Теперь соберем трассировку
за восемь секунд.

32
00:02:16,250 --> 00:02:20,980
Раз, два, три, четыре.

33
00:02:20,980 --> 00:02:25,503
Хорошо, трассировку собрали,

34
00:02:25,503 --> 00:02:28,900
benchmark остановили.

35
00:02:28,900 --> 00:02:35,615
Теперь запускаем, используя go tool trace,
запускаем http-сервер,

36
00:02:35,615 --> 00:02:40,090
который позволит нам визуализировать
результат этой трассировки.

37
00:02:40,090 --> 00:02:46,320
Итак, go tool trace, указываем http, на
каком порту нам разворачивать этот сервер.

38
00:02:46,320 --> 00:02:52,132
Указываем бинарник наш и,
собственно, дам с данными,

39
00:02:52,132 --> 00:02:57,906
непосредственно с трассировкой,
которые мы собрали с работающей программы.

40
00:02:57,906 --> 00:03:02,791
Я отдельно еще раз обращу ваше внимание,
что такого рода

41
00:03:02,791 --> 00:03:08,500
трассировку вы можете снять с
работающей в бою программе,

42
00:03:08,500 --> 00:03:12,134
работающей в продакшне
программе под нагрузкой,

43
00:03:12,134 --> 00:03:15,864
снять трассировку и уже разбираться с ней,

44
00:03:15,864 --> 00:03:21,141
уже отлаживать ее на своей
разработческой машине,

45
00:03:21,141 --> 00:03:25,200
уже никак не влияя на продакшн.

46
00:03:25,200 --> 00:03:31,082
Да, конечно, трассировка все-таки
немножко замедляет время работы,

47
00:03:31,082 --> 00:03:35,824
однако снять несколько секунд
трассировки это вполне допустимо,

48
00:03:35,824 --> 00:03:39,160
и вы вряд ли умрете от этого.

49
00:03:39,160 --> 00:03:39,821
Хорошо.

50
00:03:39,821 --> 00:03:42,136
Теперь запускаем трассировку.

51
00:03:42,136 --> 00:03:46,767
Какое-то время она будет анализировать,
этот trace,

52
00:03:46,767 --> 00:03:50,330
он немаленький получается.

53
00:03:50,330 --> 00:03:56,212
Для визуализации Chrome у меня отжирает
полтора гигабайта памяти этого дела.

54
00:03:56,212 --> 00:04:00,477
Итак, вот нам открылся этот
сервер с трассировкой.

55
00:04:00,477 --> 00:04:05,700
Мы можем посмотреть за различные периоды,

56
00:04:05,700 --> 00:04:08,955
что происходило,
и собрать какую-то другую статистику.

57
00:04:08,955 --> 00:04:12,730
Для начала давайте посмотрим просто,
что происходило в программе.

58
00:04:12,730 --> 00:04:18,040
Опять-таки какое-то время он будет думать.

59
00:04:18,040 --> 00:04:19,530
Импортируется.

60
00:04:19,530 --> 00:04:23,210
Я не врал вам про полтора
гигабайта памяти.

61
00:04:23,210 --> 00:04:31,210
Так.

62
00:04:31,210 --> 00:04:37,580
Отлично, мы дождались.

63
00:04:37,580 --> 00:04:41,605
Хорошо, вот перед нами
общий экран трассировки.

64
00:04:41,605 --> 00:04:47,304
Слева, обратите внимание,
идет некая информация Heap'а,

65
00:04:47,304 --> 00:04:51,294
сколько у нас памяти было задействовано,
количество горутин,

66
00:04:51,294 --> 00:04:55,613
которые у нас одновременно работали,
количество системных тредов,

67
00:04:55,613 --> 00:04:58,098
в которых работали эти горутины.

68
00:04:58,098 --> 00:05:04,005
Дальше у нас идет еще информация,
сеть, syscalls и процессоры.

69
00:05:04,005 --> 00:05:07,421
Proc — это как раз-таки системное ядро,

70
00:05:07,421 --> 00:05:11,874
в котором крутятся наши треды,
а в тредах крутятся наши горутины.

71
00:05:11,874 --> 00:05:16,512
Ну сверху тут совсем ничего не видно,
потому что это информация аж за четыре

72
00:05:16,512 --> 00:05:21,200
секунды, и теперь давайте
попробуем приблизить, zoom.

73
00:05:21,200 --> 00:05:24,158
Вот у нас есть какое-то пустое
пространство, вот здесь,

74
00:05:24,158 --> 00:05:25,230
приблизим вот туда.

75
00:05:25,230 --> 00:05:32,770
В это время мы не работали,
а что у нас происходило?

76
00:05:32,770 --> 00:05:35,054
А происходила у нас сборка мусора.

77
00:05:35,054 --> 00:05:41,301
Обратите внимание, в GC есть что-то,
есть сборка, а работы никакой нет.

78
00:05:41,301 --> 00:05:45,944
Попробуем GC, прокрутим вниз.

79
00:05:45,944 --> 00:05:47,420
Да, GC.

80
00:05:47,420 --> 00:05:51,801
Теперь, если покликать в различные места,
например,

81
00:05:51,801 --> 00:05:57,110
что происходило вот здесь,
это не видно, нужно еще приблизить.

82
00:05:57,110 --> 00:06:01,760
Тут прямо видно,
какая горутина выполнялась.

83
00:06:01,760 --> 00:06:07,590
Если еще развернуть,

84
00:06:07,590 --> 00:06:13,840
и еще, и теперь покрутить вбок,

85
00:06:13,840 --> 00:06:18,450
то вот тут можно заметить,

86
00:06:18,450 --> 00:06:23,272
что происходили sysread'ы,
а вот здесь на этом этапе,

87
00:06:23,272 --> 00:06:27,124
давайте еще приблизим,
а вот на этом этапе,

88
00:06:27,124 --> 00:06:32,400
где-то вот здесь,
происходила сериализация json'а.

89
00:06:32,400 --> 00:06:35,845
Но в основном у меня
получается попадать...

90
00:06:35,845 --> 00:06:36,970
Да, отлично!

91
00:06:36,970 --> 00:06:40,041
Происходила сериализаци json'а.

92
00:06:40,041 --> 00:06:42,813
Да, вот мы дошли и входим в json.

93
00:06:42,813 --> 00:06:43,510
Вот он.

94
00:06:43,510 --> 00:06:49,700
Если идти дальше, то мы будем видеть
все выделения памяти и прочее.

95
00:06:49,700 --> 00:06:55,387
Если прокрутить немножко вбок,
можно заметить SWEEP.

96
00:06:55,387 --> 00:07:00,044
SWEEP — это инструмент garbage
collector'а, который работает с памятью.

97
00:07:00,044 --> 00:07:02,120
Я не буду в это углубляться.

98
00:07:02,120 --> 00:07:05,267
Вот, то есть в целом вы можете посмотреть,

99
00:07:05,267 --> 00:07:09,468
что происходило во время
работы вашей горутины и куда,

100
00:07:09,468 --> 00:07:14,320
более того,
на каких процессах она выполнялась.

101
00:07:14,320 --> 00:07:19,450
Тут есть разные приходы.

102
00:07:19,450 --> 00:07:21,013
Да, это тоже не панацея,

103
00:07:21,013 --> 00:07:25,632
но при помощи этого инструмента тоже
можно получить какую-то информацию,

104
00:07:25,632 --> 00:07:29,858
если вдруг у вас есть нет понимания,
что происходит в вашей программе.

105
00:07:29,858 --> 00:07:34,040
Когда случались паузы вообще на всю
программу, сколько они занимают,

106
00:07:34,040 --> 00:07:37,980
сколько занимают и работают
отдельные горутины.

107
00:07:37,980 --> 00:07:42,392
К сожалению или к счастью, в Go нельзя
пометить отдельную горутину именем,

108
00:07:42,392 --> 00:07:45,423
но тем не менее,
используя этот инструмент,

109
00:07:45,423 --> 00:07:50,345
мы можем посмотреть,
какая горутина сколько времени работала.

110
00:07:50,345 --> 00:07:54,710
Ну вот, например, у нас есть здесь список,
откроем какой-то список,

111
00:07:54,710 --> 00:07:59,628
тут тоже есть довольно много информации,
сколько горутина ждала, чего и как.

112
00:07:59,628 --> 00:08:03,740
Ну вот, например,
откроем какую-нибудь, ну вот эту.

113
00:08:03,740 --> 00:08:10,190
Да, вот работа нашей горутины.

114
00:08:10,190 --> 00:08:15,225
А смотрите,

115
00:08:15,225 --> 00:08:20,259
вот мы начали, что тут происходит?

116
00:08:20,259 --> 00:08:21,991
Вот мы начали.

117
00:08:21,991 --> 00:08:22,660
Ага.

118
00:08:22,660 --> 00:08:27,518
Непосредственно main handle,
потом видим какое-то пустое место,

119
00:08:27,518 --> 00:08:30,261
то есть горутина эта не работала наша.

120
00:08:30,261 --> 00:08:32,907
Потом она поработала еще немножко.

121
00:08:32,907 --> 00:08:35,296
Это опять-таки наша горутина.

122
00:08:35,296 --> 00:08:40,580
То есть вот в это время
работали другие горутины,

123
00:08:40,580 --> 00:08:45,003
то есть мы поймали выделение памяти,
что дальше?

124
00:08:45,003 --> 00:08:46,820
Еще выделения памяти.

125
00:08:46,820 --> 00:08:48,009
Что дальше?

126
00:08:48,009 --> 00:08:50,610
Давайте дальше прокрутим.

127
00:08:50,610 --> 00:08:53,256
И вот еще, тут уже прямо много.

128
00:08:53,256 --> 00:08:54,138
О, json!

129
00:08:54,138 --> 00:08:57,680
Приближаем, приближаем, приближаем.

130
00:08:57,680 --> 00:09:03,093
Вот здесь мы можем видеть,
что json и скорее

131
00:09:03,093 --> 00:09:08,190
всего вот тут, и тут тоже json,
и вот здесь json, и вот здесь.

132
00:09:08,190 --> 00:09:11,814
Вот это все крупное —
это сериализация в json.

133
00:09:11,814 --> 00:09:15,900
И выделение памяти,
то есть конкатенация к строке.

134
00:09:15,900 --> 00:09:18,146
Ну вот garbage collection.

135
00:09:18,146 --> 00:09:21,520
То есть мы прямо видим, что где работало.

136
00:09:21,520 --> 00:09:26,313
Да, это вам не поможет поймать

137
00:09:26,313 --> 00:09:30,090
некоторые утечки памяти,
которые хорошо видны в pprof'е.

138
00:09:30,090 --> 00:09:35,410
Но какое-то понимание работы в вашей
программе вам этот инструмент даст.

139
00:09:35,410 --> 00:09:40,160
Скажу честно, мне в работе пока
не приходилось им пользоваться,

140
00:09:40,160 --> 00:09:44,910
все мои нужды полностью
удовлетворял стандартный pprof.

141
00:09:44,910 --> 00:09:47,514
И все, что надо, я находил там.

142
00:09:47,514 --> 00:09:52,461
Однако если вы начинающий разработчик и
вам очень хочется залезть прямо в кишки

143
00:09:52,461 --> 00:09:57,294
вашей программе и посмотреть,
когда что работало,

144
00:09:57,294 --> 00:10:03,120
то это очень полезный
инструмент для изучения.