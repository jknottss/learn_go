[БЕЗ_ЗВУКА] В этом видео мы начнем рассматривать возможности Go для
построения уже каких-то реальных систем. Начнем мы с работы с сетью и будем слушать tcp socket и обрабатывать входящие
команды, которые туда кто-то будет слать. Итак, с чего мы начинаем? Начинаем мы с того, что мы создаем объект, который будет собственно слушать
socket tcp на порту 88... 8080. И дальше начнем обрабатывать
входящие соединения. Каким образом это происходит? Вызывается функция accept,
и как только кто-то подключается, мы в отдельной горутине начинаем
обрабатывать это соединение. Каким образом мы его обрабатываем? Давайте смотреть. Итак, для начала мы пытаемся
получить имя удаленного соединения, просто его адрес для удобства. Печатаем нам в консоль,
что кто-то соединился. Печатаем тому, кто соединился, «Здрасьте». Как печатаем? Дело в том, что net.Conn, вот эта
вот структура, которая нам приходит, она реализует интерфейс io.Writer,
и не только его, то есть это значит, что мы можем туда писать какие-то данные,
используя slice byte. Что мы делаем? Дальше для defer мы указываем,
что соединение закрыть на всякий случай,
чтобы не было никаких утечек. Дальше мы создаем scanner, который
будет нам ожидать ввода пустой строки. И пока к нам что-то приходит,
мы будем смотреть, что это приходит, и обрабатывать. Если нам ввели exit, то мы попрощаемся с
соединением и прекратим его обработку. То есть сработает defer,
соединение закроется, и все. Ну, если нам придет какой-то непустой
text, мы его выведем на экран. Давайте это запустим. Запустили. Все хорошо. Теперь откроем консоль. И подключимся по telnet к нашему сервису. Опа! Нам напечатало, что такой-то соединился, напечатало приветствие в это соединение, отлично. [ЗВУК] Вот You enter Test. You enter Hello World! это уже работа нашей программы,
которая нам в консоль пишет, что такой-то ввел Test,
такой-то ввел Hello World. При этом за счет того что мы обрабатываем
каждое соединение в отдельной горутине, мы можем подключиться к
этому серверу еще раз, что и сделаем. [ЗВУК] Отлично. Смотрите. У нас уже другой порт. 8781 При этом здесь мы тоже это видим. Ну и мы можем отсоединиться. Все, мы отсоединились, с нами попрощались. Соединение разорвано. 8781 отконнектился. То есть, смотрите,
мы буквально десятью строчками создали tcp-сервер,
с которым уже можно работать. Такого рода сервер, такого рода механизм лежит в основе практически
любого tcp-сервера, и, собственно, это само сердце любого сетевого сервиса. Давайте посмотрим, а что будет,
если убрать вот это. Что будет, если убрать обработку
каждого соединения в отдельном сервисе? Уберем. Тут всё почистим. И тут всё почистим. Так. Теперь давайте запустим это еще раз. Напоминаю, мы сейчас не обрабатываем
соединение в отдельной горутине. Запустили. Подключаемся с первой консоли. [ЗВУК] Подключились. Работает. Теперь попробуем подключиться
из второй консоли. Не работает. Почему? Потому что мы крутим здесь
вот этот цикл все время. Мы работаем внутри горутины main и,
пока одно из соединений, то есть первое, которое мы приняли, оно не прекратит
работу, пока мы находимся внутри вот этой функции handleConnection, мы не сможем
попробовать никакие другие соединения. То есть это однопоточный
получается сервер. Теперь давайте отсюда выйдем вот так. И мы сразу же смогли подключиться вторым
соединением, как только вышли из первого. [ЗВУК] Поэтому вот буквально одной командой мы делаем
наш сервер сразу же многопоточным. Но это просто tcp. tcp-сервер — это на
самом деле очень важно, это первое, с чего начинается сервер. Но обычно нас интересует более прикладной
характер и интересует http-сервер. В go есть встроенный http-сервер, который
мы рассмотрим позднее, в отдельном видео.