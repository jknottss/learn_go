[БЕЗ_ЗВУКА] В этом видео мы рассмотрим
работу с шаблонами, которые предоставляет
стандартная библиотека Go. Шаблонизация в виде отдельного
шаблона — это давно... ну как бы признак хорошего тона. Уже никто не мешает код вместе с логикой
и не выводит его построчно по одному тегу на экран, как это было давным-давно
в темные времена веб-разработки. Итак, шаблоны в Go есть
в нескольких вариантах. Первый, из которых мы
рассмотрим — это text/template. text/template — это простые шаблоны. Они все выводят, как есть,
как мы им скажем. Для начала давайте определим
параметры шаблонизатора. Вот у меня такие параметры,
там есть URL и Browser, обе строчки. Сам шаблон, в котором я вывожу непосредственно
браузер и URL, который передали. Для доступа к переменным мне нужно... я использую двойные
фигурные скобки и точку. Точка — это текущий элемент,
с которым мы работаем. В данном случае текущий элемент — это
непосредственно вот этот tplParams, который я передам. В случае, если у нас будет
какой-то цикл по значениям, то точка будет являться элементом цикла. Итак, теперь давайте скомпилируем. В этом месте мы компилируем шаблон. Мы делаем это не очень быстро, потому что компилируем его на каждый вызов
http реквеста, но для примера нам хватит. Теперь создадим параметры, используя то,
что нам пришло из браузера. И непосредственно запустим,
«экспанднем» шаблон. Тут я передаю ResponseWriter туда,
то есть результат экспана шаблона будет передан сразу в браузер,
и параметры. Запускаем. [ЗВУК] Запустилось. Пробуем. Отлично. Он мне вывел браузер,
какой у меня есть, и URL, на котором я нахожусь,
в данном случае корень. Если я попробую какой-то другой URL,
например, вот так, то он уже будет иметь другое значение. Но это простые текстовые шаблоны, которые хороши в случаях, когда нам не
надо ничего эскейпить и нет возможности передать какие-то лишние данные
в шаблон от пользователя. В этом примере мы
рассмотрим http/template. http/template, он несколько более сложен,
чем text/template, потому что он добавляет необходимое
экранирование к вводимым символам, причем он знает, где это,
какое экранирование должно быть. То есть в URL-ах он сделает URL escape, в HTML он заэскейпит все HTML сущности, чтобы нельзя было сделать какой-нибудь
XSS Ну и также давайте мы будем экспандить не из
подготовленного куска внутри нашего кода, а из внешнего файла. Итак, вот у нас есть функция main. В данном... На строчке 16 мы парсим шаблон. Мы парсим его один раз при старте сервера,
users.html. Создаем пользователей. Ну, у нас будет какой-то небольшой кусок,
небольшой объем пользователей, то есть юзер имеет ID,
имя и флаг, он активен или нет. Вот.
Итак, обратите внимание: на строчке 20 у
Ивана имя заключено в тег какой-то. По идее, это должно отобразиться,
но это будет не так. Ну и теперь мы уже будем
экспандить этот шаблон. Вот наша функция,
которая будет вызываться. Что мы делаем? Мы говорим: tmpl.Execute, что нужно
сделать шаблон из того, что мы передали, передаем туда Writer,
в качестве параметра я не использую заранее подготовленную структуру,
а определяю прямо на месте. Вот здесь. То есть и сразу же создаю
экземпляр этой структуры вот тут, куда передаю наших пользователей. Теперь давайте рассмотрим шаблон. Это простой шаблон, в котором я просто иду
по всем пользователям и вывожу его имя. Обратите внимание: тут
я иду по пользователям, то есть пользователи — это, скажем так, элемент первого уровня, который я туда
передал, элемент поля базовой структуры. Вот. А name, name — это уже поле
конкретного пользователя, то есть поле той структуры,
которая находится в данном итерации цикле. if — какие же шаблоны без условий? Вот.
Это шаблон. Теперь надо запустить. [ЗВУК] [ЗВУК] Запустили. Итак, вывелись на экран наши пользователи. Это заголовок. Василий активен, Иван... Обратите внимание: теги заменились
на HTML-сущности, то есть это не является тегом, это просто текст, и
он не активен, Ну и Дмитрий тоже активен. Вот. Это что касается простых шаблонов.