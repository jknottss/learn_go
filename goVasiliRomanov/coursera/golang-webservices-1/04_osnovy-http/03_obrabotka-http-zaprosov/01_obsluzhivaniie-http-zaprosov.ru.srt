1
00:00:00,000 --> 00:00:06,727
[БЕЗ СЛОВ] В

2
00:00:06,727 --> 00:00:11,748
этом видео мы познакомимся с обработкой
http-запросов и теми средствами,

3
00:00:11,748 --> 00:00:15,723
которые предоставляет стандартная
библиотека Go для этих целей.

4
00:00:15,723 --> 00:00:17,753
Начнем мы с простого веб-сервера,

5
00:00:17,753 --> 00:00:20,710
который будет выводить нам
хотя бы что-то на экран.

6
00:00:20,710 --> 00:00:21,596
Итак.

7
00:00:21,596 --> 00:00:26,715
Основное, что есть для работы с http в Go,

8
00:00:26,715 --> 00:00:30,170
лежит в пакете "net/http".

9
00:00:30,170 --> 00:00:36,037
Там определено очень много всего,
и начнем мы с того,

10
00:00:36,037 --> 00:00:40,320
что мы определим какой-то обработчик,
который будет обрабатывать наши запросы.

11
00:00:40,320 --> 00:00:45,750
В самом простом варианте это
делается через указание HandleFunc.

12
00:00:45,750 --> 00:00:49,458
И роутом, то есть адресом,

13
00:00:49,458 --> 00:00:54,466
которым будет служить эта функция,
и непосредственно

14
00:00:54,466 --> 00:00:59,050
указанием функции, которая будет
обрабатывать запрос на этом URL'е.

15
00:00:59,050 --> 00:01:03,854
Функция строго описана
через конкретный тип,

16
00:01:03,854 --> 00:01:08,378
то есть у нее в первом аргументе
приходит ResponseWriter,

17
00:01:08,378 --> 00:01:11,760
то есть то,
куда мы будем записывать наш результат.

18
00:01:11,760 --> 00:01:17,620
Во втором аргументе приходит http.Request,
то есть сам запрос, который к нам пришел,

19
00:01:17,620 --> 00:01:22,147
где лежат все параметры этого запроса.

20
00:01:22,147 --> 00:01:27,093
Итак, поскольку w — это ResponseWriter,
мы можем туда записать либо

21
00:01:27,093 --> 00:01:31,790
через функцию Fprintln,
которая сама отформатирует в нужный вид,

22
00:01:31,790 --> 00:01:37,620
либо записать туда какой-то
набор байт и используя [ ]byte.

23
00:01:37,620 --> 00:01:39,847
Например, вот так.

24
00:01:39,847 --> 00:01:42,700
Ну и давайте это запустим.

25
00:01:42,700 --> 00:01:48,192
[БЕЗ СЛОВ] Итак,

26
00:01:48,192 --> 00:01:53,948
сервис запустился на порту 8080,
теперь откроем его.

27
00:01:53,948 --> 00:01:59,420
И он нам написал, отлично: «Привет,
мир!» и еще «???».

28
00:01:59,420 --> 00:02:04,363
«Привет, мир!» мы вывели

29
00:02:04,363 --> 00:02:08,378
через функцию Fprintln как строку,

30
00:02:08,378 --> 00:02:12,925
и еще «???» мы вывели как [ ]byte.

31
00:02:12,925 --> 00:02:18,462
То есть в самом базовом
варианте http-сервер

32
00:02:18,462 --> 00:02:23,400
можно закодить в Go на, буквально,
двадцати строках ввода.

33
00:02:23,400 --> 00:02:27,248
А теперь давайте рассмотрим,
каким образом мы можем обрабатывать

34
00:02:27,248 --> 00:02:31,399
несколько разных URL'ов при
помощи стандартных функций.

35
00:02:31,399 --> 00:02:36,316
Итак, в базовом варианте мы
определили просто HandleFunc как

36
00:02:36,316 --> 00:02:41,400
обработку просто слэша,
то есть самого корневого элемента.

37
00:02:41,400 --> 00:02:45,049
Теперь мы объявим еще два обработчика.

38
00:02:45,049 --> 00:02:49,460
На строчке 13 это обработчик "/page"
(обратите внимание, он без слэша,

39
00:02:49,460 --> 00:02:55,337
то есть просто page), и на строчке
18 "/pages/" со слэшом в конце,

40
00:02:55,337 --> 00:02:59,394
то есть это какой-то префикс.

41
00:02:59,394 --> 00:03:04,316
На строчке 13, тот, который "/page",
он будет обрабатывать

42
00:03:04,316 --> 00:03:07,570
только "/page" и все,
то есть если мы допишем там что-то дальше,

43
00:03:07,570 --> 00:03:10,873
оно этим обработчиком
обрабатываться не будет.

44
00:03:10,873 --> 00:03:14,266
В случае с "/pages/" на строчке 18,

45
00:03:14,266 --> 00:03:20,943
он будет обрабатывать как сам URL
"/pages/" и все, что идет после него.

46
00:03:20,943 --> 00:03:22,977
То есть это префикс именно.

47
00:03:22,977 --> 00:03:27,770
Ну и корневой элемент строчки 23,
он будет обрабатывать вообще все,

48
00:03:27,770 --> 00:03:29,996
что не попало в другие URL'ы.

49
00:03:29,996 --> 00:03:33,520
Определяется «попало /
не попало» по линии.

50
00:03:33,520 --> 00:03:34,408
Вот.

51
00:03:34,408 --> 00:03:39,699
Итак, что делает у нас "/page"?

52
00:03:39,699 --> 00:03:46,449
"/page" говорит, что мы запросили
одиночную страницу, и выводит ей URL.

53
00:03:46,449 --> 00:03:48,620
URL мы достаем из объекта Request.

54
00:03:48,620 --> 00:03:52,144
И "/pages/" делает то же самое.

55
00:03:52,144 --> 00:03:55,110
Теперь давайте это запустим.

56
00:03:55,110 --> 00:04:04,202
[БЕЗ СЛОВ] Итак,

57
00:04:04,202 --> 00:04:10,017
корневой элемент, он говорит нам,
что это — главная страница.

58
00:04:10,017 --> 00:04:11,490
Теперь страница pages.

59
00:04:11,490 --> 00:04:12,742
/pages/.

60
00:04:12,742 --> 00:04:16,160
Вот смотрите: я вывел /pages/,

61
00:04:16,160 --> 00:04:20,670
то есть это сама папка,
и могу тут теперь что-то еще написать.

62
00:04:20,670 --> 00:04:22,782
И наш роут подхватит это.

63
00:04:22,782 --> 00:04:26,864
Ну, и дописывать могу,
на самом деле, что угодно.

64
00:04:26,864 --> 00:04:32,778
Если я укажу просто /page,
то это будет одиночная страница.

65
00:04:32,778 --> 00:04:36,316
Соответственно, самый корневой элемент,

66
00:04:36,316 --> 00:04:40,880
который просто /, сам корень сайта,
он будет обрабатывать вообще все страницы,

67
00:04:40,880 --> 00:04:45,450
для которых нет никаких других URL'ов.

68
00:04:45,450 --> 00:04:50,020
Вот тест обработался
обработчиком главной страницы.

69
00:04:50,020 --> 00:04:51,110
Отлично.

70
00:04:51,110 --> 00:04:55,352
Обрабатывая URL'ы разными функциями,

71
00:04:55,352 --> 00:05:00,315
это очень хорошо, но в таком
случае мы не можем прокидывать в

72
00:05:00,315 --> 00:05:05,051
эту функцию никаких других параметров,
никаких общих данных,

73
00:05:05,051 --> 00:05:10,060
то есть никакого Dependency Injection,
либо использовать глобальные переменные.

74
00:05:10,060 --> 00:05:16,733
Иногда это бывает не очень удобно, потому
что мы хотим, все-таки, как-то что-то

75
00:05:16,733 --> 00:05:22,470
туда прокидывать и пользоваться какими-то
общими коннектами к базе данных, например.

76
00:05:22,470 --> 00:05:27,590
Поэтому, мы можем указывать
не только обработчик функции,

77
00:05:27,590 --> 00:05:30,837
но и вешать обработчик на структуру.

78
00:05:30,837 --> 00:05:37,252
Например, у нас есть структура Handler,
у нее есть поле Name,

79
00:05:37,252 --> 00:05:41,740
это просто поле,
именно относящееся к этой структуре,

80
00:05:41,740 --> 00:05:48,020
и есть функция ServeHTTP, которая
принимает в себя ResponseWriter и Request.

81
00:05:48,020 --> 00:05:51,850
И вот если мы передадим
такого рода структуру,

82
00:05:51,850 --> 00:05:57,291
она подойдет под нужный интерфейс,

83
00:05:57,291 --> 00:06:00,590
и сервером будет вызываться
метод ServeHTTP,

84
00:06:00,590 --> 00:06:04,810
который будет обрабатывать
уже наш результат.

85
00:06:04,810 --> 00:06:06,974
В данном примере я создал два обработчика.

86
00:06:06,974 --> 00:06:10,120
Первый обработчик — с именем "test",
вот здесь,

87
00:06:10,120 --> 00:06:15,030
второй обработчик — с именем "root",
вот здесь.

88
00:06:15,030 --> 00:06:17,415
Соответственно, "test"
обрабатывает все URL'ы,

89
00:06:17,415 --> 00:06:21,030
которые находятся по префиксу "test",
а "root" обрабатывает все остальное.

90
00:06:21,030 --> 00:06:28,780
И в результате я пишу, каким
обработчиком это было обработано, и URL.

91
00:06:28,780 --> 00:06:36,780
Давайте это запустим.

92
00:06:36,780 --> 00:06:42,316
[БЕЗ СЛОВ] Итак,

93
00:06:42,316 --> 00:06:48,972
главная страница обработалась обработчиком
root, и URL главной страницы.

94
00:06:48,972 --> 00:06:50,768
Напишем что-нибудь.

95
00:06:50,768 --> 00:06:53,806
Все равно обработалось через root.

96
00:06:53,806 --> 00:06:56,165
А если я допишу test,

97
00:06:56,165 --> 00:07:02,141
то теперь она обработалась уже
совершенно другим обработчиком.

98
00:07:02,141 --> 00:07:06,534
Это бывает довольно удобно,
когда у вас много URL'ов,

99
00:07:06,534 --> 00:07:12,885
которые находятся по одному префиксу,
и внутри уже вы можете делать либо switch,

100
00:07:12,885 --> 00:07:19,311
либо обрабатывать сами этот параметр,
который вам нужен.

101
00:07:19,311 --> 00:07:25,027
Например, вы могли бы
параметр 127 выбрать,

102
00:07:25,027 --> 00:07:27,720
справившись сами из URL'а.

103
00:07:27,720 --> 00:07:33,086
В предыдущих примерах мы
использовали HandleFunc и Handler,

104
00:07:33,086 --> 00:07:36,358
и ListenAndServe http
прямо из пакета http.

105
00:07:36,358 --> 00:07:37,630
Эта функция Беркли,

106
00:07:37,630 --> 00:07:42,310
которая предоставляет нам очень быстрый
интерфейс до внутренних объектов.

107
00:07:42,310 --> 00:07:46,986
Но иногда нам бывает необходимо, например,
поднять несколько разных URL'ов и

108
00:07:46,986 --> 00:07:52,180
несколько разных серверов,
и мы можем это сделать.

109
00:07:52,180 --> 00:07:58,469
Например, то, что мы раньше использовали
как HandleFunc, на самом деле вызывает

110
00:07:58,469 --> 00:08:02,510
в себя базовый глобальный мультиплексор,
который обрабатывает запросы.

111
00:08:02,510 --> 00:08:07,730
Мы можем создать отдельный объект с
таким мультиплексором, например вот так:

112
00:08:07,730 --> 00:08:13,112
http.NewServeMux, и зарегистрировать
у него уже нужные обработчики.

113
00:08:13,112 --> 00:08:15,998
Таким образом, мы можем реализовать
несколько мультиплексоров,

114
00:08:15,998 --> 00:08:20,520
которые будут обрабатывать одни
и те же URL'ы, но по-разному.

115
00:08:20,520 --> 00:08:27,239
И еще мы можем создать отдельный сервер,
указав у него разные параметры.

116
00:08:27,239 --> 00:08:31,391
В данном случае я создаю http-сервер,
указываю у него порт, на который мне нужно

117
00:08:31,391 --> 00:08:36,410
слушать, мультиплексер-обработчик
запросов, и Read и WriteTimeout'ы,

118
00:08:36,410 --> 00:08:40,880
чтобы очень медленные
коннекты не висели долго.

119
00:08:40,880 --> 00:08:44,550
После этого,
я начинаю слушать этот уже сервер.

120
00:08:44,550 --> 00:08:53,900
[БЕЗ СЛОВ] Ну вот, пожалуйста.

121
00:08:53,900 --> 00:08:55,393
Я начал просто слушать.

122
00:08:55,393 --> 00:08:59,954
Фактически, это тот же самый код,
который мы могли бы получить shortcut'ами,

123
00:08:59,954 --> 00:09:03,510
но он предоставляет нам гораздо
больше возможностей для настройки.

124
00:09:03,510 --> 00:09:10,472
Конечно, нам необязательно
ограничиваться только одним сервером.

125
00:09:10,472 --> 00:09:14,463
Мы можем запустить любое
количество http-серверов,

126
00:09:14,463 --> 00:09:17,410
http-лиснеров в разных гарутинах.

127
00:09:17,410 --> 00:09:22,760
Вот например, функция runServer, которая
регистрирует новый обработчик запросов,

128
00:09:22,760 --> 00:09:27,507
которая пишет на каком адресе
пришел запрос, ну и URL.

129
00:09:27,507 --> 00:09:32,300
Создается новый сервер, который будет
слушать на этом адресе, используя тот же

130
00:09:32,300 --> 00:09:37,300
самый обработчик запросов, ну и пишем
на каком адресе стартовал сервер.

131
00:09:37,300 --> 00:09:44,106
[БЕЗ СЛОВ] Итак,

132
00:09:44,106 --> 00:09:49,730
у нас стартовало два сервера
на порту 8080 и на порту 8081.

133
00:09:49,730 --> 00:09:54,703
Сейчас, если мы запустим, пожалуйста,

134
00:09:54,703 --> 00:10:00,504
на порту 8080 обработался адрес
по соответствующим серверам,

135
00:10:00,504 --> 00:10:06,294
и если я поставлю 8081,
то обработается уже другим сервером,

136
00:10:06,294 --> 00:10:10,760
который слушает http-запросы
на другом порту.

137
00:10:10,760 --> 00:10:15,594
Это бывает довольно удобно, потому что мы
можем поднять на одном сервере не только,

138
00:10:15,594 --> 00:10:22,960
например, http, но и любые другие лиснеры,

139
00:10:22,960 --> 00:10:27,470
например, для мониторинга.