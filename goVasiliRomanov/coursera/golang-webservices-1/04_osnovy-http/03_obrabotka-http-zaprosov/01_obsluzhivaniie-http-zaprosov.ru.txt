[БЕЗ СЛОВ] В этом видео мы познакомимся с обработкой
http-запросов и теми средствами, которые предоставляет стандартная
библиотека Go для этих целей. Начнем мы с простого веб-сервера, который будет выводить нам
хотя бы что-то на экран. Итак. Основное, что есть для работы с http в Go, лежит в пакете "net/http". Там определено очень много всего,
и начнем мы с того, что мы определим какой-то обработчик,
который будет обрабатывать наши запросы. В самом простом варианте это
делается через указание HandleFunc. И роутом, то есть адресом, которым будет служить эта функция,
и непосредственно указанием функции, которая будет
обрабатывать запрос на этом URL'е. Функция строго описана
через конкретный тип, то есть у нее в первом аргументе
приходит ResponseWriter, то есть то,
куда мы будем записывать наш результат. Во втором аргументе приходит http.Request,
то есть сам запрос, который к нам пришел, где лежат все параметры этого запроса. Итак, поскольку w — это ResponseWriter,
мы можем туда записать либо через функцию Fprintln,
которая сама отформатирует в нужный вид, либо записать туда какой-то
набор байт и используя [ ]byte. Например, вот так. Ну и давайте это запустим. [БЕЗ СЛОВ] Итак, сервис запустился на порту 8080,
теперь откроем его. И он нам написал, отлично: «Привет,
мир!» и еще «???». «Привет, мир!» мы вывели через функцию Fprintln как строку, и еще «???» мы вывели как [ ]byte. То есть в самом базовом
варианте http-сервер можно закодить в Go на, буквально,
двадцати строках ввода. А теперь давайте рассмотрим,
каким образом мы можем обрабатывать несколько разных URL'ов при
помощи стандартных функций. Итак, в базовом варианте мы
определили просто HandleFunc как обработку просто слэша,
то есть самого корневого элемента. Теперь мы объявим еще два обработчика. На строчке 13 это обработчик "/page"
(обратите внимание, он без слэша, то есть просто page), и на строчке
18 "/pages/" со слэшом в конце, то есть это какой-то префикс. На строчке 13, тот, который "/page",
он будет обрабатывать только "/page" и все,
то есть если мы допишем там что-то дальше, оно этим обработчиком
обрабатываться не будет. В случае с "/pages/" на строчке 18, он будет обрабатывать как сам URL
"/pages/" и все, что идет после него. То есть это префикс именно. Ну и корневой элемент строчки 23,
он будет обрабатывать вообще все, что не попало в другие URL'ы. Определяется «попало /
не попало» по линии. Вот. Итак, что делает у нас "/page"? "/page" говорит, что мы запросили
одиночную страницу, и выводит ей URL. URL мы достаем из объекта Request. И "/pages/" делает то же самое. Теперь давайте это запустим. [БЕЗ СЛОВ] Итак, корневой элемент, он говорит нам,
что это — главная страница. Теперь страница pages. /pages/. Вот смотрите: я вывел /pages/, то есть это сама папка,
и могу тут теперь что-то еще написать. И наш роут подхватит это. Ну, и дописывать могу,
на самом деле, что угодно. Если я укажу просто /page,
то это будет одиночная страница. Соответственно, самый корневой элемент, который просто /, сам корень сайта,
он будет обрабатывать вообще все страницы, для которых нет никаких других URL'ов. Вот тест обработался
обработчиком главной страницы. Отлично. Обрабатывая URL'ы разными функциями, это очень хорошо, но в таком
случае мы не можем прокидывать в эту функцию никаких других параметров,
никаких общих данных, то есть никакого Dependency Injection,
либо использовать глобальные переменные. Иногда это бывает не очень удобно, потому
что мы хотим, все-таки, как-то что-то туда прокидывать и пользоваться какими-то
общими коннектами к базе данных, например. Поэтому, мы можем указывать
не только обработчик функции, но и вешать обработчик на структуру. Например, у нас есть структура Handler,
у нее есть поле Name, это просто поле,
именно относящееся к этой структуре, и есть функция ServeHTTP, которая
принимает в себя ResponseWriter и Request. И вот если мы передадим
такого рода структуру, она подойдет под нужный интерфейс, и сервером будет вызываться
метод ServeHTTP, который будет обрабатывать
уже наш результат. В данном примере я создал два обработчика. Первый обработчик — с именем "test",
вот здесь, второй обработчик — с именем "root",
вот здесь. Соответственно, "test"
обрабатывает все URL'ы, которые находятся по префиксу "test",
а "root" обрабатывает все остальное. И в результате я пишу, каким
обработчиком это было обработано, и URL. Давайте это запустим. [БЕЗ СЛОВ] Итак, главная страница обработалась обработчиком
root, и URL главной страницы. Напишем что-нибудь. Все равно обработалось через root. А если я допишу test, то теперь она обработалась уже
совершенно другим обработчиком. Это бывает довольно удобно,
когда у вас много URL'ов, которые находятся по одному префиксу,
и внутри уже вы можете делать либо switch, либо обрабатывать сами этот параметр,
который вам нужен. Например, вы могли бы
параметр 127 выбрать, справившись сами из URL'а. В предыдущих примерах мы
использовали HandleFunc и Handler, и ListenAndServe http
прямо из пакета http. Эта функция Беркли, которая предоставляет нам очень быстрый
интерфейс до внутренних объектов. Но иногда нам бывает необходимо, например,
поднять несколько разных URL'ов и несколько разных серверов,
и мы можем это сделать. Например, то, что мы раньше использовали
как HandleFunc, на самом деле вызывает в себя базовый глобальный мультиплексор,
который обрабатывает запросы. Мы можем создать отдельный объект с
таким мультиплексором, например вот так: http.NewServeMux, и зарегистрировать
у него уже нужные обработчики. Таким образом, мы можем реализовать
несколько мультиплексоров, которые будут обрабатывать одни
и те же URL'ы, но по-разному. И еще мы можем создать отдельный сервер,
указав у него разные параметры. В данном случае я создаю http-сервер,
указываю у него порт, на который мне нужно слушать, мультиплексер-обработчик
запросов, и Read и WriteTimeout'ы, чтобы очень медленные
коннекты не висели долго. После этого,
я начинаю слушать этот уже сервер. [БЕЗ СЛОВ] Ну вот, пожалуйста. Я начал просто слушать. Фактически, это тот же самый код,
который мы могли бы получить shortcut'ами, но он предоставляет нам гораздо
больше возможностей для настройки. Конечно, нам необязательно
ограничиваться только одним сервером. Мы можем запустить любое
количество http-серверов, http-лиснеров в разных гарутинах. Вот например, функция runServer, которая
регистрирует новый обработчик запросов, которая пишет на каком адресе
пришел запрос, ну и URL. Создается новый сервер, который будет
слушать на этом адресе, используя тот же самый обработчик запросов, ну и пишем
на каком адресе стартовал сервер. [БЕЗ СЛОВ] Итак, у нас стартовало два сервера
на порту 8080 и на порту 8081. Сейчас, если мы запустим, пожалуйста, на порту 8080 обработался адрес
по соответствующим серверам, и если я поставлю 8081,
то обработается уже другим сервером, который слушает http-запросы
на другом порту. Это бывает довольно удобно, потому что мы
можем поднять на одном сервере не только, например, http, но и любые другие лиснеры, например, для мониторинга.