1
00:00:00,000 --> 00:00:08,515
[БЕЗ_ЗВУКА] Итак,
в прошлом видео я демонстрировал,

2
00:00:08,515 --> 00:00:12,390
каким образом можно осуществить
запрос на какой-то внешний сервис.

3
00:00:12,390 --> 00:00:18,510
И для демонстрации этого я поднимал
прямо в той же программе веб-сервер,

4
00:00:18,510 --> 00:00:22,050
для того чтобы в него ходить.

5
00:00:22,050 --> 00:00:28,204
Это не всегда удобно, и иногда мы
хотим протестить либо HTTP handler,

6
00:00:28,204 --> 00:00:31,670
то есть функцию,
которая будет обрабатывать наши запросы,

7
00:00:31,670 --> 00:00:37,041
либо мы хотим протестировать функцию,
которая входит в какой-то

8
00:00:37,041 --> 00:00:42,450
внешний сервис и получает оттуда ответ,
и мы хотим протестировать ее.

9
00:00:42,450 --> 00:00:46,599
В этом видео мы проговорим про то,

10
00:00:46,599 --> 00:00:50,640
какие инструменты
предоставляет Go для этого.

11
00:00:50,640 --> 00:00:55,700
Итак, допустим, у нас есть функция
GetUser — это HTTP handler.

12
00:00:55,700 --> 00:00:57,558
Она принимает параметр,

13
00:00:57,558 --> 00:01:02,460
и в зависимости от этого параметра
нам отдает какой-то результат.

14
00:01:02,460 --> 00:01:05,561
Мы хотим ее протестировать.

15
00:01:05,561 --> 00:01:09,920
Да, мы можем как-то мокать или что-то еще,

16
00:01:09,920 --> 00:01:16,692
какие-то подставлять значения туда, но в
Go есть для этого специальная функция.

17
00:01:16,692 --> 00:01:21,205
Есть пакет net/http/httptest
— вот так он называется.

18
00:01:21,205 --> 00:01:23,796
И там находится вспомогательная функция.

19
00:01:23,796 --> 00:01:28,580
Например, там есть
Request и есть Recorder.

20
00:01:28,580 --> 00:01:30,696
Соответственно, что мы можем сделать?

21
00:01:30,696 --> 00:01:35,103
Мы можем подготовить этот тестовый запрос,
то есть он будет ровно таким,

22
00:01:35,103 --> 00:01:37,380
который придет в вашу функцию.

23
00:01:37,380 --> 00:01:42,544
Не тот, который вы отправляете
на какой-то внешний сервис,

24
00:01:42,544 --> 00:01:45,677
а именно тот,
который придет в этот сервис.

25
00:01:45,677 --> 00:01:53,360
Можем подготовить Recorder и уже запросить
как раз таки функцию с этими параметрами.

26
00:01:53,360 --> 00:01:59,418
И дальше уже проверять,
что там есть, все ли хорошо,

27
00:01:59,418 --> 00:02:04,975
тот ли статус код вернулся,
тот ли результат вернулся.

28
00:02:04,975 --> 00:02:10,038
То есть мы можем из вот
httptest.NewRecorder

29
00:02:10,038 --> 00:02:15,655
вернуть результат — это тот response,
который получила бы ваша функция.

30
00:02:15,655 --> 00:02:19,140
Там есть Header, там есть Body,
там есть статус код.

31
00:02:19,140 --> 00:02:22,600
В данном случае я вычитываю весь Body,

32
00:02:22,600 --> 00:02:28,706
привожу его к строку и просто
сравниваю с эталоном, вот так.

33
00:02:28,706 --> 00:02:34,887
Если тут что-то или нет,
запускаем request_test.

34
00:02:34,887 --> 00:02:37,835
Тест проходит, все хорошо.

35
00:02:37,835 --> 00:02:42,550
Теперь как быть,
если нужно с другой стороны?

36
00:02:42,550 --> 00:02:46,890
То есть протестировать какую-то внешнюю,

37
00:02:46,890 --> 00:02:50,590
подменить какой-то внешний сервис.

38
00:02:50,590 --> 00:02:54,531
Это можно сделать,
используя тот же пакет httptest.

39
00:02:54,531 --> 00:02:58,310
Рассмотрим следующим
пример: у нас есть функция,

40
00:02:58,310 --> 00:03:03,200
у нас есть структура «корзина»,

41
00:03:03,200 --> 00:03:06,080
и у нее есть метод Checkout (оплатить).

42
00:03:06,080 --> 00:03:10,253
В данном случае я привел упрощенную — там,
конечно, должна быть сумма и прочее,

43
00:03:10,253 --> 00:03:14,956
прочее, но для примера подойдет.

44
00:03:14,956 --> 00:03:19,223
Есть URL платежного шлюза
или платежного сервиса,

45
00:03:19,223 --> 00:03:23,100
куда нам нужно сходить,
чтобы списали с нашего баланса.

46
00:03:23,100 --> 00:03:29,200
И вот, допустим, мы создаем сразу URL,
по которому мы идем, добавляем там id.

47
00:03:29,200 --> 00:03:30,773
И дергаем его Get'ом.

48
00:03:30,773 --> 00:03:35,413
Все, не заморачиваемся,
потом там проверяем ошибки, закрываем,

49
00:03:35,413 --> 00:03:40,113
вычитываем Body, и распаковываем json,
и опять возвращаем ошибку.

50
00:03:40,113 --> 00:03:42,765
И мы хотим проверить, что эта функция,

51
00:03:42,765 --> 00:03:45,885
что полностью мы покрыли
все возможные результаты.

52
00:03:45,885 --> 00:03:51,500
Может быть, test coverage построить,
может быть, у нас цель — достичь 100 %-го.

53
00:03:51,500 --> 00:03:55,238
Если просто ходить в какой-то
внешний сервис, во-первых,

54
00:03:55,238 --> 00:03:58,280
на реальном сервисе у нас
будут списывать деньги.

55
00:03:58,280 --> 00:04:01,373
Ну и, конечно,
мы не всегда можем гарантировать,

56
00:04:01,373 --> 00:04:04,200
что он вернет нам ошибку
или там будем таймаут,

57
00:04:04,200 --> 00:04:08,220
потому что на той стороне люди наверняка
стараются, чтобы этого не происходило.

58
00:04:08,220 --> 00:04:09,729
Как это проверить?

59
00:04:09,729 --> 00:04:14,975
Очень хорошо, что у нас есть
PaymentApiURL, поэтому мы можем

60
00:04:14,975 --> 00:04:20,835
поднять у себя сервер и туда отправить,

61
00:04:20,835 --> 00:04:26,580
в этот PaymentApiURL уже поставить нужное
нам значение нашего локального сервера.

62
00:04:26,580 --> 00:04:28,159
Итак, рассмотрим.

63
00:04:28,159 --> 00:04:30,710
Вот мои тест-кейсы, их четыре.

64
00:04:30,710 --> 00:04:35,040
Вот я создаю сервер,
указываю CheckoutDummy, то есть функцию,

65
00:04:35,040 --> 00:04:38,690
которая будет обрабатывать
приходящие туда запросы.

66
00:04:38,690 --> 00:04:42,710
Этот сервер начнет слушать
на каком-то случайном порту,

67
00:04:42,710 --> 00:04:48,750
и мне вернется его URL.

68
00:04:48,750 --> 00:04:51,468
Теперь я могу уже, не стесняясь,

69
00:04:51,468 --> 00:04:55,446
отправлять туда все нужные мои запросы,
зная, что они придут ко мне.

70
00:04:55,446 --> 00:04:57,390
Не в какой-то внешний сервис, а ко мне.

71
00:04:57,390 --> 00:05:02,280
И я проверяю, что была ли там ошибка,
либо там, наоборот, ошибки не было.

72
00:05:02,280 --> 00:05:06,593
И мне вернулся ровно тот результат,
который я ожидал.

73
00:05:06,593 --> 00:05:09,360
Ну и в конце я выключаю этот сервер.

74
00:05:09,360 --> 00:05:09,890
Вот.

75
00:05:09,890 --> 00:05:14,670
Давайте посмотрим функцию
CheckDummy еще наконец.

76
00:05:14,670 --> 00:05:19,980
CheckDummy — это функция, которую я
принимаю в свои входящие параметры,

77
00:05:19,980 --> 00:05:25,010
которую я отсылаю на этот сервер,
и возвращаю какой-то нужный мне результат.

78
00:05:25,010 --> 00:05:31,516
То есть я могу вернуть успешный запрос,
могу вернуть плохой запрос,

79
00:05:31,516 --> 00:05:37,515
но как будто бы это штатная ситуация,
могу вернуть, вообще,

80
00:05:37,515 --> 00:05:42,180
кривой json, либо же могу вернуть просто
500 server, значит он вообще недоступен.

81
00:05:42,180 --> 00:05:49,459
То есть очень удобно, когда вы можете
подменить какой-то внешний сервис своим,

82
00:05:49,459 --> 00:05:52,904
написать там все нужные вам тест-кейсы
и проверить нужный ваш код.

83
00:05:52,904 --> 00:05:56,400
При этом опять-таки это все предоставляет
вам стандартная библиотека.

84
00:05:56,400 --> 00:05:59,890
Давайте запускать.

85
00:05:59,890 --> 00:06:07,890
[ШУМ]

86
00:06:07,890 --> 00:06:14,152
[ШУМ] Вот

87
00:06:14,152 --> 00:06:18,813
мой тест отработал, все успешно,

88
00:06:18,813 --> 00:06:25,460
я прошел все случаи: и ошибки,
и кривой json, и отсутствующий баланс.

89
00:06:25,460 --> 00:06:31,260
Таким образом вы можете покрыть
все ваши все ваши функции,

90
00:06:31,260 --> 00:06:36,484
который либо ходят куда-то,
либо принимают откуда-то что-то, без

91
00:06:36,484 --> 00:06:41,770
того чтобы очень долго городить какую-то
необходимую инфраструктуру вокруг этого.

92
00:06:41,770 --> 00:06:46,200
Вы используете прямо в своем тесте,
прямо в своем коде.

93
00:06:46,200 --> 00:06:49,650
Это очень удобно.