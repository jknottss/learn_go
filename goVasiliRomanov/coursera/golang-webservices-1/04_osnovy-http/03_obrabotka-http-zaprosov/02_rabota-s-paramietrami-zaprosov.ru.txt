[БЕЗ_ЗВУКА] В этом видео мы рассмотрим работу с входящими
параметрами запроса, с теми параметрами, которые вы можете получить от
пользователя тем или иным образом. Никакая работа с динамическими данными
невозможна без обработки этих параметров. Давайте рассмотрим следующую функцию. В ней мы будем просто
получать get-параметры. Получить параметры можно
несколькими образами. Первым является непосредственно
получение из url, то есть get-параметров,
которые приходят к нам в запросе. В данном случае мы из url
получаем объект query, а у него уже получаем параметр
с незамысловатым именем param. Если такого параметра нет,
этот метод возвращает пустоту. Мы проверяем, что если параметр не пуст,
мы выводим его на экран. Вторым способом является
использование функции FormValue из объекта request и
через неё мы получаем функцию key. При помощи этой функции можно также
получать параметры из post-запросов. Мы тоже выводим эту функцию на экран. А теперь это надо запустить. Она уже запущена. Итак, вот вывод нашей программы. mParam = 1 и key = 2. Теперь это можно изменить. [БЕЗ_ЗВУКА] Итак, mParam теперь тест, а key теперь hello. Но это были get-параметры. А как насчёт post? Итак, теперь давайте
рассмотрим post-параметры. У нас есть handler mainPage,
который проверяет, что, если метод, с которым мы пришли, не post,
то мы рисуем форму логина. Форму логина я записал руками,
просто как html. А если мы пришли через post,
то мы можем получить доступ к параметрам. Мы можем руками распарсить форму,
когда нам надо, r.ParseForm, и обратиться
к ней за нашими данными. Либо мы можем использовать короткое
обращение, используя FormValue, которая всю эту работу сделает за нас
и вернет нам первый нужный параметр. Причем функция FormValue будет возвращать
параметры вообще всего запроса, не только из get, но и из post. При этом, конечно же,
из post будет иметь приоритет. Мы выведем на экран тот параметр,
который мы ввели. Запросили сервер, отлично. Теперь он меня просит
ввести логин и пароль. [БЕЗ_ЗВУКА] Жмем логин и теперь программа вывела,
что я вел rvasily. Так обрабатываются post-параметры. Еще одним входящим
параметром являются куки. Куки — это значение, которое постоянно в рамках HTPC
пользователя для того, чтобы, например, запоминать уже авторизационные данные
на сервер, чтобы иметь какой-то ключ. Итак, давайте посмотрим,
как же нам работать с куками. Зарегистрируем три функции. Функцию login, logout и главную страницу. Что делает главная страница? Главная страница получает куку, используя метод cookie из объекта request,
и дальше мы проверяем, что если такая кука есть, мы считаем,
что пользователь залогинен. Если куки нет, мы считаем,
что ему нужно логиниться. Итак, если он залогинен,
то мы даем ссылку на logout, и пишем значение куки session.Value. Session — это как раз таки наша кука. Противным образом,
если пользователь не залогинен, то мы ему предлагаем залогиниться. Что делает функция login? Функция login просто выставляет куку
с заранее заданными значениями, это не многопользовательский сервер. Итак, у куки есть имя. Кука представляет собой
структуру в пакете http. У неё есть имя, value, дата протухания, и для того, чтобы поставить куку, есть в
пакете http специальная функция SetCookie. Итого, я передаю туда response writer
и куку, которую я хочу поставить. Всё хорошо. Дальше я делаю redirect
на главную страницу. Функция logout просто удаляет куку. Я теперь смотрю,
что пытаюсь получить куку. Если ее нет, я сразу redirect на главную,
если она есть, я оставлю дату в прошлое. Таким образом, я говорю серверу, что это
кука больше не валидная, ее нужно удалить. И тоже делаю redirect. Теперь давайте посмотрим,
как это работает. Запустим наш сервер. Запустили. Откроем консоль, чтобы смотреть,
что нам выставляется сервером. Итак, главная страница, которая проверила,
что куки нет, и нам нужно ее получить. Жмем на логин. Итак, вот наш логин. Вот было выставление куки
имя cookies session_id, значение rvasily, и дата протухания. Теперь мы с редиректа на главную. Если мы попробуем выйти,
нажмем на кнопку logout, то нам тоже выставилась кука,
но с датой уже в прошлое. Куки в основном используются для запоминания каких-то значений,
которые не очень секьюрные, потому что браузерный JavaScript
может получать к ним доступ. Очень часто куки используются для того,
чтобы запомнить идентификатор сессии пользователя, чтобы эти секретные
значения уже определять на сервере. Ещё очень важная информация, которая находится в http request,
это заголовки header. Header могут быть как выставлены,
так и получены из запроса. В этом примере я покажу,
как с этим работать. Для того, чтобы выставить header,
мы должны получить объект header из response writer, из w,
и указать в нем функцию set, в которой с параметрами мы передадим
само название header и значение. В данном случае я указываю какое-то
случайное значение, которое каким-либо образом предполагается идентифицирует
мой запрос, возможно в логах. Далее я хочу получить
теперь значения какие-то. Для получения header с UserAgent есть
сокращение у http request сразу UserAgent. Для того чтобы получить
какие-то другие header, мне нужно обратиться к структуре header и
вызвать у нее метод gets нужным header. Давайте запустим. Запустили сервер. Итак, смотрим. Вот мой браузер, которым я записываю. А вот accept, значение header accept, который был передан моим
браузером на сервер. Теперь для того чтобы
посмотреть header response, обратимся к инспектору,
найдем response header и вот наш Requestid, то значение,
которое мы прокинули.