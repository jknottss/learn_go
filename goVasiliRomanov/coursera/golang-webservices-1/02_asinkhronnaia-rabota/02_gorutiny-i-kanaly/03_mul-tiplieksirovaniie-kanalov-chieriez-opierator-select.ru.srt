1
00:00:00,000 --> 00:00:05,556
[БЕЗ_ЗВУКА] В этом

2
00:00:05,556 --> 00:00:10,420
видео мы поговорим о мультиплексировании
каналов при помощи инструкции select.

3
00:00:10,420 --> 00:00:14,670
Часто бывают случаи, когда нам
нужно опрашивать несколько каналов,

4
00:00:14,670 --> 00:00:19,019
но мы не можем делать это
последовательно или хотя бы в цикле,

5
00:00:19,019 --> 00:00:23,540
потому что тогда они заблокируются,
если они еще не готовы.

6
00:00:23,540 --> 00:00:25,371
Для того,
чтобы опрашивать несколько каналов,

7
00:00:25,371 --> 00:00:26,810
есть специальная инструкция select.

8
00:00:26,810 --> 00:00:28,300
Давайте посмотрим, как она работает.

9
00:00:28,300 --> 00:00:35,478
Итак, у нас есть два канала, которые
не буферизированы, и инструкция select.

10
00:00:35,478 --> 00:00:40,694
Select очень похожа на switch,
однако в ней

11
00:00:40,694 --> 00:00:46,969
в качестве случаев для case
выступают не логические,

12
00:00:46,969 --> 00:00:50,980
то есть булевы выражения,
а операции над каналами.

13
00:00:50,980 --> 00:00:57,840
Вы можете как читать из канала какое-то
значение, так и писать в канал.

14
00:00:57,840 --> 00:01:01,592
И есть оператор default,

15
00:01:01,592 --> 00:01:07,010
который выполняется в том случае,
если никакого из других операторов...

16
00:01:07,010 --> 00:01:12,000
никакой из других случаев не ответил,
то есть канал заблокирован.

17
00:01:12,000 --> 00:01:18,560
Давайте запустим эту программу.

18
00:01:18,560 --> 00:01:23,840
Смотрите, выполнился default case.

19
00:01:23,840 --> 00:01:25,120
Почему?

20
00:01:25,120 --> 00:01:27,887
Потому что у нас ни в одном
из каналов не было значения.

21
00:01:27,887 --> 00:01:32,011
То есть в первом канале, откуда мы
пытались прочитать, ничего не было,

22
00:01:32,011 --> 00:01:36,027
второй канал,
куда мы что-то попытались записать,

23
00:01:36,027 --> 00:01:39,663
из него никто не читал,
и как бы он тоже был заблокирован.

24
00:01:39,663 --> 00:01:42,928
Теперь давайте сделаем один
из каналов буферизированным,

25
00:01:42,928 --> 00:01:44,920
и положим туда какое-то значение.

26
00:01:44,920 --> 00:01:48,870
[ЗВУК] И запустим заново.

27
00:01:48,870 --> 00:01:53,414
Смотрите, сейчас выполнится случай,

28
00:01:53,414 --> 00:02:00,525
когда мы пытались прочитать что-то
из канала 1, и он нам напечатался.

29
00:02:00,525 --> 00:02:06,013
Если случая default не будет,
и при этом никакой канал не будет готов,

30
00:02:06,013 --> 00:02:08,520
то наступит ситуация deadlock.

31
00:02:08,520 --> 00:02:17,317
[ЗВУК] Deadlock,
то есть никакой из каналов не прочитан,

32
00:02:17,317 --> 00:02:21,950
и мы ждем,
то есть с той стороны тоже никто не пишет.

33
00:02:21,950 --> 00:02:22,680
Вот.

34
00:02:22,680 --> 00:02:26,170
Давайте посмотрим,
что с этим можно дальше сделать.

35
00:02:26,170 --> 00:02:27,934
Вот у нас есть такая программа.

36
00:02:27,934 --> 00:02:30,153
То есть мы можем читать из этих каналов.

37
00:02:30,153 --> 00:02:32,520
Давайте посмотрим, как это происходит.

38
00:02:32,520 --> 00:02:39,002
За раз внутри select выполняется только
одна операция, то есть это не происходит

39
00:02:39,002 --> 00:02:43,445
так, что select сам опросил несколько
каналов и каждый из них выполнил, нет.

40
00:02:43,445 --> 00:02:49,470
Если мы хотим, чтобы попытки
опроса каналов происходили еще,

41
00:02:49,470 --> 00:02:51,875
то нам приходится делать цикл.

42
00:02:51,875 --> 00:02:54,910
Давайте посмотрим, как это работает.

43
00:02:54,910 --> 00:02:56,663
Создадим два канала.

44
00:02:56,663 --> 00:03:00,360
В каждый из них положим
по несколько значений.

45
00:03:00,360 --> 00:03:04,203
Теперь внутри цикла мы будем опрашивать
эти каналы, если там что-то есть,

46
00:03:04,203 --> 00:03:05,810
мы будем выводить это на экран.

47
00:03:05,810 --> 00:03:08,867
А если ничего нам не вернется,

48
00:03:08,867 --> 00:03:14,131
то мы завершим цикл,
используя break и метку цикла.

49
00:03:14,131 --> 00:03:17,131
Мы не можем написать просто break,

50
00:03:17,131 --> 00:03:22,371
потому что в этом случае мы завершим
select, поэтому нужна метка цикла.

51
00:03:22,371 --> 00:03:23,540
Давайте запустим.

52
00:03:23,540 --> 00:03:31,132
[ЗВУК] [ЗВУК] Вот посмотрите.

53
00:03:31,132 --> 00:03:38,600
Мы прочитали из канала 1, потом из
канала 2 и затем еще раз из канала 1.

54
00:03:38,600 --> 00:03:42,610
Какой из каналов выбирать для чтения,

55
00:03:42,610 --> 00:03:46,620
планировщик Go выбирает случайным образом,
мы это контролировать не можем.

56
00:03:46,620 --> 00:03:52,080
То есть они выполняются не в том порядке,
в котором мы их указали внутри select.

57
00:03:52,080 --> 00:03:53,260
Хорошо.

58
00:03:53,260 --> 00:03:57,980
Мы разобрались с чтением из каналов.

59
00:03:57,980 --> 00:04:01,710
Но мы можем не только...

60
00:04:01,710 --> 00:04:06,314
в рамках одного select мы можем не
только читать из разных каналов,

61
00:04:06,314 --> 00:04:07,780
но и читать и писать.

62
00:04:07,780 --> 00:04:15,139
И это открывает нам возможность для того,
чтобы завершать какие-то внешние каналы,

63
00:04:15,139 --> 00:04:19,775
внешние функции,
используя так называемый канал отмены.

64
00:04:19,775 --> 00:04:21,930
Давайте посмотрим, как это работает.

65
00:04:21,930 --> 00:04:24,022
Итак, у нас есть два канала.

66
00:04:24,022 --> 00:04:29,145
Первый канал — канал отмены,
в него мы можем класть пустую структуру.

67
00:04:29,145 --> 00:04:32,905
Пустая структура — это структура
без полей, она не занимает места,

68
00:04:32,905 --> 00:04:33,988
то есть как бы...

69
00:04:33,988 --> 00:04:36,360
только сам признак, что там что-то есть.

70
00:04:36,360 --> 00:04:37,769
Ну и канал с данными.

71
00:04:37,769 --> 00:04:44,616
Теперь вызовем функцию, которая будет
бесконечно нам печатать значения.

72
00:04:44,616 --> 00:04:46,860
Ну как бесконечно?

73
00:04:46,860 --> 00:04:51,300
Внутри этой функции
будет бесконечный цикл.

74
00:04:51,300 --> 00:04:56,280
И внутри этого цикла будет
select с несколькими case-ами.

75
00:04:56,280 --> 00:05:01,310
Первый case выполняется только если
мы что-то прочитали из канала отмены,

76
00:05:01,310 --> 00:05:03,230
какого-то внешнего канала.

77
00:05:03,230 --> 00:05:07,010
В этом случае мы завершим
работу всей функции.

78
00:05:07,010 --> 00:05:12,831
В противном случае мы будем писать в
канал с данными увеличивающиеся значения.

79
00:05:12,831 --> 00:05:16,543
Ну и теперь давайте попробуем
итерироваться по этому каналу со

80
00:05:16,543 --> 00:05:18,459
значениями — data Сhannel.

81
00:05:18,459 --> 00:05:22,883
Смотрите, мы итерируемся,
пишем, что мы что-то прочитали.

82
00:05:22,883 --> 00:05:27,349
Если то, что мы прочитали,
больше 3, тогда мы

83
00:05:27,349 --> 00:05:32,315
отправим в канал с
отменой пустую структуру,

84
00:05:32,315 --> 00:05:36,463
то есть сам признак того,
что туда что-то положили.

85
00:05:36,463 --> 00:05:41,420
Когда это произойдет,
когда это произойдет на строчке 27,

86
00:05:41,420 --> 00:05:47,970
это значение прочитается
из канала на строчке 15.

87
00:05:47,970 --> 00:05:53,102
То есть нам не важно само значение, нам
важен сам факт, что было что-то прочитано.

88
00:05:53,102 --> 00:05:57,769
Как только этот факт случился,
то мы просто завершаем выполнение функции.

89
00:05:57,769 --> 00:06:00,580
Давайте посмотрим, как это будет работать.

90
00:06:00,580 --> 00:06:08,144
[ЗВУК] Посмотрите.

91
00:06:08,144 --> 00:06:10,070
Мы напечатали пять значений.

92
00:06:10,070 --> 00:06:14,366
Как только значение,
которое нам пришло, стало больше 3, да,

93
00:06:14,366 --> 00:06:19,734
то есть 4, текущее значение больше 3,
мы написали,

94
00:06:19,734 --> 00:06:23,730
что мы шлем отмену и завершили цикл.

95
00:06:23,730 --> 00:06:24,590
Все.

96
00:06:24,590 --> 00:06:28,725
В этом видео мы посмотрели,

97
00:06:28,725 --> 00:06:32,821
как можно мультиплексировать каналы,
как можно читать из нескольких каналов,

98
00:06:32,821 --> 00:06:39,280
как использовать мультиплексор select
для того, чтобы завершить работу канала.

99
00:06:39,280 --> 00:06:41,257
В следующем видео мы посмотрим,

100
00:06:41,257 --> 00:06:44,800
какие другие функции Go
предоставляет для удобного...

101
00:06:44,800 --> 00:06:50,510
удобной работы с таймингами
и завершением каналов.