1
00:00:00,000 --> 00:00:08,400
[БЕЗ_ЗВУКА] А теперь давайте
поговорим о каналах.

2
00:00:08,400 --> 00:00:12,705
Основная трудность при
многопроцессорной разработке,

3
00:00:12,705 --> 00:00:15,914
то есть когда ваша программа использует
несколько ядер процессоров или даже

4
00:00:15,914 --> 00:00:20,921
несколько процессоров, состоит в том, что
вам нужно как-то их синхронизировать между

5
00:00:20,921 --> 00:00:25,930
собой и каким-то образом передавать
данные между разными потоками.

6
00:00:25,930 --> 00:00:29,850
В Go для этих целей есть каналы.

7
00:00:29,850 --> 00:00:37,511
Каналы нужны, для того чтобы передавать
владения данными в другую горутину.

8
00:00:37,511 --> 00:00:39,329
Как это работает?

9
00:00:39,329 --> 00:00:43,802
Смотрите, для начала нужно
создать какой-то канал,

10
00:00:43,802 --> 00:00:46,690
канал создается конструкцией make,

11
00:00:46,690 --> 00:00:52,350
после идет ключевое
слово chan и тип канала.

12
00:00:52,350 --> 00:00:54,597
То есть каналы будут тоже типизированы,

13
00:00:54,597 --> 00:00:57,430
в них можно класть только
определенный тип данных.

14
00:00:57,430 --> 00:01:01,918
После этого, смотрите,
я запускаю горутину,

15
00:01:01,918 --> 00:01:06,789
которая принимает на вход
канал (in — это имя канала,

16
00:01:06,789 --> 00:01:12,530
chan int — это тип канала),
вычитывает оттуда какое-то значение.

17
00:01:12,530 --> 00:01:17,063
Вычитывание из канала
происходит посредством стрелки

18
00:01:17,063 --> 00:01:21,660
слева от канала, и печатается значение.

19
00:01:21,660 --> 00:01:25,765
Это отдельная горутина,
которую мы запустили.

20
00:01:25,765 --> 00:01:30,048
В основной горутине мы кладет
значение в этот канал.

21
00:01:30,048 --> 00:01:37,375
Кладется значение в канал,
используя стрелку справа от канала.

22
00:01:37,375 --> 00:01:38,754
И затем мы что-то печатаем.

23
00:01:38,754 --> 00:01:41,630
Теперь давайте запустим это и посмотрим,
как оно работает.

24
00:01:41,630 --> 00:01:49,170
Смотрите: сначала

25
00:01:49,170 --> 00:01:53,983
мы положили значение в канал,

26
00:01:53,983 --> 00:02:00,108
после этого дела мы вывели текст из
главной горутины, после программа

27
00:02:00,108 --> 00:02:05,818
ожидает ввода от меня строки,
и управление переключилось в горутину.

28
00:02:05,818 --> 00:02:13,960
Горутина получила значение из канала,
и после значения что-то вывела.

29
00:02:13,960 --> 00:02:16,517
Но есть нюанс.

30
00:02:16,517 --> 00:02:21,924
Смотрите, такая конструкция
make (chan int),

31
00:02:21,924 --> 00:02:25,470
она делает небуферизированный канал.

32
00:02:25,470 --> 00:02:27,047
Что это значит?

33
00:02:27,047 --> 00:02:33,910
Это значит, что,
когда я кладу в канал какое-то значение,

34
00:02:33,910 --> 00:02:38,120
кто-то с другой стороны этого
канала должен его прочитать.

35
00:02:38,120 --> 00:02:43,490
И если никто не читает,
то горутина блокируется,

36
00:02:43,490 --> 00:02:48,400
до тех пор пока на той
стороне не появится тот,

37
00:02:48,400 --> 00:02:51,350
кто вычтет это значение.

38
00:02:51,350 --> 00:02:54,056
К чему это можем привести?

39
00:02:54,056 --> 00:02:58,227
Привести это может к тому,
что мы залочимся.

40
00:02:58,227 --> 00:03:03,361
Эта ситуация называется
deadlock — когда горутина ждет,

41
00:03:03,361 --> 00:03:06,310
но не может дождаться.

42
00:03:06,310 --> 00:03:08,826
Давайте воспроизведем эту ситуацию.

43
00:03:08,826 --> 00:03:11,500
Смотрите, напишем что-то еще в канал.

44
00:03:11,500 --> 00:03:17,689
[ШУМ] Мы написали второе значение.

45
00:03:17,689 --> 00:03:19,120
И давайте запустим.

46
00:03:19,120 --> 00:03:25,401
Все плохо — рантайм ругнулся на то,

47
00:03:25,401 --> 00:03:33,166
что мы залочились на строчке 15,
на отправке в канал.

48
00:03:33,166 --> 00:03:36,319
Давайте посмотрим, что происходит.

49
00:03:36,319 --> 00:03:39,595
На строчке 15 мы пытаемся
отправить еще значение в канал.

50
00:03:39,595 --> 00:03:44,990
Но горутина, в которую мы указали,
чтобы вычитать это значение,

51
00:03:44,990 --> 00:03:48,827
она выполнилась только один раз
и завершилась после этого дела.

52
00:03:48,827 --> 00:03:53,460
То есть наша главная горутина,
функция main,

53
00:03:53,460 --> 00:03:59,830
повисла на строчке 15 в ожидании,
пока кто-то вычитает значение из канала.

54
00:03:59,830 --> 00:04:04,130
И все — и произошел deadlock.

55
00:04:04,130 --> 00:04:07,223
В данном случае нам повезло,
потому что наша программа,

56
00:04:07,223 --> 00:04:09,380
она завершилась сразу с ошибкой.

57
00:04:09,380 --> 00:04:14,321
Но в случае если в deadlock
попадут какие-то другие горутины

58
00:04:14,321 --> 00:04:18,700
внутри вашей программы,
а другие горутины будут

59
00:04:18,700 --> 00:04:24,102
продолжать работать, которые будут
выполнять совершенно другую работу,

60
00:04:24,102 --> 00:04:27,720
то может прийти ситуация,
которая называется утечка горутин,

61
00:04:27,720 --> 00:04:31,400
то есть горутина залочилась и чего-то
ждет, но никогда не дождется.

62
00:04:31,400 --> 00:04:37,160
Это приводит к утечке памяти,
то есть это весьма плохая ситуация,

63
00:04:37,160 --> 00:04:42,225
Теперь давайте рассмотрим,
каким образом вообще это можно избежать.

64
00:04:42,225 --> 00:04:47,392
Вроде бы не очень удобно иметь
небуферизированные каналы.

65
00:04:47,392 --> 00:04:50,533
Каналы в Go могут быть буферизированными.

66
00:04:50,533 --> 00:04:51,569
Что это значит?

67
00:04:51,569 --> 00:04:56,329
Это значит, что канал может
принимать не одно значение,

68
00:04:56,329 --> 00:04:59,628
до того как он залочится, а несколько.

69
00:04:59,628 --> 00:05:04,173
Осуществляется это если мы укажем
значение буфера для этого канала.

70
00:05:04,173 --> 00:05:04,950
Смотрите.

71
00:05:04,950 --> 00:05:09,160
После запятой в конструкции make я
могу указать 0 — это по-прежнему

72
00:05:09,160 --> 00:05:10,894
небуферизированный канал.

73
00:05:10,894 --> 00:05:12,770
Либо могу указать значение 1.

74
00:05:12,770 --> 00:05:17,933
1 это значит, что я могу положить одно

75
00:05:17,933 --> 00:05:23,800
значение в буфер и, если я пытаюсь
положить туда второе значение,

76
00:05:23,800 --> 00:05:30,184
то только тогда я залочусь и буду
ждать пока там освободится место.

77
00:05:30,184 --> 00:05:33,780
Теперь давайте запустим нашу программу
и посмотрим, что получилось.

78
00:05:33,780 --> 00:05:39,250
Смотрите, наша программа
успешно отработала.

79
00:05:39,250 --> 00:05:44,490
Ошибки нет, и мы ее успешно завершаем.

80
00:05:44,490 --> 00:05:47,009
Это происходит за счет того,

81
00:05:47,009 --> 00:05:51,372
что на строчке 15 теперь наша
программа не заблокировалась,

82
00:05:51,372 --> 00:05:57,420
потому что в нашем канале есть место, куда
мы можем положить значение, не блокируясь.

83
00:05:57,420 --> 00:06:02,705
А теперь давайте рассмотрим, как можно

84
00:06:02,705 --> 00:06:07,534
работать в цикле канала.

85
00:06:07,534 --> 00:06:14,290
Вот перед вами программа,
которая запускается, принимает канал.

86
00:06:14,290 --> 00:06:19,990
В данном случае это
небуферизированный канал.

87
00:06:19,990 --> 00:06:23,190
И начинает печатать туда значения.

88
00:06:23,190 --> 00:06:28,567
После закрывает канал,
а в главной горутине у нас есть

89
00:06:28,567 --> 00:06:33,466
конструкция, у нас есть цикл,
который, используя range,

90
00:06:33,466 --> 00:06:38,781
просто итерируется по каналу,
по тем значениям, которые туда приходят.

91
00:06:38,781 --> 00:06:41,610
Давайте посмотрим, как это работает.

92
00:06:41,610 --> 00:06:48,960
[ШУМ] Смотрите,

93
00:06:48,960 --> 00:06:54,050
мы записали что-то в канал,
теперь мы залочились,

94
00:06:54,050 --> 00:07:00,748
управление получила главная горутина, она
прочитала тут значения, и пошло дальше.

95
00:07:00,748 --> 00:07:06,610
И после этого, в конце,
после 4-й итерации наш генератор,

96
00:07:06,610 --> 00:07:12,960
он завершил работу, управление вернулось в
главную горутину, и она вывела значение.

97
00:07:12,960 --> 00:07:16,790
Давайте посмотрим, как это работает.

98
00:07:16,790 --> 00:07:21,737
Мы принимаем канал, в Go можно указать,
при передаче канала в функцию

99
00:07:21,737 --> 00:07:26,399
можно указать,
какого типа будет этот канал.

100
00:07:26,399 --> 00:07:31,232
Например, если я укажу просто chan int,
это значит,

101
00:07:31,232 --> 00:07:34,256
что я в канал смогу и писать, и читать.

102
00:07:34,256 --> 00:07:40,180
Если я поставлю стрелку, это значит,
что я смогу с этого канала только читать.

103
00:07:40,180 --> 00:07:47,160
Если я поставлю стрелку справа, это
значит, что я смогу в канал только писать.

104
00:07:47,160 --> 00:07:54,178
Это удобно, чтобы не делать те операции,
которые не ожидаются от этой горутины.

105
00:07:54,178 --> 00:07:59,120
И такого рода вещи проверяются
на уровне компиляции.

106
00:07:59,120 --> 00:08:04,660
Смотрите: пишем-пишем-пишем,
потом закрываем канал.

107
00:08:04,660 --> 00:08:09,000
Наш цикл должен когда-то прерваться.

108
00:08:09,000 --> 00:08:11,357
Когда цикл прерывается?

109
00:08:11,357 --> 00:08:17,406
Как раз таки закрытие канала ведет к тому,
что цикл завершается.

110
00:08:17,406 --> 00:08:21,580
Давайте попробуем убрать закрытие канала.

111
00:08:21,580 --> 00:08:29,564
Смотрите, я убрал закрытие канала,
генератор закончил работу,

112
00:08:29,564 --> 00:08:33,676
мы получили последнее значение,
и теперь опять впали в deadlock.

113
00:08:33,676 --> 00:08:34,260
Почему?

114
00:08:34,260 --> 00:08:38,469
Потому что в канал in уже
больше никто не пишет,

115
00:08:38,469 --> 00:08:42,940
а мы на строчке 20 все
еще ждем оттуда значений.

116
00:08:42,940 --> 00:08:49,361
То есть конструкция close,
она позволяет завершить цикл,

117
00:08:49,361 --> 00:08:55,150
которые пытается итерироваться
по значениям, идущим в канал.