1
00:00:00,000 --> 00:00:05,739
[БЕЗ_ЗВУКА] В этом

2
00:00:05,739 --> 00:00:10,536
видео мы проговорим про горутины
— одну из тех приятных вещей,

3
00:00:10,536 --> 00:00:15,796
которые делают вашу жизнь при разработке
многопоточных программ в Go гораздо проще.

4
00:00:15,796 --> 00:00:19,970
Итак, рассмотрим для начала
следующую программу.

5
00:00:19,970 --> 00:00:23,800
У нас есть цикл,
который запускает каких-то worker'ов,

6
00:00:23,800 --> 00:00:26,029
которые делают какую-то работу.

7
00:00:26,029 --> 00:00:30,200
В данном случае работа — это
просто напечатать что-то на экран.

8
00:00:30,200 --> 00:00:33,430
Сейчас я продемонстрирую,
как это выглядит.

9
00:00:33,430 --> 00:00:34,168
Итак.

10
00:00:34,168 --> 00:00:40,200
Вот у нас запустился нулевой
worker и что-то напечатал,

11
00:00:40,200 --> 00:00:44,390
вот первый worker что-то
напечатал и так далее.

12
00:00:44,390 --> 00:00:49,183
Теперь, допустим, я хочу, чтобы эти
worker'ы работали не последовательно,

13
00:00:49,183 --> 00:00:54,195
один за другим, а распараллелить их хочу.

14
00:00:54,195 --> 00:00:58,230
Для этого можно запустить
их в разных горутинах.

15
00:00:58,230 --> 00:00:59,518
Как это делать?

16
00:00:59,518 --> 00:01:00,714
Очень просто.

17
00:01:00,714 --> 00:01:06,406
Для того чтобы запустить какую-либо
функцию внутри отдельной горутины,

18
00:01:06,406 --> 00:01:08,683
нужно написать просто слово go.

19
00:01:08,683 --> 00:01:09,340
Вот так.

20
00:01:09,340 --> 00:01:09,980
Всё.

21
00:01:09,980 --> 00:01:17,030
Теперь в этом месте моя программа
в этом цикле не заблокируется,

22
00:01:17,030 --> 00:01:22,234
пока worker не отработает,
а сразу же перейдёт к следующему циклу,

23
00:01:22,234 --> 00:01:25,345
и в нём запустит следующую горутину.

24
00:01:25,345 --> 00:01:26,667
Но есть нюанс.

25
00:01:26,667 --> 00:01:31,498
В данном случае моя программа
может выйти сразу же после

26
00:01:31,498 --> 00:01:36,352
окончания цикла,
не дав поработать никаким горутинам.

27
00:01:36,352 --> 00:01:40,390
Поэтому я поставил fmt.Scanln (),
чтобы она дожидалась вывода от меня.

28
00:01:40,390 --> 00:01:44,855
Как с этим работать, мы узнаем дальше,
но сейчас давайте запустим и посмотрим,

29
00:01:44,855 --> 00:01:50,125
как наша программа
отрабатывает в режиме горутин.

30
00:01:50,125 --> 00:01:52,182
Итак, отлично.

31
00:01:52,182 --> 00:01:57,012
Смотрите, сначала отработал,
действительно, первый worker,

32
00:01:57,012 --> 00:02:04,137
успел урвать себе ресурсов, потом начался
четвёртый, уже не первый, а четвёртый.

33
00:02:04,137 --> 00:02:10,471
Причём он отработал не до конца,
а был прерван другими горутинами.

34
00:02:10,471 --> 00:02:14,996
То есть на самом деле это
не последовательный запуск,

35
00:02:14,996 --> 00:02:19,620
это параллельный,
просто выводится это всё последовательно.

36
00:02:19,620 --> 00:02:20,268
Итак.

37
00:02:20,268 --> 00:02:24,804
Теперь давайте попробуем
симулировать работу,

38
00:02:24,804 --> 00:02:28,630
как будто бы мы пошли
по сети и стоим ждём.

39
00:02:28,630 --> 00:02:34,450
В go есть возможность передать
управление другой горутине.

40
00:02:34,450 --> 00:02:38,900
Это находится в пакете runtime,
функция Goshed(),

41
00:02:38,900 --> 00:02:42,204
то есть вызвать планировщик задач.

42
00:02:42,204 --> 00:02:45,613
Смотрите, мы добавили всего
одну строчку и посмотрим,

43
00:02:45,613 --> 00:02:47,650
как изменится вывод нашей программы.

44
00:02:47,650 --> 00:02:51,000
Запускаем.

45
00:02:51,000 --> 00:02:56,030
Если раньше наши горутины
выполнялись в какой-то

46
00:02:56,030 --> 00:03:01,242
непонятной последовательности,
при этом одна могла успеть

47
00:03:01,242 --> 00:03:06,476
выполнить либо много итераций, либо
мало итераций, то сейчас она выполняет

48
00:03:06,476 --> 00:03:12,120
всего одну итерацию и передаёт
управление другой горутине.

49
00:03:12,120 --> 00:03:13,591
Вот так это выглядит.

50
00:03:13,591 --> 00:03:17,860
То есть вывод уже совсем другой,
не похож на предыдущий запуск.

51
00:03:17,860 --> 00:03:22,540
Но это всего лишь операция Goshed().

52
00:03:22,540 --> 00:03:25,699
На самом деле,

53
00:03:25,699 --> 00:03:30,770
внутри функции Printf(), вот здесь,

54
00:03:30,770 --> 00:03:35,660
тоже может вызваться планировщик задач,

55
00:03:35,660 --> 00:03:39,990
и он тоже может передать
работу другой горутине.

56
00:03:39,990 --> 00:03:46,880
При этом вы можете начать выполняться
на одном системном треде,

57
00:03:46,880 --> 00:03:51,070
а продолжить выполняться
на другом системном треде.

58
00:03:51,070 --> 00:03:55,786
То есть go не просто
блокируется на каких-то

59
00:03:55,786 --> 00:04:00,302
там сетевых вызовах и передаёт
управление дальше, нет.

60
00:04:00,302 --> 00:04:04,655
Планировщик может решить,
что эта горутина уже много поработала,

61
00:04:04,655 --> 00:04:11,660
давайте передадим другой, то есть ваша
программа не заблокируется просто в цикле.

62
00:04:11,660 --> 00:04:15,177
Да, она может заблокироваться в цикле,
если вы там совершаете простые

63
00:04:15,177 --> 00:04:18,130
математические операции без
вызова каких-либо функций.

64
00:04:18,130 --> 00:04:22,851
Также стоит отметить,
что из горутины вы не

65
00:04:22,851 --> 00:04:27,720
можете вернуть никакое значение

66
00:04:27,720 --> 00:04:32,580
в основную программу, туда,
где была вызвана эта горутина.

67
00:04:32,580 --> 00:04:37,440
Для этих целей используются каналы,

68
00:04:37,440 --> 00:04:40,820
про которые мы как раз и
поговорим в следующем видео.