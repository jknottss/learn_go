<!doctype html><html lang=en-us class=labs_live_alert_open><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=keywords content="Ardan Labs,Go,Programming,Blog,Go Programming,Golang"><title>The Behavior Of Channels</title><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-PHCW7L4');</script><meta name=description content="Introduction When I started to work with Go’s channels for the first time, I made the mistake of thinking about channels as a data structure. I saw channels as a queue that provided automatic synchronized access between goroutines. This structural understanding caused me to write a lot of bad and complicated concurrent code. I learned over time that it’s best to forget about how channels are structured and focus on how they behave."><meta property=og:title content="The Behavior Of Channels"><meta property=og:type content=website><meta property=og:description content="Our Blog is a great source of insights about Go, also referred as &amp;quot;golang&amp;quot;. Our main contributor Bill Kennedy is a renowned Go Trainer, consultant, and author."><meta property=og:url content=https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html><meta property=og:locale content=en><meta property=og:image content=http://ardanlabs.com/images/ardan-labs.jpg><meta property=og:image:secure_url content=https://www.ardanlabs.com/images/ardan-labs.jpg><meta property=og:type content=website><meta property=twitter:description content="Our Blog is a great source of insights about Go, also referred as &amp;quot;golang&amp;quot;. Our main contributor Bill Kennedy is a renowned Go Trainer, consultant, and author."><meta property=twitter:title content="The Behavior Of Channels"><meta property=twitter:image content=http://ardanlabs.com/images/ardan-labs-twitter-card.jpg><meta property=twitter:image:secure_url content=https://www.ardanlabs.com/images/ardan-labs-twitter-card.jpg><meta name=twitter:card content=summary_large_image><meta name=generator content="Hugo 0.47"><link rel=stylesheet href=https://www.ardanlabs.com/css/bundle.min.8b015d3e2805a934c7bfe1cbaae3cba4a45ae58042b382fbe1e37a7e460c5e54.css><link href="https://fonts.googleapis.com/css?family=Titillium+Web:300,400,500,700" rel=stylesheet><link rel="shortcut icon" href=https://www.ardanlabs.com/favicon.ico type=image/x-icon></head><body class=blog><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PHCW7L4" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><section class=alert-wrapper><div class="alert fade-in labs-live-alert" role=alert><button type=button class=close data-dismiss=alert aria-label=Close>
<span aria-hidden=true>×</span></button><p><strong>Ardan Labs Live |</strong> Join us for a month of classes & free talks to grow your engineering skills.
<a href=/ardan-labs-live>Explore Events <i class="fa fa-angle-right" aria-hidden=true></i></a><div id=content class=container><div id=countdown><ul><li><span id=days></span>d<li><span id=hours></span>h<li><span id=minutes></span>m<li><span id=seconds></span>s</ul></div></div><script>(function(){const second=1000,minute=second*60,hour=minute*60,day=hour*24;let today=new Date(),dd=String(today.getDate()).padStart(2,"0"),mm=String(today.getMonth()+1).padStart(2,"0"),yyyy=today.getFullYear(),nextYear=yyyy+1,dayMonth="02/16/",birthday=dayMonth+yyyy;today=mm+"/"+dd+"/"+yyyy;if(today>birthday){birthday=dayMonth+nextYear;}
const countDown=new Date(birthday).getTime(),x=setInterval(function(){const now=new Date().getTime(),distance=countDown-now;document.getElementById("days").innerText=Math.floor(distance/(day)),document.getElementById("hours").innerText=Math.floor((distance%(day))/(hour)),document.getElementById("minutes").innerText=Math.floor((distance%(hour))/(minute)),document.getElementById("seconds").innerText=Math.floor((distance%(minute))/second);if(distance<0){document.getElementById("countdown").style.display="none";document.getElementById("content").style.display="block";clearInterval(x);}},0)}());</script></div></section><div class="nav-wrap affix-top"><nav><div class=nav-inner><div class=nav-brand><a href=/><img src=https://www.ardanlabs.com/images/ardanlabs-logo.svg alt="Ardan Labs"></a></div><div class=nav-links><ul class=main><li class=training><a class="menu-toggle training_menu" href=#.>Training
<span><i class="fa fa-chevron-up" aria-hidden=true></i></span></a><div class=nav-dropdown><div class="nav-dropdown-inner parent-flex"><div class=main-links><p>Our training paths<ul><li><a class=all_training href=/training><span><img src=https://www.ardanlabs.com/images/drop-menu-all-icon.svg alt="Ardan Labs"></span> All Training</a><li><a class=on_demand href=/education target=_blank><span><img src=https://www.ardanlabs.com/images/drop-menu-video-icon.svg alt="Ardan Labs"></span> On-Demand</a><li><a class=ardan_labs_live href=/ardan-labs-live/><span><img src=https://www.ardanlabs.com/images/drop-menu-live-icon.svg alt="Ardan Labs"></span> Ardan Labs Live<br><i class=dates>Feb 28 - Apr 8</i></a></ul></div><div class=sub-links><p>Grow your skills<ul><li><a class=go_training_link href=/ultimate-go>Go</a><li><a class=k8s_training_link href=/intensive-docker-kubernetes>K8s</a><li><a class=python_training_link href=/python-training>Python</a><li><a class=terraform_training_link href=/terraform-training>Terraform</a><li><a class=dgraph_training_link href=/ultimate-dgraph>Dgraph</a></ul></div></div></div><li class=consulting><a href=/development>Development</a><li class=devops><a href=/devops-consulting>DevOps</a><li class=blockchain><a href=/blockchain>Blockchain</a><li class=staffing><a class=consulting_click href=/staffing>Staffing</a><li class=careers><a href=/careers>Careers</a><li class=blog><a href=/blog>Blog</a></ul><ul class=util><li><a href=https://courses.ardanlabs.com/users/sign_in>Sign In</a><li class="contact letstalk"><button type=button class="btn btn-lets-talk lets_talk_btn" data-toggle=modal data-target=#contactModal data-lets-talk=lets-talk-nav>
<i class="fa fa-comments-o" aria-hidden=true></i>&nbspLet's Talk</button></ul></div><div class=nav-mobile><button class="hamburger navbar-toggler second-button" type=button data-toggle=collapse data-target=#navbarSupportedContent23 aria-controls=navbarSupportedContent23 aria-expanded=false aria-label="Toggle navigation"><div class=animated-icon2><span></span><span></span><span></span><span></span></div></button>
<button type=button class="btn btn-lets-talk" data-toggle=modal data-target=#contactModal>
<i class="fa fa-comments-o" aria-hidden=true></i>&nbspLet's Talk</button></div></div></nav></div><div style=display:none class=div-fix style=height:0;width:100% id=nav><nav class="navbar navbar-default" data-spy=affix data-offset-top=0><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#navbar-collapse>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button><div class=brand-box></div><button type=button class=btn data-toggle=modal data-target=#contactModal>
<i class="fa fa-comments-o" aria-hidden=true></i>&nbspLet's Talk</button></div><div class="collapse navbar-collapse" id=navbar-collapse><ul class="nav navbar-nav navbar-right"><div class=modal-header><li class=go-training><a href=/training>Training</a><li class=consulting><a href=/development>Development</a><li class=devops><a href=/devops-consulting>DevOps</a><li class=staffing><a class=consulting_click href=/staffing>Staffing</a><li class=careers><a href=/careers>Careers</a><li class=about><a href=/about>About</a><li class=blog><a href=/blog>Blog</a><li class="contact letstalk"><button type=button class=btn data-toggle=modal data-target=#contactModal>
<i class="fa fa-comments-o" aria-hidden=true></i>&nbspLet's Talk</button></ul></div></div></nav></div><div class=content><header class=blog-header><div class=container><div class=row><div class=col-lg-12><div class=header-intro><h2 class=title>Subscribe to the Ardan Labs <span>Insider</span></h2><p class=into-text>You’ll get our <b>FREE</b> Video Series & special offers on upcoming training events along with notifications on our latest blog posts.<div class=alternate><b>Included in your subscription</b><ul><li><i class="fa fa-check-circle" aria-hidden=true></i>Access to our free video previews<li><i class="fa fa-check-circle" aria-hidden=true></i>Updates on our latest blog posts<li><i class="fa fa-check-circle" aria-hidden=true></i>Discounts on upcoming events</ul></div><form class=subscriber-form><div class="form-wrap parent-flex"><input type=hidden id=tags name=tags value=Blog>
<input class=form-control name=email placeholder="email address">
<input type=submit value=Subscribe href=https://www.ardanlabs.com/subscribe class="btn btn-lets-talk subscribebtn"><p class=error-message>Valid email required.<p class=failed-message>Submit failed. Try again or message us directly at <a href=mailto:hello@ardanlabs.com class=text-link>hello@ardanlabs.com.</a></div><div class=confirmation-message><img src=https://www.ardanlabs.com/images/check.svg><h1>Thank You for Subscribing</h1><p>Check your email for confirmation.</div></form></div></div></div></div></header><section class=ribbon-slider><div id=promo-ribbon class="carousel slide" data-ride=carousel><div class=carousel-inner role=listbox><div class="item active"><a href=/ardan-labs-live class="ribbon-slider-link ardan_labs_live_click"><p><img src=https://www.ardanlabs.com/images/live-promo-small.png><b>Ardan Labs Live</b>: Feb 28th - Apr 8th, 2022 <span>Explore Events</span></p></a></div><div class=item class=ultimate_go_notebook_click><a class=ribbon-slider-link href=https://courses.ardanlabs.com/courses/ultimate-go-notebook target=_blank><p><img src=https://www.ardanlabs.com/images/book-promo-img-small.png>Introducing the <b>Ultimate Go Notebook</b>. Turn your programming into engineering. <span>Get your copy</span></p></a></div><div class=item class=education_click><a class=ribbon-slider-link href=https://www.ardanlabs.com/education/ target=_blank><p><img src=https://www.ardanlabs.com/images/edu-cert.png>Advanced Self-Paced Video Training. Learn <b>Go</b>, <b>K8s</b> & grow your engineering skills. <span>Free Preview</span></p></a></div></div><a class="left carousel-control" href=#promo-ribbon role=button data-slide=prev><span class="glyphicon glyphicon-chevron-left fa fa-angle-left" aria-hidden=true></span><span class=sr-only>Previous</span></a>
<a class="right carousel-control" href=#promo-ribbon role=button data-slide=next><span class="glyphicon glyphicon-chevron-right fa fa-angle-right" aria-hidden=true></span><span class=sr-only>Next</span></a></div></section><div class=container><ul class=breadcrumbs><li><a href=/>Home ></a><li><a href=/blog>Blog ></a><li id=title>The Behavior Of Channels</ul><div class=row><div class=col-lg-12><div class=blog-links><a href=https://www.ardanlabs.com/all-posts class="btn btn-secondary-outline"><i class="fa fa-list" aria-hidden=true></i>&nbsp;
List All Posts</a>
<a id=rsslinkbtn data-toggle=popover data-placement=top data-content="RSS link copied to clipboard" class="btn btn-secondary-outline" data-clipboard-text=https://www.ardanlabs.com/blog/index.xml><i class="fa fa-rss" aria-hidden=true></i>&nbsp; RSS</a></div><div class=clearfix></div><div class=single-post><header><h1 class=title>The Behavior Of Channels</h1><div class=author-flex><span class=author-section><img class=author-thumb src=https://www.ardanlabs.com//images/avatar-william-Kennedy.jpg alt="Author image" nopin=nopin></span><div class=author-info><span class=author-section><p class=author-name>William Kennedy</p><span class=post-date>October 24, 2017</span><ul class=author-social><li class=icon><a href=mailto:bill@ardanlabs.com title=bill@ardanlabs.com><i class="fa fa-envelope-o" aria-hidden=true></i></a><li class=icon><a href=https://github.com/ardanlabs/gotraining title=ardanlabs/gotraining target=_blank><i class="fa fa-github-square" aria-hidden=true></i></a><li class=icon><a href=https://twitter.com/goinggodotnet title=goinggodotnet target=_blank><i class="fa fa-twitter-square" aria-hidden=true></i></a></ul></span></div></div></header><section class=post-content><h3 id=introduction>Introduction</h3><p>When I started to work with Go’s channels for the first time, I made the mistake of thinking about channels as a data structure. I saw channels as a queue that provided automatic synchronized access between goroutines. This structural understanding caused me to write a lot of bad and complicated concurrent code.<p>I learned over time that it’s best to forget about how channels are structured and focus on how they behave. So now when it comes to channels, I think about one thing: <strong>signaling</strong>. A channel allows one goroutine to signal another goroutine about a particular event. Signaling is at the core of everything you should be doing with channels. Thinking of channels as a signaling mechanism will allow you to write better code with well defined and more precise behavior.<p>To understand how signaling works, we must understand its three attributes:<ul><li>Guarantee Of Delivery<li>State<li>With or Without Data</ul><p>These three attributes work together to create a design philosophy around signaling. After I discuss these attributes, I will provide a number of code examples that demonstrate signaling with these attributes applied.<h3 id=guarantee-of-delivery>Guarantee Of Delivery</h3><p>The Guarantee Of Delivery is based on one question: “Do I need a guarantee that the signal sent by a particular goroutine has been received?”<p>In other words, given this example in listing 1:<p><strong>Listing 1</strong><pre><code>01 go func() {
02     p := &lt;-ch // Receive
03 }()
04
05 ch &lt;- &quot;paper&quot; // Send
</code></pre><p>Does the sending goroutine need a guarantee that the <code>paper</code> being sent over the channel on line 05 was received by the goroutine on line 02 before moving on?<p>Based on the answer to this question, you will know which of the two types of channels to use: <strong>Unbuffered</strong> or <strong>Buffered</strong>. Each channel provides a different behavior around guarantees of delivery.<p><strong>Figure 1 : Guarantee Of Delivery</strong><p><img src=../../../images/goinggo/86_guarantee_of_delivery.png alt="Guarantee Of Delivery"><p>Guarantees are important, and, if you don’t think so, I have a ton of things I want to sell you. Of course, I’m trying to make a joke, but don’t you get nervous when you don’t have guarantees in life? Having a strong understanding of whether or not you need a guarantee is crucial when writing concurrent software. As we continue, you&rsquo;ll learn how to decide.<h3 id=state>State</h3><p>The behavior of a channel is directly influenced by its current State. The state of a channel can be <strong>nil</strong>, <strong>open</strong> or <strong>closed</strong>.<p>Listing 2 below shows how to declare or place a channel into each of these three states.<p><strong>Listing 2</strong><pre><code>// ** nil channel

// A channel is in a nil state when it is declared to its zero value
var ch chan string

// A channel can be placed in a nil state by explicitly setting it to nil.
ch = nil


// ** open channel

// A channel is in a open state when it’s made using the built-in function make.
ch := make(chan string)    


// ** closed channel

// A channel is in a closed state when it’s closed using the built-in function close.
close(ch)
</code></pre><p>The state determines how the <strong>send</strong> and <strong>receive</strong> operations behave.<p><em>Signals are sent and received through a channel. Don’t say read/write because channels don’t perform I/O.</em><p><strong>Figure 2 : State</strong><p><img src=../../../images/goinggo/86_state.png alt=State><p>When a channel is in a <strong>nil</strong> state, any send or receive attempted on the channel will block. When a channel is in an <strong>open</strong> state, signals can be sent and received. When a channel is placed into a <strong>closed</strong> state, signals can no longer be sent but it’s still possible to receive signals.<p>These states will provide the different behaviors you need for the different situations you encounter. When combining <strong>State</strong> with <strong>Guarantee Of Delivery</strong>, you can begin to analyze the costs/benefits you are incurring as a result of your design choices. In many cases, you will also be able to quickly spot bugs just by reading the code, because you understand how the channel is going to behave.<h3 id=with-and-without-data>With and Without Data</h3><p>The last signaling attribute that needs to be taken into account is whether you need to signal <strong>with</strong> or <strong>without</strong> data.<p>You signal <strong>with</strong> data by performing a send on a channel.<p><strong>Listing 3</strong><pre><code>01 ch &lt;- &quot;paper&quot;
</code></pre><p>When you signal with data, it’s usually because:<ul><li>A goroutine is being asked to start a new task.<li>A goroutine reports back a result.</ul><p>You signal <strong>without</strong> data by closing a channel.<p><strong>Listing 4</strong><pre><code>01 close(ch)
</code></pre><p>When you signal without data, it’s usually because:<ul><li>A goroutine is being told to stop what they are doing.<li>A goroutine reports back they are done with no result.<li>A goroutine reports that it has completed processing and shut down.</ul><p><em>There are exceptions to these rules, but these are the major use cases and the ones we will focus on in this post. I would consider exceptions to these rules to be an initial code smell.</em><p>One benefit of signaling without data is a single goroutine can signal many goroutines at once. Signaling with data is always a 1 to 1 exchange between goroutines.<h3 id=signaling-with-data>Signaling With Data</h3><p>When you are going to signal with data, there are three channel configuration options you can choose depending on the type of guarantee you need.<p><strong>Figure 3 : Signaling With Data</strong><p><img src=../../../images/goinggo/86_signaling_with_data.png alt><p>The three channel options are <strong>Unbuffered</strong>, <strong>Buffered &gt;1</strong> or <strong>Buffered =1</strong>.<ul><li><p><strong>Guarantee</strong><ul><li>An <strong>Unbuffered</strong> channel gives you a <strong>Guarantee</strong> that a signal being sent has been received.<ul><li>Because the <strong>Receive</strong> of the signal <strong>Happens Before</strong> the <strong>Send</strong> of the signal completes.</ul></ul><li><p><strong>No Guarantee</strong><ul><li>A <strong>Buffered</strong> channel of size <strong>&gt;1</strong> gives you <strong>No Guarantee</strong> that a signal being sent has been received.<ul><li>Because the <strong>Send</strong> of the signal <strong>Happens Before</strong> the <strong>Receive</strong> of the signal completes.</ul></ul><li><p><strong>Delayed Guarantee</strong><ul><li>A <strong>Buffered</strong> channel of size <strong>=1</strong> gives you a <strong>Delayed Guarantee</strong>. It can guarantee that the previous signal that was sent has been received.<ul><li>Because the <strong>Receive</strong> of the <strong>First Signal, Happens Before</strong> the <strong>Send</strong> of the <strong>Second Signal</strong> completes.</ul></ul></ul><p><em>The size of the buffer must never be a random number, It must always be calculated for some well defined constraint. There is no infinity in computing, everything must have some well defined constraint whether that is time or space.</em><h3 id=signaling-without-data>Signaling Without Data</h3><p>Signaling without data is mainly reserved for cancellation. It allows one goroutine to signal another goroutine to cancel what they are doing and move on. Cancellation can be implemented using both Unbuffered and Buffered channels, but using a Buffered channel when no data will be sent is a code smell.<p><strong>Figure 4 : Signaling Without Data</strong><p><img src=../../../images/goinggo/86_signaling_without_data.png alt><p>The built-in function <code>close</code> is used to signal without data. As explained above in the <strong>State</strong> section, you can still receive signals on a channel that is closed. In fact, any receive on a closed channel will not block and the receive operation always returns.<p>In most cases you want to use the standard library <code>context</code> package to implement signaling without data. The <code>context</code> package uses an Unbuffered channel underneath for the signaling and the built-in function <code>close</code> to signal without data.<p><em>If you choose to use your own channel for cancellation, rather than the context package, your channel should be of type <code>chan struct{}</code>. It is the zero-space, idiomatic way to indicate a channel used only for signalling.</em><h3 id=scenarios>Scenarios</h3><p>With these attributes in place, the best way to further understand how they work in practice is to run through a series of code scenarios. I like thinking of goroutines as people when I am reading and writing channel based code. This visualization really helps, and I will use it as an aid below.<h4 id=signal-with-data-guarantee-unbuffered-channels>Signal With Data - Guarantee - Unbuffered Channels</h4><p>When you need to know that a signal being sent has been received, two scenarios come into play. These are <strong>Wait For Task</strong> and <strong>Wait For Result</strong>.<p><strong>Scenario 1 - Wait For Task</strong><p>Think about being a manager and hiring a new employee. In this scenario, you want your new employee to perform a task but they need to wait until you are ready. This is because you need to hand them a piece of paper before they start.<p><strong>Listing 5</strong><br><a href=https://play.golang.org/p/BnVEHRCcdh>https://play.golang.org/p/BnVEHRCcdh</a><pre><code>01 func waitForTask() {
02     ch := make(chan string)
03
04     go func() {
05         p := &lt;-ch
06
07         // Employee performs work here.
08
09         // Employee is done and free to go.
10     }()
11
12     time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
13
14     ch &lt;- &quot;paper&quot;
15 }
</code></pre><p>On line 02 in listing 5, an Unbuffered channel is created with the attribute that <code>string</code> data will be sent with the signal. Then on line 04, an employee is hired and told to wait for your signal on line 05 before doing their work. Line 05 is the channel receive, causing the employee to block while waiting for the piece of paper you will send. Once the paper is received by the employee, the employee performs the work and then is done and free to go.<p>You as the manager are working concurrently with your new employee. So after you hire the employee on line 04, you find yourself (on line 12) doing what you need to do to unblock and signal the employee. Note, it was unknown just how long it would take to prepare this piece of paper you need to send.<p>Eventually you are ready to signal the employee. On line 14, you perform a signal with data, the data being that piece of paper. Since an Unbuffered channel is being used, you get a guarantee that the employee has received the paper once your send operation completes. The receive happens before the send.<p><em>Technically all you know is that the employee has the paper by the time your channel send operation completes. After both channel operations, the scheduler can choose to execute any statement it wants. The next line of code that is executed either by you or the employee is nondeterministic. This means using print statements can fool you about the order of things.</em><p><strong>Scenario 2 - Wait For Result</strong><p>In this next scenario things are reversed. This time you want your new employee to perform a task immediately when they are hired, and you need to wait for the result of their work. You need to wait because you need the paper from them before you can continue.<p><strong>Listing 6</strong><br><a href=https://play.golang.org/p/VFAWHxIQTP>https://play.golang.org/p/VFAWHxIQTP</a><pre><code>01 func waitForResult() {
02     ch := make(chan string)
03
04     go func() {
05         time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
06
07         ch &lt;- &quot;paper&quot;
08
09         // Employee is done and free to go.
10     }()
11
12     p := &lt;-ch
13 }
</code></pre><p>On line 02 in listing 6, an Unbuffered channel is created with the attribute that <code>string</code> data will be sent with the signal. Then on line 04, an employee is hired and is immediately put to work. After you hire the employee on line 04, you find yourself next on line 12 waiting for the paper report.<p>Once the work is completed by the employee on line 05, they send the result to you on line 07 by performing a channel send with data. Since this is an Unbuffered channel, the receive happens before the send and the employee is guaranteed that you have received the result. Once the employee has this guarantee, they are done and free to go. In this scenario, you have no idea how long it is going to take the employee to finish the task.<p><strong>Cost/Benefit</strong><p>An Unbuffered channel provides a guarantee that a signal being sent was received. This is great, but nothing is free. The cost of this guarantee is unknown latency. In the <strong>Wait For Task</strong> scenario, the employee has no idea how long it’s going to take for you to send that paper. In the <strong>Wait For Result</strong> scenario, you have no idea how long it’s going to take the employee to send you that result.<p>In both scenarios, this unknown latency is something we have to live with because the guarantee is required. The logic doesn’t work without this guaranteed behavior.<h4 id=signal-with-data-no-guarantee-buffered-channels-1>Signal With Data - No Guarantee - Buffered Channels &gt;1</h4><p>When you don’t need to know that a signal being sent has been received, these two scenarios come into play: <strong>Fan Out</strong> and <strong>Drop</strong>.<p>A Buffered channel has a well defined space that can be used to store the data being sent. So how do you decide how much space you need? Answer these questions:<ul><li>Do I have a well defined amount of work to be completed?<ul><li>How much work is there?</ul><li>If my employee can’t keep up, can I discard any new work?<ul><li>How much outstanding work puts me at capacity?</ul><li>What level of risk am I willing to accept if my program terminates unexpectedly?<ul><li>Anything waiting in the buffer will be lost.</ul></ul><p>If these questions don’t make sense for the behavior you are modeling, it’s a code smell that using a Buffered channel any larger than 1 is probably wrong.<p><strong>Scenario 1 - Fan Out</strong><p>A fan out pattern allows you to throw a well defined number of employees at a problem who work concurrently. Since you have one employee for every task, you know exactly how many reports you will receive. You can make sure there is the right amount of space in your box to receive all those reports. This has the benefit of your employees not needing to wait for you to submit their report. They do however need to each take a turn placing the report in your box if they arrive at the box at or near the same time.<p>Imagine you are the manager again but this time you hire a team of employees. You have an individual task you want each employee to perform. As each individual employee finishes their task, they need to provide you with a paper report that must be placed in your box on your desk.<p><strong>Listing 7</strong><br><a href=https://play.golang.org/p/8HIt2sabs_>https://play.golang.org/p/8HIt2sabs_</a><pre><code>01 func fanOut() {
02     emps := 20
03     ch := make(chan string, emps)
04
05     for e := 0; e &lt; emps; e++ {
06         go func() {
07             time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
08             ch &lt;- &quot;paper&quot;
09         }()
10     }
11
12     for emps &gt; 0 {
13         p := &lt;-ch
14         fmt.Println(p)
15         emps--
16     }
17 }
</code></pre><p>On line 03 in listing 7, a Buffered channel is created with the attribute that <code>string</code> data will be sent with the signal. This time the channel is created with 20 buffers thanks to the <code>emps</code> variable declared on line 02.<p>Between lines 05 through 10, 20 employees are hired and they immediately get to work. You have no idea how long each employee is going to take on line 07. Then on line 08, the employees send the paper report but this time the send does not block waiting for a receive. Since there is room in the box for each employee, the send on the channel is only competing with other employees that may want to send their report at or near the same time.<p>The code between lines 12 through 16 is all you. This is where you wait for all 20 employees to finish their work and send their report. On line 12, you are in a loop and on line 13 you are blocked in a channel receive waiting for your reports. Once a report is received, the report is printed on line 14 and the local counter variable is decremented to indicate an employee is done.<p><strong>Scenario 2 - Drop</strong><p>A drop pattern allows you to throw work away when your employee(s) are at capacity. This has the benefit of continuing to accepting work from your clients and never applying back pressure or latency in the acceptance of that work. The key here is knowing when you are truly at capacity so you don’t under or over commit to the amount of work you will attempt to get done. Usually integration testing or metrics is what you need to help you identify this number.<p>Imagine you are the manager again and you hire a single employee to get work done. You have an individual task you want the employee to perform. As the employee finishes their task you don’t care to know they are done. All that’s important is whether you can or can’t place new work in the box. If you can’t perform the send, then you know your box is full and the employee is at capacity. At this point the new work needs to be discarded so things can keep moving.<p><strong>Listing 8</strong><br><a href=https://play.golang.org/p/PhFUN5itiv>https://play.golang.org/p/PhFUN5itiv</a><pre><code>01 func selectDrop() {
02     const cap = 5
03     ch := make(chan string, cap)
04
05     go func() {
06         for p := range ch {
07             fmt.Println(&quot;employee : received :&quot;, p)
08         }
09     }()
10
11     const work = 20
12     for w := 0; w &lt; work; w++ {
13         select {
14             case ch &lt;- &quot;paper&quot;:
15                 fmt.Println(&quot;manager : send ack&quot;)
16             default:
17                 fmt.Println(&quot;manager : drop&quot;)
18         }
19     }
20
21     close(ch)
22 }
</code></pre><p>On line 03 in listing 8, a Buffered channel is created with the attribute that <code>string</code> data will be sent with the signal. This time the channel is created with 5 buffers thanks to the <code>cap</code> constant declared on line 02.<p>Between lines 05 through 09 a single employee is hired to handle the work. A <code>for range</code> is used for the channel receive. Every time a piece of paper is received it is processed on line 07.<p>Between lines 11 through 19 you attempt to send 20 pieces of paper to your employee. This time a <code>select</code> statement is used to perform the send inside the first <code>case</code> on line 14. Since the <code>default</code> clause is being used inside the <code>select</code> on line 16, if the send is going to block because there is no more room in the buffer, the send is abandoned by executing line 17.<p>Finally on line 21, the built-in function <code>close</code> is called against the channel. This will signal without data to the employee they are done and free to go once they completed their assigned work..<p><strong>Cost/Benefit</strong><p>A Buffered channel greater than 1 provides no guarantee that a signal being sent is ever received. There is a benefit of walking away from this guarantee, which is the reduced or no latency in the communication between two goroutines. In the <strong>Fan Out</strong> scenario, there is a buffer space for each employee that will be sending a report. In the <strong>Drop</strong> scenario, the buffer is measured for capacity and if capacity is reached work is dropped so things can keep moving.<p>In both options, this lack of a guarantee is something we have to live with because the reduction in latency is more important. The requirement of zero to minimum latency doesn’t pose a problem to the overall logic of the system.<h4 id=signal-with-data-delayed-guarantee-buffered-channel-1>Signal With Data - Delayed Guarantee - Buffered Channel 1</h4><p>When it’s necessary to know if the previous signal that was sent has been received before sending a new signal, the <strong>Wait For Tasks</strong> scenario come into play.<p><strong>Scenario 1 - Wait For Tasks</strong><p>In this scenario you have a new employee but they are going to do more than just one task. You are going to feed them many tasks, one after the other. However, they must finish each individual task before they can start a new one. Since they can only work on one task at a time there could be latency issues between the handoff of work. If the latency could be reduced without losing the guarantee that the employee is working on the next task, it could help.<p>This is where a Buffered channel of 1 has benefit. If everything is running at the expected pace between you and the employee, neither of you will need to wait for the other. Every time you send a piece of paper, the buffer is empty. Every time your employee reaches for more work, the buffer is full. It is a perfect symmetry of work flow.<p>The best part is this. If at any time you attempt to send a piece of paper and you can’t because the buffer is full, you know your employee is having a problem and you stop. This is where that delayed guarantee comes in. When the buffer is empty and you perform the send, you have the guarantee that your employee has taken the last piece of work you sent. If you perform the send and you can’t, you have the guarantee they haven’t.<p><strong>Listing 9</strong><br><a href=https://play.golang.org/p/4pcuKCcAK3>https://play.golang.org/p/4pcuKCcAK3</a><pre><code>01 func waitForTasks() {
02     ch := make(chan string, 1)
03
04     go func() {
05         for p := range ch {
06             fmt.Println(&quot;employee : working :&quot;, p)
07         }
08     }()
09
10     const work = 10
11     for w := 0; w &lt; work; w++ {
12         ch &lt;- &quot;paper&quot;
13     }
14
15     close(ch)
16 }
</code></pre><p>On line 02 in listing 9, a Buffered channel of size 1 is created with the attribute that <code>string</code> data will be sent with the signal. Between lines 04 through 08 a single employee is hired to handle the work. A <code>for range</code> is used for the channel receive. Every time a piece of paper is received it is processed on line 06.<p>Between lines 10 through 13 you begin to send your tasks to the employee. If your employee can run as fast as you can send, the latency between you two is reduced. But with each send you perform successfully, you have the guarantee that the last piece of work you submitted is being worked on.<p>Finally on line 15, the built-in function <code>close</code> is called against the channel. This will signal without data to the employee they are done and free to go. However, the last piece of work you submitted will be received (flushed) before the <code>for range</code> is terminated.<h4 id=signal-without-data-context>Signal Without Data - Context</h4><p>In this last scenario you will see how you can cancel a running goroutine using a <code>Context</code> value from the <code>context</code> package. This all works by leveraging an Unbuffered channel that is closed to perform a signal without data.<p>You are the manager one last time and you hire a single employee to get work done. This time you are not willing to wait for some unknown amount of time for the employee to finish. You are on a discrete deadline and if the employee doesn’t finish in time, you are not willing to wait.<p><strong>Listing 10</strong><br><a href=https://play.golang.org/p/6GQbN5Z7vC>https://play.golang.org/p/6GQbN5Z7vC</a><pre><code>01 func withTimeout() {
02     duration := 50 * time.Millisecond
03
04     ctx, cancel := context.WithTimeout(context.Background(), duration)
05     defer cancel()
06
07     ch := make(chan string, 1)
08
09     go func() {
10         time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
11         ch &lt;- &quot;paper&quot;
12     }()
13
14     select {
15     case p := &lt;-ch:
16         fmt.Println(&quot;work complete&quot;, p)
17
18     case &lt;-ctx.Done():
19         fmt.Println(&quot;moving on&quot;)
20     }
21 }
</code></pre><p>On line 02 in listing 10, a duration value is declared which represents how long the employee will have to finish the task. This value is used on line 04 to create a <code>context.Context</code> value with a timeout of 50 milliseconds. The <code>WithTimeout</code> function from the <code>context</code> package returns a <code>Context</code> value and a cancellation function.<p>The <code>context</code> package creates a goroutine that will close the Unbuffered channel associated with the <code>Context</code> value once the duration is met. You are responsible for calling the <code>cancel</code> function regardless of how things turn out. This will clean things up that have been created for the <code>Context</code>. It is ok for the <code>cancel</code> function to be called more than once.<p>On line 05, the <code>cancel</code> function is deferred to be executed once this function terminates. On line 07 a Buffered channel of 1 is created, which is going to be used by the employee to send you the result of their work. Then on lines 09 through 12, the employee is hired and immediately put to work. You have no idea how long it is going to take the employee to finish.<p>Between lines 14 through 20 you use the <code>select</code> statement to receive on two channels. The receive on line 15, you wait for the employee to send you their result. The receive on line 18, you wait to see if the <code>context</code> package is going to signal that the 50 milliseconds is up. Whichever signal you receive first will be the one processed.<p><em>An important aspect of this algorithm is the use of the Buffered channel of 1. If the employee doesn’t finish in time, you are moving on without giving the employee any notice. From the employee perspective, they will always send you the report on line 11 and they are blind if you are there or not to receive it. If you use an Unbuffered channel, the employee will block forever trying to send you the report if you move on. This would create a goroutine leak. So a Buffered channel of 1 is being used to prevent this from happening.</em><h3 id=conclusion>Conclusion</h3><p>The attributes of signaling around guarantees, channel state and sending are important to know and understand when using channels (or concurrency). They will help guide you in implementing the best behavior you need for the concurrent programs and algorithms you are writing. They will help you find bugs and sniff out potentially bad code.<p>In this post I have shared a few sample programs that show how the attributes of signaling work in different scenarios. There are exceptions to every rule but these patterns are a good foundation to start.<p>Review these outlines as a summary of when and how to effectively think about and use channels:<p><strong>Language Mechanics</strong><ul><li>Use channels to orchestrate and coordinate goroutines.<ul><li>Focus on the signaling attributes and not the sharing of data.<li>Signaling with data or without data.<li>Question their use for synchronizing access to shared state.<ul><li>There are cases where channels can be simpler for this but initially question.</ul></ul><li>Unbuffered channels:<ul><li>Receive happens before the Send.<li>Benefit: 100% guarantee the signal has been received.<li>Cost: Unknown latency on when the signal will be received.</ul><li>Buffered channels:<ul><li>Send happens before the Receive.<li>Benefit: Reduce blocking latency between signaling.<li>Cost: No guarantee when the signal has been received.<ul><li>The larger the buffer, the less guarantee.<li>Buffer of 1 can give you one delayed send of guarantee.</ul></ul><li>Closing channels:<ul><li>Close happens before the Receive (like Buffered).<li>Signaling without data.<li>Perfect for signaling cancellations and deadlines.</ul><li>nil channels:<ul><li>Send and Receive block.<li>Turn off signaling<li>Perfect for rate limiting or short term stoppages.</ul></ul><p><strong>Design Philosophy</strong><ul><li>If any given Send on a channel CAN cause the sending goroutine to block:<ul><li>Not allowed to use a Buffered channel larger than 1.<ul><li>Buffers larger than 1 must have reason/measurements.</ul><li>Must know what happens when the sending goroutine blocks.</ul><li>If any given Send on a channel WON&rsquo;T cause the sending goroutine to block:<ul><li>You have the exact number of buffers for each send.<ul><li>Fan Out pattern</ul><li>You have the buffer measured for max capacity.<ul><li>Drop pattern</ul></ul><li>Less is more with buffers.<ul><li>Don’t think about performance when thinking about buffers.<li>Buffers can help to reduce blocking latency between signaling.<ul><li>Reducing blocking latency towards zero does not necessarily mean better throughput.<li>If a buffer of one is giving you good enough throughput then keep it.<li>Question buffers that are larger than one and measure for size.<li>Find the smallest buffer possible that provides good enough throughput.</ul></ul></ul></section><div class=clearfix></div></div></div></div></div><div class=clearfix></div><div class=container-fluid><div class=row><div class=go-training-area><div class=col-md-12><h1 class=go-training-title>Go Training</h1><p>We have taught Go to thousands of developers all around the world since 2014. There is no other company that has been doing it longer and our material has proven to help jump start developers 6 to 12 months ahead of their knowledge of Go. We know what knowledge developers need in order to be productive and efficient when writing software in Go.<p>Our classes are perfect for both experienced and beginning engineers. We start every class from the beginning and get very detailed about the internals, mechanics, specification, guidelines, best practices and design philosophies. We cover a lot about "if performance matters" with a focus on mechanical sympathy, data oriented design, decoupling and writing production software.</div><div class="col-md-12 training-clients"><div class=training-clients-area><div class=training-clients-box><span><img alt="Capital One" src=https://www.ardanlabs.com/images/client-logos/white/training-client01.png></span></div><div class=training-clients-box><span><img alt=Cisco src=https://www.ardanlabs.com/images/client-logos/white/training-client02.png></span></div><div class=training-clients-box><span><img alt=Visa src=https://www.ardanlabs.com/images/client-logos/white/training-client03.png></span></div><div class=training-clients-box><span><img alt=Teradata src=https://www.ardanlabs.com/images/client-logos/white/training-client04.png></span></div><div class=training-clients-box><span><img alt="Red Ventures" src=https://www.ardanlabs.com/images/client-logos/white/training-client05.png></span></div></div></div><div class="col-md-12 corporate-training"><p>Interested in Ultimate Go Corporate Training and special pricing?</p><a href="mailto:hello@ardanlabs.com?Subject=Let’s%20Talk%20Ultimate%20Go%20Corporate%20Training%20and%20special%20pricing!" class="button btn-sm">Let’s Talk Corporate Training!</a></div><div class=clearfix></div></div><div class=video-training-section><div class=parent-flex><div class=info><h1>Join Our Online<br>Education Program</h1><p>Our courses have been designed from training over 4,000 engineers since 2013 and they go beyond just being a language course. Our goal is to challenge every student to think about what they are doing and why.</div><div class=image><a class="btn btn-lets-talk" href=https://www.ardanlabs.com/education target=_blank><i class="fa fa-plus" aria-hidden=true></i>Enroll Now</a></div></div></div></div></div></div><div class="modal fade" id=contactModal tabindex=-1 role=dialog aria-labelledby=exampleModalLabel aria-hidden=true><div class=modal-dialog role=document><div class=modal-content><div class=modal-body><div class=contact-modal-header><h1><i class="fa fa-comments-o" aria-hidden=true></i>Let's Talk</h1><p>Please fill out the form below and we'll get back to you soon.</p><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&times;</span></button></div><div id=success_confirmation><form name=contact-modal action=/api/contact/email method=post><div class="inner-form-wrap parent-flex"><div class=personal-info><h1><b>1.</b> Fill in your personal info</h1><div class="form-group name"><label class=required>Full Name</label>
<input name=name id=name class=form-control placeholder="Your name">
<label class=error for=name id=name_error>This field is required.</label></div><div class="form-group email"><label class=required>E-mail</label>
<input name=email id=email class=form-control placeholder="Your e-mail">
<label class=error for=email id=email_error>This field is required.</label>
<label class=error for=email id=email_error_sintax>Invalid email.</label></div><div class="form-group company"><label>Company</label>
<input name=company id=company class=form-control placeholder="Your company">
<label class=error for=company id=company_error>This field is required.</label></div><div class="form-group phone"><label>Phone</label>
<input name=phone id=phone class=form-control placeholder="Your phone number"></div></div><div class=message-info><h1><b>2.</b> Tell us about what you need</h1><div class="form-group reason" id=group_reason><label class="pull-left required">Reason for contact</label>
<select type=select class=form-control id=interests name=interests placeholder="What are you interested in?">
<option value><option value=caddy>Caddy Server
<option value=gotraining>Go Training
<option value=kubernetestraining>Kubernetes Training
<option value=blockchain>Blockchain Consulting
<option value=training-quote>Online Video Training
<option value=development>Development
<option value=staffaugmentation>Staff Augmentation
<option value=devops>Dev Ops
<option value=uiux>UI / UX
<option value=other>Other</select>
<label class=error for=reason id=reason_error>This field is required.</label></div><div class="form-group reason" id=group_forwho><label class="pull-left required">Is this for you or your company?</label>
<select type=select class=form-control id=is-for-company>
<option value><option value=false>For me
<option id=for-company value=true>For my company</select>
<label class=error for=is-for-company id=forwho_error>This field is required.</label></div><div class="form-group message" id=group_message><label class=required>What are you interested in?</label>
<textarea name=message id=message class=form-control type=text placeholder="Your message here..."></textarea>
<label class=error for=message id=message_error>This field is required.</label></div></div><div class=submit-wrap><input class="btn btn-lets-talk" value="Send Message" type=submit></div></div><div class=confirmation><img src=https://www.ardanlabs.com/images/form-confirm.svg><h2>Message Sent</h2><p>Check your email for confirmation of your sent message. We'll get back to you shortly.</p><button type=button class="btn btn-lets-talk" data-dismiss=modal aria-label=Close>
Finish</button></div></form></div></div></div></div></div><footer><div class=footer-below><div class=container><div class=row><div class=footer-flex><div class=ft-flex-general-link><ul class=footer-ul><div class=blue-line></div><li><a href=/training>Training</a><li><a href=/development>Development</a><li><a href=/devops-consulting>DevOps</a><li><a href=/blockchain>Blockchain</a><li><a class=consulting_click href=/staffing>Staffing</a><li><a href=/ui-ux>UI/UX</a><li><a href=/machine-learning>Machine Learning</a></ul><ul class=footer-ul><div class=blue-line></div><li><a target=_blank href=https://www.ardanlabs.com/education>Education</a><li><a href=/ardan-labs-live/>Live Events</a><li><a target=_blank href=https://ardanlabs.buzzsprout.com/>Podcast</a><li><a target=_blank href=https://www.youtube.com/channel/UCCgGRKeRM1b0LTDqqb4NqjA>YouTube</a><li><a href=/blog>Blog</a><li><a target=_blank href=https://store.ardanlabs.com/>Store</a></ul><ul class=footer-ul><div class=blue-line></div><li><a href=/about>About</a><li><a href=/news>News</a><li><a href=/my/contact-us>Contact</a><li><a href=/careers>Careers</a><li><a href=/my/lab>My Lab</a><li><a href=/terms-service>Terms of Service</a><li><a href=/privacy-policy>Privacy</a></ul></div><div class=ft-flex-reach-us><h6 class=heading7>Reach Us</h6><p><i class="fa fa-phone"></i>(888) 72 ARDAN<br><span>888 722-7326</span><p><a href=mailto:hello@ardanlabs.com><i class="fa fa-envelope"></i>hello@ardanlabs.com</a></div></div></div></div></div></footer><div class=bottom-footer><div class=footer-social-link><a href=https://twitter.com/ardanlabs target=_blank><i class="fa fa-twitter" aria-hidden=true></i>Twitter</a>
<a href=https://github.com/ardanlabs target=_blank><i class="fa fa-github" aria-hidden=true></i>Github</a>
<a href=https://ardanlabs.buzzsprout.com/ target=_blank><i class="fa fa-podcast" aria-hidden=true></i>Podcast</a>
<a href=https://www.youtube.com/channel/UCCgGRKeRM1b0LTDqqb4NqjA target=_blank><i class="fa fa-youtube-play" aria-hidden=true></i>YouTube</a>
<a href=https://www.linkedin.com/company/ardanlabs/ target=_blank><i class="fa fa-linkedin" aria-hidden=true></i>LinkedIn</a>
<a href=https://store.ardanlabs.com/ target=_blank><i class="fa fa-shopping-bag" aria-hidden=true></i></i>Store</a></div><div class=copyright><div class=container><div class=col-md-12><p>Ardan Labs Copyrights &copy; 2022</div></div></div></div><div class=clear-fix></div><script src=https://www.ardanlabs.com/js/bundle.min.c591bc854a48859ebd9ea96ddbac048004e6c9cc09252ae84d2f29b65a9741f5.js></script><script>$(document).ready(function(){$(".dropdown-toggle").dropdown();$('.carousel').carousel({interval:6000});$('#nav').on('affix.bs.affix',function(){if(!$(window).scrollTop())return false;});$("#ultimate-close").click(function(){$("section.ad-widget").addClass("hide-widget");});$("#contact-close").click(function(){$(".contact-widget-inner-corporate").addClass("hide-widget");$(".toggle-icon").addClass("show-toggle-icon");});$(".toggle-icon").click(function(){$(".contact-widget-inner-corporate").removeClass("hide-widget");$(".contact-widget-inner-corporate").addClass("instant-load");$(".toggle-icon").removeClass("show-toggle-icon");});$("#confirm-close").click(function(){$(".contact-widget-inner-corporate").addClass("hide-widget");});});$(document).ready(function(){$('[data-toggle="popover"]').popover({});$('[data-toggle="popover"]').click(function(){setTimeout(function(){$('.popover').fadeOut('slow');},5000);});});$(document).on('click','.navbar-collapse.in',function(e){if($(e.target).is('a')){$(this).collapse('hide');}});$('#myModal').on('hidden.bs.modal',function(){var $this=$(this).find('iframe'),tempSrc=$this.attr('src');$this.attr('src',"");$this.attr('src',tempSrc);});$(document).on('ready',function(){$('.slider-for').slick({slidesToShow:1,slidesToScroll:1,arrows:false,fade:true,draggable:false,asNavFor:'.slider-nav'});$('.slider-nav').slick({slidesToShow:3,slidesToScroll:1,asNavFor:'.slider-for',dots:true,draggable:false,focusOnSelect:true});});$(window).on('resize orientationchange',function(){$('.slider-nav').slick('unslick');$('.slider-nav').slick({slidesToShow:3,slidesToScroll:1,asNavFor:'.slider-for',dots:true,draggable:false,focusOnSelect:true});});</script><script>var rsslinkbtn=document.getElementById('rsslinkbtn');if(rsslinkbtn){var clipboard=new ClipboardJS(rsslinkbtn);clipboard.on('success',function(e){console.log(e);});clipboard.on('error',function(e){console.log(e);});}</script><script>!function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);},s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');twq('init','o26lj');twq('track','PageView');</script><script>_linkedin_partner_id="1254834";window._linkedin_data_partner_ids=window._linkedin_data_partner_ids||[];window._linkedin_data_partner_ids.push(_linkedin_partner_id);</script><script>(function(){var s=document.getElementsByTagName("script")[0];var b=document.createElement("script");b.type="text/javascript";b.async=true;b.src="https://snap.licdn.com/li.lms-analytics/insight.min.js";s.parentNode.insertBefore(b,s);})();</script><noscript><img height=1 width=1 style=display:none alt src="https://px.ads.linkedin.com/collect/?pid=1254834&fmt=gif"></noscript><script>(function(){window.ldfdr=window.ldfdr||{};(function(d,s,ss,fs){fs=d.getElementsByTagName(s)[0];function ce(src){var cs=d.createElement(s);cs.src=src;setTimeout(function(){fs.parentNode.insertBefore(cs,fs)},1);}ce(ss);})(document,'script','https://sc.lfeeder.com/lftracker_v1_ywVkO4XynoeaZ6Bj.js');})();</script><script>!function(f,b,e,v,n,t,s)
{if(f.fbq)return;n=f.fbq=function(){n.callMethod?n.callMethod.apply(n,arguments):n.queue.push(arguments)};if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';n.queue=[];t=b.createElement(e);t.async=!0;t.src=v;s=b.getElementsByTagName(e)[0];s.parentNode.insertBefore(t,s)}(window,document,'script','https://connect.facebook.net/en_US/fbevents.js');fbq('init','3572784256110371');fbq('track','PageView');</script><noscript><img height=1 width=1 src="https://www.facebook.com/tr?id=3572784256110371&ev=PageView&noscript=1"></noscript><script>!function(w,d){if(!w.rdt){var p=w.rdt=function(){p.sendEvent?p.sendEvent.apply(p,arguments):p.callQueue.push(arguments)};p.callQueue=[];var t=d.createElement("script");t.src="https://www.redditstatic.com/ads/pixel.js",t.async=!0;var s=d.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}}(window,document);rdt('init','t2_765ylmxh');rdt('track','PageVisit');</script></body></html>