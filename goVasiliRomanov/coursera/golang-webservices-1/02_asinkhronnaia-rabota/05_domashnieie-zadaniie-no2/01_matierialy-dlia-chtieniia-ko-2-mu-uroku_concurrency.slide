
<!DOCTYPE html>
<html>
  <head>
    <title>Go Concurrency Patterns</title>
    <meta charset='utf-8'>
    <script>
      var notesEnabled =  false ;
    </script>
    <script src='/static/slides.js'></script>

    

    <script>
      
      if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
        var _gaq = _gaq || [];
        _gaq.push(["_setAccount", "UA-11222381-6"]);
        _gaq.push(["b._setAccount", "UA-49880327-6"]);
        window.trackPageview = function() {
          _gaq.push(["_trackPageview", location.pathname+location.hash]);
          _gaq.push(["b._trackPageview", location.pathname+location.hash]);
        };
        window.trackPageview();
        window.trackEvent = function(category, action, opt_label, opt_value, opt_noninteraction) {
          _gaq.push(["_trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
          _gaq.push(["b._trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
        };
      }
    </script>
  </head>

  <body style='display: none'>

    <section class='slides layout-widescreen'>

      <article>
        <h1>Go Concurrency Patterns</h1>
        
        
        
          <div class="presenter">
            
  
  <p>
    Rob Pike
  </p>
  

  
  <p>
    Google
  </p>
  

          </div>
        
      </article>

  
  
      <article >
      
        <h3>Video</h3>
        
  
  <p>
    This talk was presented at Google I/O in June 2012.
  </p>
  
<p class="link"><a href="http://www.youtube.com/watch?v=f6kdp27TYZs" target="_blank">Watch the talk on YouTube</a></p>
      
      <span class="pagenumber">2</span>
      </article>
  
  
  
      <article >
      
        <h2>Introduction</h2>
      
      <span class="pagenumber">3</span>
      </article>
  
  
  
      <article >
      
        <h3>Concurrency features in Go</h3>
        
  
  <p>
    People seemed fascinated by the concurrency features of Go when the language was first announced.
  </p>
  

  
  <p>
    Questions:
  </p>
  

  <ul>
  
    <li>Why is concurrency supported?</li>
  
    <li>What is concurrency, anyway?</li>
  
    <li>Where does the idea come from?</li>
  
    <li>What is it good for?</li>
  
    <li>How do I use it?</li>
  
  </ul>

      
      <span class="pagenumber">4</span>
      </article>
  
  
  
      <article >
      
        <h3>Why?</h3>
        
  
  <p>
    Look around you. What do you see?
  </p>
  

  
  <p>
    Do you see a single-stepping world doing one thing at a time?
  </p>
  

  
  <p>
    Or do you see a complex world of interacting, independently behaving pieces?
  </p>
  

  
  <p>
    That&#39;s why. Sequential processing on its own does not model the world&#39;s behavior.
  </p>
  

      
      <span class="pagenumber">5</span>
      </article>
  
  
  
      <article >
      
        <h3>What is concurrency?</h3>
        
  
  <p>
    Concurrency is the composition of independently executing computations.
  </p>
  

  
  <p>
    Concurrency is a way to structure software, particularly as a way to write clean code that interacts well with the real world.
  </p>
  

  
  <p>
    It is not parallelism.
  </p>
  

      
      <span class="pagenumber">6</span>
      </article>
  
  
  
      <article >
      
        <h3>Concurrency is not parallelism</h3>
        
  
  <p>
    Concurrency is not parallelism, although it enables parallelism.
  </p>
  

  
  <p>
    If you have only one processor, your program can still be concurrent  but it cannot be parallel.
  </p>
  

  
  <p>
    On the other hand, a well-written concurrent program might run efficiently in parallel on a multiprocessor. That property could be important...
  </p>
  

  
  <p>
    For more on that distinction, see the link below. Too much to discuss here.
  </p>
  
<p class="link"><a href="http://golang.org/s/concurrency-is-not-parallelism" target="_blank">golang.org/s/concurrency-is-not-parallelism</a></p>
      
      <span class="pagenumber">7</span>
      </article>
  
  
  
      <article >
      
        <h3>A model for software construction</h3>
        
  
  <p>
    Easy to understand.
  </p>
  

  
  <p>
    Easy to use.
  </p>
  

  
  <p>
    Easy to reason about.
  </p>
  

  
  <p>
    You don&#39;t need to be an expert!
  </p>
  

  
  <p>
    (Much nicer than dealing with the minutiae of parallelism (threads, semaphores, locks, barriers, etc.))
  </p>
  

      
      <span class="pagenumber">8</span>
      </article>
  
  
  
      <article >
      
        <h3>History</h3>
        
  
  <p>
    To many, the concurrency features of Go seemed new.
  </p>
  

  
  <p>
    But they are rooted in a long history, reaching back to Hoare&#39;s CSP in 1978 and even Dijkstra&#39;s guarded commands (1975).
  </p>
  

  
  <p>
    Languages with similar features:
  </p>
  

  <ul>
  
    <li>Occam (May, 1983)</li>
  
    <li>Erlang (Armstrong, 1986)</li>
  
    <li>Newsqueak (Pike, 1988)</li>
  
    <li>Concurrent ML (Reppy, 1993)</li>
  
    <li>Alef (Winterbottom, 1995)</li>
  
    <li>Limbo (Dorward, Pike, Winterbottom, 1996).</li>
  
  </ul>

      
      <span class="pagenumber">9</span>
      </article>
  
  
  
      <article >
      
        <h3>Distinction</h3>
        
  
  <p>
    Go is the latest on the Newsqueak-Alef-Limbo branch, distinguished by first-class channels.
  </p>
  

  
  <p>
    Erlang is closer to the original CSP, where you communicate to a process by name rather than over a channel.
  </p>
  

  
  <p>
    The models are equivalent but express things differently.
  </p>
  

  
  <p>
    Rough analogy: writing to a file by name (process, Erlang) vs. writing to a file descriptor (channel, Go).
  </p>
  

      
      <span class="pagenumber">10</span>
      </article>
  
  
  
      <article >
      
        <h2>Basic Examples</h2>
      
      <span class="pagenumber">11</span>
      </article>
  
  
  
      <article >
      
        <h3>A boring function</h3>
        
  
  <p>
    We need an example to show the interesting properties of the concurrency primitives.
  </p>
  

  
  <p>
    To avoid distraction, we make it a boring example.
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;time&#34;
)

func main() {
	boring(&#34;boring!&#34;)
}

</span></pre><pre><span num="15">func boring(msg string) {</span>
<span num="16">    for i := 0; ; i&#43;&#43; {</span>
<span num="17">        fmt.Println(msg, i)</span>
<span num="18">        time.Sleep(time.Second)</span>
<span num="19">    }</span>
<span num="20">}</span>
</pre>
</div>

      
      <span class="pagenumber">12</span>
      </article>
  
  
  
      <article >
      
        <h3>Slightly less boring</h3>
        
  
  <p>
    Make the intervals between messages unpredictable (still under a second).
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

func main() {
	boring(&#34;boring!&#34;) // HL
}

</span></pre><pre><span num="16">func boring(msg string) {</span>
<span num="17">    for i := 0; ; i&#43;&#43; {</span>
<span num="18">        fmt.Println(msg, i)</span>
<span num="19">        time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)</span>
<span num="20">    }</span>
<span num="21">}</span>
</pre>
</div>

      
      <span class="pagenumber">13</span>
      </article>
  
  
  
      <article >
      
        <h3>Running it</h3>
        
  
  <p>
    The boring function runs on forever, like a boring party guest.
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

</span></pre><pre><span num="11">func main() {</span>
<span num="12">    <b>boring(&#34;boring!&#34;)</b></span>
<span num="13">}</span>
<span num="14"></span>
<span num="16">func boring(msg string) {</span>
<span num="17">    for i := 0; ; i&#43;&#43; {</span>
<span num="18">        fmt.Println(msg, i)</span>
<span num="19">        time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)</span>
<span num="20">    }</span>
<span num="21">}</span>
</pre>
</div>

      
      <span class="pagenumber">14</span>
      </article>
  
  
  
      <article >
      
        <h3>Ignoring it</h3>
        
  
  <p>
    The go statement runs the function as usual, but doesn&#39;t make the caller wait.
  </p>
  

  
  <p>
    It launches a goroutine.
  </p>
  

  
  <p>
    The functionality is analogous to the &amp; on the end of a shell command.
  </p>
  

  <div class="code playground" >
<pre><span num="3">package main</span>
<span num="4"></span>
<span num="5">import (</span>
<span num="6">    &#34;fmt&#34;</span>
<span num="7">    &#34;math/rand&#34;</span>
<span num="8">    &#34;time&#34;</span>
<span num="9">)</span>
<span num="10"></span>
<span num="11">func main() {</span>
<span num="12">    <b>go boring(&#34;boring!&#34;)</b></span>
<span num="13">}</span>
</pre>
<pre style="display: none"><span>// STOP OMIT

func boring(msg string) {
	for i := 0; ; i&#43;&#43; {
		fmt.Println(msg, i)
		time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)
	}
}
</span></pre></div>

      
      <span class="pagenumber">15</span>
      </article>
  
  
  
      <article >
      
        <h3>Ignoring it a little less</h3>
        
  
  <p>
    When main returns, the program exits and takes the boring function down with it.
  </p>
  

  
  <p>
    We can hang around a little, and on the way show that both main and the launched goroutine are running.
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

</span></pre><pre><span num="11">func main() {</span>
<span num="12">    go boring(&#34;boring!&#34;)</span>
<span num="13">    fmt.Println(&#34;I&#39;m listening.&#34;)</span>
<span num="14">    time.Sleep(2 * time.Second)</span>
<span num="15">    fmt.Println(&#34;You&#39;re boring; I&#39;m leaving.&#34;)</span>
<span num="16">}</span>
</pre>
<pre style="display: none"><span>// STOP OMIT

func boring(msg string) {
	for i := 0; ; i&#43;&#43; {
		fmt.Println(msg, i)
		time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)
	}
}
</span></pre></div>

      
      <span class="pagenumber">16</span>
      </article>
  
  
  
      <article >
      
        <h3>Goroutines</h3>
        
  
  <p>
    What is a goroutine? It&#39;s an independently executing function, launched by a go statement.
  </p>
  

  
  <p>
    It has its own call stack, which grows and shrinks as required.
  </p>
  

  
  <p>
    It&#39;s very cheap. It&#39;s practical to have thousands, even hundreds of thousands of goroutines.
  </p>
  

  
  <p>
    It&#39;s not a thread.
  </p>
  

  
  <p>
    There might be only one thread in a program with thousands of goroutines.
  </p>
  

  
  <p>
    Instead, goroutines are multiplexed dynamically onto threads as needed to keep all the goroutines running.
  </p>
  

  
  <p>
    But if you think of it as a very cheap thread, you won&#39;t be far off.
  </p>
  

      
      <span class="pagenumber">17</span>
      </article>
  
  
  
      <article >
      
        <h3>Communication</h3>
        
  
  <p>
    Our boring examples cheated: the main function couldn&#39;t see the output from the other goroutine.
  </p>
  

  
  <p>
    It was just printed to the screen, where we pretended we saw a conversation.
  </p>
  

  
  <p>
    Real conversations require communication.
  </p>
  

      
      <span class="pagenumber">18</span>
      </article>
  
  
  
      <article >
      
        <h3>Channels</h3>
        
  
  <p>
    A channel in Go provides a connection between two goroutines, allowing them to communicate.
  </p>
  

  <div class="code" >
<pre><span num="9">    // Declaring and initializing.</span>
<span num="10">    var c chan int</span>
<span num="11">    c = make(chan int)</span>
<span num="12">    // or</span>
<span num="13">    <b>c := make(chan int)</b></span>
</pre>
</div>

  <div class="code" >
<pre><span num="17">    // Sending on a channel.</span>
<span num="18">    <b>c &lt;- 1</b></span>
</pre>
</div>

  <div class="code" >
<pre><span num="22">    // Receiving from a channel.</span>
<span num="23">    // The &#34;arrow&#34; indicates the direction of data flow.</span>
<span num="24">    <b>value = &lt;-c</b></span>
</pre>
</div>

      
      <span class="pagenumber">19</span>
      </article>
  
  
  
      <article >
      
        <h3>Using channels</h3>
        
  
  <p>
    A channel connects the main and boring goroutines so they can communicate.
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

</span></pre><pre><span num="12">func main() {</span>
<span num="13">    c := make(chan string)</span>
<span num="14">    go boring(&#34;boring!&#34;, c)</span>
<span num="15">    for i := 0; i &lt; 5; i&#43;&#43; {</span>
<span num="16">        <b>fmt.Printf(&#34;You say: %q\n&#34;, &lt;-c) // Receive expression is just a value.</b></span>
<span num="17">    }</span>
<span num="18">    fmt.Println(&#34;You&#39;re boring; I&#39;m leaving.&#34;)</span>
<span num="19">}</span>
</pre>
<pre style="display: none"><span>
// START2 OMIT
func boring(msg string, c chan string) {
	for i := 0; ; i&#43;&#43; {
		c &lt;- fmt.Sprintf(&#34;%s %d&#34;, msg, i) // Expression to be sent can be any suitable value. // HL
		time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)
	}
}
// STOP2 OMIT

</span></pre></div>

  <div class="code" >
<pre><span num="23">func boring(msg string, c chan string) {</span>
<span num="24">    for i := 0; ; i&#43;&#43; {</span>
<span num="25">        <b>c &lt;- fmt.Sprintf(&#34;%s %d&#34;, msg, i) // Expression to be sent can be any suitable value.</b></span>
<span num="26">        time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)</span>
<span num="27">    }</span>
<span num="28">}</span>
</pre>
</div>

      
      <span class="pagenumber">20</span>
      </article>
  
  
  
      <article >
      
        <h3>Synchronization</h3>
        
  
  <p>
    When the main function executes &lt;–c, it will wait for a value to be sent.
  </p>
  

  
  <p>
    Similarly, when the boring function executes c &lt;– value, it waits for a receiver to be ready.
  </p>
  

  
  <p>
    A sender and receiver must both be ready to play their part in the communication. Otherwise we wait until they are.
  </p>
  

  
  <p>
    Thus channels both communicate and synchronize.
  </p>
  

      
      <span class="pagenumber">21</span>
      </article>
  
  
  
      <article >
      
        <h3>An aside about buffered channels</h3>
        
  
  <p>
    Note for experts: Go channels can also be created with a buffer.
  </p>
  

  
  <p>
    Buffering removes synchronization.
  </p>
  

  
  <p>
    Buffering makes them more like Erlang&#39;s mailboxes.
  </p>
  

  
  <p>
    Buffered channels can be important for some problems but they are more subtle to reason about.
  </p>
  

  
  <p>
    We won&#39;t need them today.
  </p>
  

      
      <span class="pagenumber">22</span>
      </article>
  
  
  
      <article >
      
        <h3>The Go approach</h3>
        
  
  <p>
    Don&#39;t communicate by sharing memory, share memory by communicating.
  </p>
  

      
      <span class="pagenumber">23</span>
      </article>
  
  
  
      <article >
      
        <h2>&#34;Patterns&#34;</h2>
      
      <span class="pagenumber">24</span>
      </article>
  
  
  
      <article >
      
        <h3>Generator: function that returns a channel</h3>
        
  
  <p>
    Channels are first-class values, just like strings or integers.
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

func main() {
</span></pre><pre><span num="13">    <b>c := boring(&#34;boring!&#34;) // Function returning a channel.</b></span>
<span num="14">    for i := 0; i &lt; 5; i&#43;&#43; {</span>
<span num="15">        fmt.Printf(&#34;You say: %q\n&#34;, &lt;-c)</span>
<span num="16">    }</span>
<span num="17">    fmt.Println(&#34;You&#39;re boring; I&#39;m leaving.&#34;)</span>
</pre>
<pre style="display: none"><span>}

// START2 OMIT
func boring(msg string) &lt;-chan string { // Returns receive-only channel of strings. // HL
	c := make(chan string)
	go func() { // We launch the goroutine from inside the function. // HL
		for i := 0; ; i&#43;&#43; {
			c &lt;- fmt.Sprintf(&#34;%s %d&#34;, msg, i)
			time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)
		}
	}()
	return c // Return the channel to the caller. // HL
}
// STOP2 OMIT

</span></pre></div>

  <div class="code" >
<pre><span num="22"><b>func boring(msg string) &lt;-chan string { // Returns receive-only channel of strings.</b></span>
<span num="23">    c := make(chan string)</span>
<span num="24">    <b>go func() { // We launch the goroutine from inside the function.</b></span>
<span num="25">        for i := 0; ; i&#43;&#43; {</span>
<span num="26">            c &lt;- fmt.Sprintf(&#34;%s %d&#34;, msg, i)</span>
<span num="27">            time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)</span>
<span num="28">        }</span>
<span num="29">    }()</span>
<span num="30">    <b>return c // Return the channel to the caller.</b></span>
<span num="31">}</span>
</pre>
</div>

      
      <span class="pagenumber">25</span>
      </article>
  
  
  
      <article >
      
        <h3>Channels as a handle on a service</h3>
        
  
  <p>
    Our boring function returns a channel that lets us communicate with the boring service it provides.
  </p>
  

  
  <p>
    We can have more instances of the service.
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

</span></pre><pre><span num="12">func main() {</span>
<span num="13">    <b>joe := boring(&#34;Joe&#34;)</b></span>
<span num="14">    <b>ann := boring(&#34;Ann&#34;)</b></span>
<span num="15">    for i := 0; i &lt; 5; i&#43;&#43; {</span>
<span num="16">        fmt.Println(&lt;-joe)</span>
<span num="17">        fmt.Println(&lt;-ann)</span>
<span num="18">    }</span>
<span num="19">    fmt.Println(&#34;You&#39;re both boring; I&#39;m leaving.&#34;)</span>
<span num="20">}</span>
</pre>
<pre style="display: none"><span>
// START2 OMIT
func boring(msg string) &lt;-chan string { // Returns receive-only channel of strings. // HL
	c := make(chan string)
	go func() { // We launch the goroutine from inside the function. // HL
		for i := 0; ; i&#43;&#43; {
			c &lt;- fmt.Sprintf(&#34;%s: %d&#34;, msg, i)
			time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)
		}
	}()
	return c // Return the channel to the caller. // HL
}
// STOP2 OMIT

</span></pre></div>

      
      <span class="pagenumber">26</span>
      </article>
  
  
  
      <article >
      
        <h3>Multiplexing</h3>
        
  
  <p>
    These programs make Joe and Ann count in lockstep.
<br>

    We can instead use a fan-in function to let whosoever is ready talk.
  </p>
  

  <div class="code" >
<pre><span num="36"><b>func fanIn(input1, input2 &lt;-chan string) &lt;-chan string {</b></span>
<span num="37">    c := make(chan string)</span>
<span num="38">    <b>go func() { for { c &lt;- &lt;-input1 } }()</b></span>
<span num="39">    <b>go func() { for { c &lt;- &lt;-input2 } }()</b></span>
<span num="40">    return c</span>
<span num="41">}</span>
</pre>
</div>

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

</span></pre><pre><span num="12">func main() {</span>
<span num="13">    <b>c := fanIn(boring(&#34;Joe&#34;), boring(&#34;Ann&#34;))</b></span>
<span num="14">    for i := 0; i &lt; 10; i&#43;&#43; {</span>
<span num="15">        <b>fmt.Println(&lt;-c)</b></span>
<span num="16">    }</span>
<span num="17">    fmt.Println(&#34;You&#39;re both boring; I&#39;m leaving.&#34;)</span>
<span num="18">}</span>
</pre>
<pre style="display: none"><span>
// START2 OMIT
func boring(msg string) &lt;-chan string { // Returns receive-only channel of strings. // HL
	c := make(chan string)
	go func() { // We launch the goroutine from inside the function. // HL
		for i := 0; ; i&#43;&#43; {
			c &lt;- fmt.Sprintf(&#34;%s: %d&#34;, msg, i)
			time.Sleep(time.Duration(rand.Intn(2e3)) * time.Millisecond)
		}
	}()
	return c // Return the channel to the caller. // HL
}
// STOP2 OMIT


// START3 OMIT
func fanIn(input1, input2 &lt;-chan string) &lt;-chan string { // HL
	c := make(chan string)
	go func() { for { c &lt;- &lt;-input1 } }() // HL
	go func() { for { c &lt;- &lt;-input2 } }() // HL
	return c
}
// STOP3 OMIT
</span></pre></div>

      
      <span class="pagenumber">27</span>
      </article>
  
  
  
      <article >
      
        <h3>Fan-in</h3>
        
<div class="image">
  <img src="concurrency/images/gophermegaphones.jpg">
</div>

      
      <span class="pagenumber">28</span>
      </article>
  
  
  
      <article >
      
        <h3>Restoring sequencing</h3>
        
  
  <p>
    Send a channel on a channel, making goroutine wait its turn.
  </p>
  

  
  <p>
    Receive all messages, then enable them again by sending on a private channel.
  </p>
  

  
  <p>
    First we define a message type that contains a channel for the reply.
  </p>
  

  <div class="code" >
<pre><span num="12">type Message struct {</span>
<span num="13">    str string</span>
<span num="14">    <b>wait chan bool</b></span>
<span num="15">}</span>
</pre>
</div>

      
      <span class="pagenumber">29</span>
      </article>
  
  
  
      <article >
      
        <h3>Restoring sequencing.</h3>
        
  
  <p>
    Each speaker must wait for a go-ahead.
  </p>
  

  <div class="code" >
<pre><span num="21">    for i := 0; i &lt; 5; i&#43;&#43; {</span>
<span num="22">        msg1 := &lt;-c; fmt.Println(msg1.str)</span>
<span num="23">        msg2 := &lt;-c; fmt.Println(msg2.str)</span>
<span num="24">        msg1.wait &lt;- true</span>
<span num="25">        msg2.wait &lt;- true</span>
<span num="26">    }</span>
</pre>
</div>

  <div class="code" >
<pre><span num="34">    waitForIt := make(chan bool) // Shared between all messages.</span>
</pre>
</div>

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

// START0 OMIT
type Message struct {
	str string
	wait chan bool // HL
}
// STOP0 OMIT

func main() {
	c := fanIn(boring(&#34;Joe&#34;), boring(&#34;Ann&#34;)) // HL
// START1 OMIT
	for i := 0; i &lt; 5; i&#43;&#43; {
		msg1 := &lt;-c; fmt.Println(msg1.str)
		msg2 := &lt;-c; fmt.Println(msg2.str)
		msg1.wait &lt;- true
		msg2.wait &lt;- true
	}
// STOP1 OMIT
	fmt.Println(&#34;You&#39;re all boring; I&#39;m leaving.&#34;)
}

func boring(msg string) &lt;-chan Message { // Returns receive-only channel of strings. // HL
	c := make(chan Message)
// START2 OMIT
	waitForIt := make(chan bool) // Shared between all messages.
// STOP2 OMIT
	go func() { // We launch the goroutine from inside the function. // HL
		for i := 0; ; i&#43;&#43; {
</span></pre><pre><span num="39">            c &lt;- Message{ fmt.Sprintf(&#34;%s: %d&#34;, msg, i), waitForIt }</span>
<span num="40">            time.Sleep(time.Duration(rand.Intn(2e3)) * time.Millisecond)</span>
<span num="41">            &lt;-waitForIt</span>
</pre>
<pre style="display: none"><span>		}
	}()
	return c // Return the channel to the caller. // HL
}


// START3 OMIT
func fanIn(inputs ... &lt;-chan Message) &lt;-chan Message { // HL
	c := make(chan Message)
	for i := range inputs {
		input := inputs[i] // New instance of &#39;input&#39; for each loop.
		go func() { for { c &lt;- &lt;-input } }()
	}
	return c
}
// STOP3 OMIT
</span></pre></div>

      
      <span class="pagenumber">30</span>
      </article>
  
  
  
      <article >
      
        <h3>Select</h3>
        
  
  <p>
    A control structure unique to concurrency.
  </p>
  

  
  <p>
    The reason channels and goroutines are built into the language.
  </p>
  

      
      <span class="pagenumber">31</span>
      </article>
  
  
  
      <article >
      
        <h3>Select</h3>
        
  
  <p>
    The select statement provides another way to handle multiple channels.
<br>

    It&#39;s like a switch, but each case is a communication:
<br>

    - All channels are evaluated.
<br>

    - Selection blocks until one communication can proceed, which then does.
<br>

    - If multiple can proceed, select chooses pseudo-randomly.
<br>

    - A default clause, if present, executes immediately if no channel is ready.
  </p>
  

  <div class="code" >
<pre><span num="8">    select {</span>
<span num="9">    case v1 := &lt;-c1:</span>
<span num="10">        fmt.Printf(&#34;received %v from c1\n&#34;, v1)</span>
<span num="11">    case v2 := &lt;-c2:</span>
<span num="12">        fmt.Printf(&#34;received %v from c2\n&#34;, v1)</span>
<span num="13">    case c3 &lt;- 23:</span>
<span num="14">        fmt.Printf(&#34;sent %v to c3\n&#34;, 23)</span>
<span num="15">    default:</span>
<span num="16">        fmt.Printf(&#34;no one was ready to communicate\n&#34;)</span>
<span num="17">    }</span>
</pre>
</div>

      
      <span class="pagenumber">32</span>
      </article>
  
  
  
      <article >
      
        <h3>Fan-in again</h3>
        
  
  <p>
    Rewrite our original fanIn function. Only one goroutine is needed. Old:
  </p>
  

  <div class="code" >
<pre><span num="36"><b>func fanIn(input1, input2 &lt;-chan string) &lt;-chan string {</b></span>
<span num="37">    c := make(chan string)</span>
<span num="38">    <b>go func() { for { c &lt;- &lt;-input1 } }()</b></span>
<span num="39">    <b>go func() { for { c &lt;- &lt;-input2 } }()</b></span>
<span num="40">    return c</span>
<span num="41">}</span>
</pre>
</div>

      
      <span class="pagenumber">33</span>
      </article>
  
  
  
      <article >
      
        <h3>Fan-in using select</h3>
        
  
  <p>
    Rewrite our original fanIn function. Only one goroutine is needed. New:
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

// START1 OMIT
func main() {
	c := fanIn(boring(&#34;Joe&#34;), boring(&#34;Ann&#34;)) // HL
	for i := 0; i &lt; 10; i&#43;&#43; {
		fmt.Println(&lt;-c) // HL
	}
	fmt.Println(&#34;You&#39;re both boring; I&#39;m leaving.&#34;)
}
// STOP1 OMIT

// START2 OMIT
func boring(msg string) &lt;-chan string { // Returns receive-only channel of strings. // HL
	c := make(chan string)
	go func() { // We launch the goroutine from inside the function. // HL
		for i := 0; ; i&#43;&#43; {
			c &lt;- fmt.Sprintf(&#34;%s: %d&#34;, msg, i)
			time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)
		}
	}()
	return c // Return the channel to the caller. // HL
}
// STOP2 OMIT


</span></pre><pre><span num="36"><b>func fanIn(input1, input2 &lt;-chan string) &lt;-chan string {</b></span>
<span num="37">    c := make(chan string)</span>
<span num="38">    <b>go func() {</b></span>
<span num="39">        for {</span>
<span num="40">            <b>select {</b></span>
<span num="41">            <b>case s := &lt;-input1:  c &lt;- s</b></span>
<span num="42">            <b>case s := &lt;-input2:  c &lt;- s</b></span>
<span num="43">            <b>}</b></span>
<span num="44">        }</span>
<span num="45">    }()</span>
<span num="46">    return c</span>
<span num="47">}</span>
</pre>
</div>

      
      <span class="pagenumber">34</span>
      </article>
  
  
  
      <article >
      
        <h3>Timeout using select</h3>
        
  
  <p>
    The time.After function returns a channel that blocks for the specified duration.
<br>

    After the interval, the channel delivers the current time, once.
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

</span></pre><pre><span num="12">func main() {</span>
<span num="13">    c := boring(&#34;Joe&#34;)</span>
<span num="14">    for {</span>
<span num="15">        select {</span>
<span num="16">        case s := &lt;-c:</span>
<span num="17">            fmt.Println(s)</span>
<span num="18">        <b>case &lt;-time.After(1 * time.Second):</b></span>
<span num="19">            fmt.Println(&#34;You&#39;re too slow.&#34;)</span>
<span num="20">            return</span>
<span num="21">        }</span>
<span num="22">    }</span>
<span num="23">}</span>
</pre>
<pre style="display: none"><span>
// START2 OMIT
func boring(msg string) &lt;-chan string { // Returns receive-only channel of strings. // HL
	c := make(chan string)
	go func() { // We launch the goroutine from inside the function. // HL
		for i := 0; ; i&#43;&#43; {
			c &lt;- fmt.Sprintf(&#34;%s: %d&#34;, msg, i)
			time.Sleep(time.Duration(rand.Intn(1500)) * time.Millisecond)
		}
	}()
	return c // Return the channel to the caller. // HL
}
// STOP2 OMIT


// START3 OMIT
func fanIn(input1, input2 &lt;-chan string) &lt;-chan string { // HL
	c := make(chan string)
	go func() {
		for {
			select {
			case s := &lt;-input1:
				c &lt;- s
			case s := &lt;-input2:
				c &lt;- s
			}
		}
	}()
	return c
}
// STOP3 OMIT
</span></pre></div>

      
      <span class="pagenumber">35</span>
      </article>
  
  
  
      <article >
      
        <h3>Timeout for whole conversation using select</h3>
        
  
  <p>
    Create the timer once, outside the loop, to time out the entire conversation.
<br>

    (In the previous program, we had a timeout for each message.)
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

</span></pre><pre><span num="12">func main() {</span>
<span num="13">    c := boring(&#34;Joe&#34;)</span>
<span num="14">    <b>timeout := time.After(5 * time.Second)</b></span>
<span num="15">    for {</span>
<span num="16">        select {</span>
<span num="17">        case s := &lt;-c:</span>
<span num="18">            fmt.Println(s)</span>
<span num="19">        <b>case &lt;-timeout:</b></span>
<span num="20">            fmt.Println(&#34;You talk too much.&#34;)</span>
<span num="21">            return</span>
<span num="22">        }</span>
<span num="23">    }</span>
<span num="24">}</span>
</pre>
<pre style="display: none"><span>
// START2 OMIT
func boring(msg string) &lt;-chan string { // Returns receive-only channel of strings. // HL
	c := make(chan string)
	go func() { // We launch the goroutine from inside the function. // HL
		for i := 0; ; i&#43;&#43; {
			c &lt;- fmt.Sprintf(&#34;%s: %d&#34;, msg, i)
			time.Sleep(time.Duration(rand.Intn(1500)) * time.Millisecond)
		}
	}()
	return c // Return the channel to the caller. // HL
}
// STOP2 OMIT


// START3 OMIT
func fanIn(input1, input2 &lt;-chan string) &lt;-chan string { // HL
	c := make(chan string)
	go func() {
		for {
			select {
			case s := &lt;-input1:
				c &lt;- s
			case s := &lt;-input2:
				c &lt;- s
			}
		}
	}()
	return c
}
// STOP3 OMIT
</span></pre></div>

      
      <span class="pagenumber">36</span>
      </article>
  
  
  
      <article >
      
        <h3>Quit channel</h3>
        
  
  <p>
    We can turn this around and tell Joe to stop when we&#39;re tired of listening to him.
  </p>
  

  <div class="code" >
<pre><span num="13">    <b>quit := make(chan bool)</b></span>
<span num="14">    c := boring(&#34;Joe&#34;, quit)</span>
<span num="15">    for i := rand.Intn(10); i &gt;= 0; i-- { fmt.Println(&lt;-c) }</span>
<span num="16">    <b>quit &lt;- true</b></span>
</pre>
</div>

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

func main() {
// START1 OMIT
	quit := make(chan bool) // HL
	c := boring(&#34;Joe&#34;, quit)
	for i := rand.Intn(10); i &gt;= 0; i-- { fmt.Println(&lt;-c) }
	quit &lt;- true // HL
// STOP1 OMIT
}

func boring(msg string, quit &lt;-chan bool) &lt;-chan string {
	c := make(chan string)
	go func() { // HL
		for i := 0; ; i&#43;&#43; {
			time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)
</span></pre><pre><span num="26">            select {</span>
<span num="27">            case c &lt;- fmt.Sprintf(&#34;%s: %d&#34;, msg, i):</span>
<span num="28">                // do nothing</span>
<span num="29">            <b>case &lt;-quit:</b></span>
<span num="30">                return</span>
<span num="31">            }</span>
</pre>
<pre style="display: none"><span>		}
	}()
	return c
}
</span></pre></div>

      
      <span class="pagenumber">37</span>
      </article>
  
  
  
      <article >
      
        <h3>Receive on quit channel</h3>
        
  
  <p>
    How do we know it&#39;s finished? Wait for it to tell us it&#39;s done: receive on the quit channel
  </p>
  

  <div class="code" >
<pre><span num="16">    <b>quit := make(chan string)</b></span>
<span num="17">    <b>c := boring(&#34;Joe&#34;, quit)</b></span>
<span num="18">    for i := rand.Intn(10); i &gt;= 0; i-- { fmt.Println(&lt;-c) }</span>
<span num="19">    <b>quit &lt;- &#34;Bye!&#34;</b></span>
<span num="20">    <b>fmt.Printf(&#34;Joe says: %q\n&#34;, &lt;-quit)</b></span>
</pre>
</div>

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

func cleanup() {
}

func main() {
// START1 OMIT
	quit := make(chan string) // HL
	c := boring(&#34;Joe&#34;, quit) // HL
	for i := rand.Intn(10); i &gt;= 0; i-- { fmt.Println(&lt;-c) }
	quit &lt;- &#34;Bye!&#34; // HL
	fmt.Printf(&#34;Joe says: %q\n&#34;, &lt;-quit) // HL
// STOP1 OMIT
}

func boring(msg string, quit chan string) &lt;-chan string {
	c := make(chan string) // HL
	go func() {
		for i := 0; ; i&#43;&#43; {
			time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)
</span></pre><pre><span num="30">            select {</span>
<span num="31">            case c &lt;- fmt.Sprintf(&#34;%s: %d&#34;, msg, i):</span>
<span num="32">                // do nothing</span>
<span num="33">            <b>case &lt;-quit:</b></span>
<span num="34">                cleanup()</span>
<span num="35">                <b>quit &lt;- &#34;See you!&#34;</b></span>
<span num="36">                return</span>
<span num="37">            }</span>
</pre>
<pre style="display: none"><span>		}
	}()
	return c
}
</span></pre></div>

      
      <span class="pagenumber">38</span>
      </article>
  
  
  
      <article >
      
        <h3>Daisy-chain</h3>
        
  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import &#34;fmt&#34;

</span></pre><pre><span num="7">func f(left, right chan int) {</span>
<span num="8">    left &lt;- 1 &#43; &lt;-right</span>
<span num="9">}</span>
<span num="10"></span>
<span num="11">func main() {</span>
<span num="12">    const n = 10000</span>
<span num="13">    leftmost := make(chan int)</span>
<span num="14">    right := leftmost</span>
<span num="15">    left := leftmost</span>
<span num="16">    for i := 0; i &lt; n; i&#43;&#43; {</span>
<span num="17">        right = make(chan int)</span>
<span num="18">        go f(left, right)</span>
<span num="19">        left = right</span>
<span num="20">    }</span>
<span num="21">    go func(c chan int) { c &lt;- 1 }(right)</span>
<span num="22">    fmt.Println(&lt;-leftmost)</span>
<span num="23">}</span>
</pre>
</div>

      
      <span class="pagenumber">39</span>
      </article>
  
  
  
      <article >
      
        <h3>Chinese whispers, gopher style</h3>
        
<div class="image">
  <img src="concurrency/images/gophereartrumpet.jpg">
</div>

      
      <span class="pagenumber">40</span>
      </article>
  
  
  
      <article >
      
        <h3>Systems software</h3>
        
  
  <p>
    Go was designed for writing systems software.
<br>

    Let&#39;s see how the concurrency features come into play.
  </p>
  

      
      <span class="pagenumber">41</span>
      </article>
  
  
  
      <article >
      
        <h3>Example: Google Search</h3>
        
  
  <p>
    Q: What does Google search do?
  </p>
  

  
  <p>
    A: Given a query, return a page of search results (and some ads).
  </p>
  

  
  <p>
    Q: How do we get the search results?
  </p>
  

  
  <p>
    A: Send the query to Web search, Image search, YouTube, Maps, News,etc., then mix the results.
  </p>
  

  
  <p>
    How do we implement this?
  </p>
  

      
      <span class="pagenumber">42</span>
      </article>
  
  
  
      <article >
      
        <h3>Google Search: A fake framework</h3>
        
  
  <p>
    We can simulate the search function, much as we simulated conversation before.
  </p>
  

  <div class="code" >
<pre><span num="24">var (</span>
<span num="25">    Web = fakeSearch(&#34;web&#34;)</span>
<span num="26">    Image = fakeSearch(&#34;image&#34;)</span>
<span num="27">    Video = fakeSearch(&#34;video&#34;)</span>
<span num="28">)</span>
<span num="29"></span>
<span num="30"><b>type Search func(query string) Result</b></span>
<span num="31"></span>
<span num="32">func fakeSearch(kind string) Search {</span>
<span num="33">        return func(query string) Result {</span>
<span num="34">              time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)</span>
<span num="35">              return Result(fmt.Sprintf(&#34;%s result for %q\n&#34;, kind, query))</span>
<span num="36">        }</span>
<span num="37">}</span>
</pre>
</div>

      
      <span class="pagenumber">43</span>
      </article>
  
  
  
      <article >
      
        <h3>Google Search: Test the framework</h3>
        
  <div class="code playground" >
<pre style="display: none"><span>
// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

type Result string

// START1 OMIT
func Google(query string) (results []Result) {
	results = append(results, Web(query))
	results = append(results, Image(query))
	results = append(results, Video(query))
	return
}
// STOP1 OMIT

// START2 OMIT
var (
	Web = fakeSearch(&#34;web&#34;)
	Image = fakeSearch(&#34;image&#34;)
	Video = fakeSearch(&#34;video&#34;)
)

type Search func(query string) Result // HL

func fakeSearch(kind string) Search {
        return func(query string) Result {
	          time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
	          return Result(fmt.Sprintf(&#34;%s result for %q\n&#34;, kind, query))
        }
}
// STOP2 OMIT

</span></pre><pre><span num="40">func main() {</span>
<span num="41">    rand.Seed(time.Now().UnixNano())</span>
<span num="42">    start := time.Now()</span>
<span num="43">    <b>results := Google(&#34;golang&#34;)</b></span>
<span num="44">    elapsed := time.Since(start)</span>
<span num="45">    fmt.Println(results)</span>
<span num="46">    fmt.Println(elapsed)</span>
<span num="47">}</span>
</pre>
</div>

      
      <span class="pagenumber">44</span>
      </article>
  
  
  
      <article >
      
        <h3>Google Search 1.0</h3>
        
  
  <p>
    The Google function takes a query and returns a slice of Results (which are just strings).
  </p>
  

  
  <p>
    Google invokes Web, Image, and Video searches serially, appending them to the results slice.
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>
// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

type Result string

</span></pre><pre><span num="15">func Google(query string) (results []Result) {</span>
<span num="16">    results = append(results, Web(query))</span>
<span num="17">    results = append(results, Image(query))</span>
<span num="18">    results = append(results, Video(query))</span>
<span num="19">    return</span>
<span num="20">}</span>
</pre>
<pre style="display: none"><span>
// START2 OMIT
var (
	Web = fakeSearch(&#34;web&#34;)
	Image = fakeSearch(&#34;image&#34;)
	Video = fakeSearch(&#34;video&#34;)
)

type Search func(query string) Result // HL

func fakeSearch(kind string) Search {
        return func(query string) Result {
	          time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
	          return Result(fmt.Sprintf(&#34;%s result for %q\n&#34;, kind, query))
        }
}
// STOP2 OMIT

func main() {
	rand.Seed(time.Now().UnixNano())
	start := time.Now()
	results := Google(&#34;golang&#34;) // HL
	elapsed := time.Since(start)
	fmt.Println(results)
	fmt.Println(elapsed)
}
</span></pre></div>

      
      <span class="pagenumber">45</span>
      </article>
  
  
  
      <article >
      
        <h3>Google Search 2.0</h3>
        
  
  <p>
    Run the Web, Image, and Video searches concurrently, and wait for all results.
  </p>
  

  
  <p>
    No locks.  No condition variables.  No callbacks.
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

type Result string
type Search func(query string) Result

var (
	Web = fakeSearch(&#34;web&#34;)
	Image = fakeSearch(&#34;image&#34;)
	Video = fakeSearch(&#34;video&#34;)
)


</span></pre><pre><span num="21">func Google(query string) (results []Result) {</span>
<span num="22">    c := make(chan Result)</span>
<span num="23">    go func() { c &lt;- Web(query) } ()</span>
<span num="24">    go func() { c &lt;- Image(query) } ()</span>
<span num="25">    go func() { c &lt;- Video(query) } ()</span>
<span num="26"></span>
<span num="27">    for i := 0; i &lt; 3; i&#43;&#43; {</span>
<span num="28">        result := &lt;-c</span>
<span num="29">        results = append(results, result)</span>
<span num="30">    }</span>
<span num="31">    return</span>
<span num="32">}</span>
</pre>
<pre style="display: none"><span>
func fakeSearch(kind string) Search {
        return func(query string) Result {
	          time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
	          return Result(fmt.Sprintf(&#34;%s result for %q\n&#34;, kind, query))
        }
}

func main() {
	rand.Seed(time.Now().UnixNano())
	start := time.Now()
	results := Google(&#34;golang&#34;)
	elapsed := time.Since(start)
	fmt.Println(results)
	fmt.Println(elapsed)
}


</span></pre></div>

      
      <span class="pagenumber">46</span>
      </article>
  
  
  
      <article >
      
        <h3>Google Search 2.1</h3>
        
  
  <p>
    Don&#39;t wait for slow servers. No locks.  No condition variables.  No callbacks.
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

type Result string
type Search func(query string) Result

var (
	Web = fakeSearch(&#34;web&#34;)
	Image = fakeSearch(&#34;image&#34;)
	Video = fakeSearch(&#34;video&#34;)
)

func Google(query string) (results []Result) {
</span></pre><pre><span num="22">    c := make(chan Result)</span>
<span num="23">    go func() { c &lt;- Web(query) } ()</span>
<span num="24">    go func() { c &lt;- Image(query) } ()</span>
<span num="25">    go func() { c &lt;- Video(query) } ()</span>
<span num="26"></span>
<span num="27">    timeout := time.After(80 * time.Millisecond)</span>
<span num="28">    for i := 0; i &lt; 3; i&#43;&#43; {</span>
<span num="29">        select {</span>
<span num="30">        case result := &lt;-c:</span>
<span num="31">            results = append(results, result)</span>
<span num="32">        case &lt;-timeout:</span>
<span num="33">            fmt.Println(&#34;timed out&#34;)</span>
<span num="34">            return</span>
<span num="35">        }</span>
<span num="36">    }</span>
<span num="37">    return</span>
</pre>
<pre style="display: none"><span>}

func fakeSearch(kind string) Search {
        return func(query string) Result {
	          time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
	          return Result(fmt.Sprintf(&#34;%s result for %q\n&#34;, kind, query))
        }
}

func main() {
	rand.Seed(time.Now().UnixNano())
	start := time.Now()
	results := Google(&#34;golang&#34;)
	elapsed := time.Since(start)
	fmt.Println(results)
	fmt.Println(elapsed)
}

</span></pre></div>

      
      <span class="pagenumber">47</span>
      </article>
  
  
  
      <article >
      
        <h3>Avoid timeout</h3>
        
  
  <p>
    Q: How do we avoid discarding results from slow servers?
  </p>
  

  
  <p>
    A: Replicate the servers.  Send requests to multiple replicas, and use the first response.
  </p>
  

  <div class="code" >
<pre><span num="15">func First(query string, replicas ...Search) Result {</span>
<span num="16">    c := make(chan Result)</span>
<span num="17">    searchReplica := func(i int) { c &lt;- replicas[i](query) }</span>
<span num="18">    for i := range replicas {</span>
<span num="19">        go searchReplica(i)</span>
<span num="20">    }</span>
<span num="21">    return &lt;-c</span>
<span num="22">}</span>
</pre>
</div>

      
      <span class="pagenumber">48</span>
      </article>
  
  
  
      <article >
      
        <h3>Using the First function</h3>
        
  <div class="code playground" >
<pre style="display: none"><span>// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

type Result string
type Search func(query string) Result

// START1 OMIT
func First(query string, replicas ...Search) Result {
	c := make(chan Result)
	searchReplica := func(i int) { c &lt;- replicas[i](query) }
	for i := range replicas {
		go searchReplica(i)
	}
	return &lt;-c
}
// STOP1 OMIT

</span></pre><pre><span num="26">func main() {</span>
<span num="27">    rand.Seed(time.Now().UnixNano())</span>
<span num="28">    start := time.Now()</span>
<span num="29">    result := First(&#34;golang&#34;,</span>
<span num="30">        fakeSearch(&#34;replica 1&#34;),</span>
<span num="31">        fakeSearch(&#34;replica 2&#34;))</span>
<span num="32">    elapsed := time.Since(start)</span>
<span num="33">    fmt.Println(result)</span>
<span num="34">    fmt.Println(elapsed)</span>
<span num="35">}</span>
</pre>
<pre style="display: none"><span>
func fakeSearch(kind string) Search {
        return func(query string) Result {
	          time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
	          return Result(fmt.Sprintf(&#34;%s result for %q\n&#34;, kind, query))
        }
}

</span></pre></div>

      
      <span class="pagenumber">49</span>
      </article>
  
  
  
      <article >
      
        <h3>Google Search 3.0</h3>
        
  
  <p>
    Reduce tail latency using replicated search servers.
  </p>
  

  <div class="code playground" >
<pre style="display: none"><span>

// &#43;build ignore,OMIT

package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;time&#34;
)

type Result string
type Search func(query string) Result

var (
	Web1 = fakeSearch(&#34;web1&#34;)
        Web2 = fakeSearch(&#34;web2&#34;)
	Image1 = fakeSearch(&#34;image1&#34;)
	Image2 = fakeSearch(&#34;image2&#34;)
	Video1 = fakeSearch(&#34;video1&#34;)
	Video2 = fakeSearch(&#34;video2&#34;)
)

func Google(query string) (results []Result) {
</span></pre><pre><span num="27">    c := make(chan Result)</span>
<span num="28">    go func() { c &lt;- First(query, Web1, Web2) } ()</span>
<span num="29">    go func() { c &lt;- First(query, Image1, Image2) } ()</span>
<span num="30">    go func() { c &lt;- First(query, Video1, Video2) } ()</span>
<span num="31">    timeout := time.After(80 * time.Millisecond)</span>
<span num="32">    for i := 0; i &lt; 3; i&#43;&#43; {</span>
<span num="33">        select {</span>
<span num="34">        case result := &lt;-c:</span>
<span num="35">            results = append(results, result)</span>
<span num="36">        case &lt;-timeout:</span>
<span num="37">            fmt.Println(&#34;timed out&#34;)</span>
<span num="38">            return</span>
<span num="39">        }</span>
<span num="40">    }</span>
<span num="41">    return</span>
</pre>
<pre style="display: none"><span>}

func First(query string, replicas ...Search) Result {
	c := make(chan Result)
	searchReplica := func(i int) {
		c &lt;- replicas[i](query)
	}
	for i := range replicas {
		go searchReplica(i)
	}
        return &lt;-c
}

func fakeSearch(kind string) Search {
        return func(query string) Result {
	          time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
	          return Result(fmt.Sprintf(&#34;%s result for %q\n&#34;, kind, query))
        }
}

func main() {
	rand.Seed(time.Now().UnixNano())
	start := time.Now()
	results := Google(&#34;golang&#34;)
	elapsed := time.Since(start)
	fmt.Println(results)
	fmt.Println(elapsed)
}
</span></pre></div>

      
      <span class="pagenumber">50</span>
      </article>
  
  
  
      <article >
      
        <h3>And still…</h3>
        
  
  <p>
    No locks.  No condition variables.  No callbacks.
  </p>
  

      
      <span class="pagenumber">51</span>
      </article>
  
  
  
      <article >
      
        <h3>Summary</h3>
        
  
  <p>
    In just a few simple transformations we used Go&#39;s concurrency primitives to convert a
  </p>
  

  <ul>
  
    <li>slow</li>
  
    <li>sequential</li>
  
    <li>failure-sensitive</li>
  
  </ul>

  
  <p>
    program into one that is
  </p>
  

  <ul>
  
    <li>fast</li>
  
    <li>concurrent</li>
  
    <li>replicated</li>
  
    <li>robust.</li>
  
  </ul>

      
      <span class="pagenumber">52</span>
      </article>
  
  
  
      <article >
      
        <h3>More party tricks</h3>
        
  
  <p>
    There are endless ways to use these tools, many presented elsewhere.
  </p>
  

  
  <p>
    Chatroulette toy:
  </p>
  
<p class="link"><a href="http://golang.org/s/chat-roulette" target="_blank">golang.org/s/chat-roulette</a></p>
  
  <p>
    Load balancer:
  </p>
  
<p class="link"><a href="http://golang.org/s/load-balancer" target="_blank">golang.org/s/load-balancer</a></p>
  
  <p>
    Concurrent prime sieve:
  </p>
  
<p class="link"><a href="http://golang.org/s/prime-sieve" target="_blank">golang.org/s/prime-sieve</a></p>
  
  <p>
    Concurrent power series (by McIlroy):
  </p>
  
<p class="link"><a href="http://golang.org/s/power-series" target="_blank">golang.org/s/power-series</a></p>
      
      <span class="pagenumber">53</span>
      </article>
  
  
  
      <article >
      
        <h3>Don&#39;t overdo it</h3>
        
  
  <p>
    They&#39;re fun to play with, but don&#39;t overuse these ideas.
  </p>
  

  
  <p>
    Goroutines and channels are big ideas. They&#39;re tools for program construction.
  </p>
  

  
  <p>
    But sometimes all you need is a reference counter.
  </p>
  

  
  <p>
    Go has &#34;sync&#34; and &#34;sync/atomic&#34; packages that provide mutexes, condition variables, etc. They provide tools for smaller problems.
  </p>
  

  
  <p>
    Often, these things will work together to solve a bigger problem.
  </p>
  

  
  <p>
    Always use the right tool for the job.
  </p>
  

      
      <span class="pagenumber">54</span>
      </article>
  
  
  
      <article >
      
        <h3>Conclusions</h3>
        
  
  <p>
    Goroutines and channels make it easy to express complex operations dealing with
  </p>
  

  <ul>
  
    <li>multiple inputs</li>
  
    <li>multiple outputs</li>
  
    <li>timeouts</li>
  
    <li>failure</li>
  
  </ul>

  
  <p>
    And they&#39;re fun to use.
  </p>
  

      
      <span class="pagenumber">55</span>
      </article>
  
  
  
      <article >
      
        <h3>Links</h3>
        
  
  <p>
    Go Home Page:
  </p>
  
<p class="link"><a href="http://golang.org" target="_blank">golang.org</a></p>
  
  <p>
    Go Tour (learn Go in your browser)
  </p>
  
<p class="link"><a href="http://tour.golang.org" target="_blank">tour.golang.org</a></p>
  
  <p>
    Package documentation:
  </p>
  
<p class="link"><a href="http://golang.org/pkg" target="_blank">golang.org/pkg</a></p>
  
  <p>
    Articles galore:
  </p>
  
<p class="link"><a href="http://golang.org/doc" target="_blank">golang.org/doc</a></p>
  
  <p>
    Concurrency is not parallelism:
  </p>
  
<p class="link"><a href="http://golang.org/s/concurrency-is-not-parallelism" target="_blank">golang.org/s/concurrency-is-not-parallelism</a></p>
      
      <span class="pagenumber">56</span>
      </article>
  
  

      <article>
        <h3>Thank you</h3>
        
          <div class="presenter">
            
  
  <p>
    Rob Pike
  </p>
  

  
  <p>
    Google
  </p>
  
<p class="link"><a href="http://golang.org/s/plusrob" target="_blank">http://golang.org/s/plusrob</a></p><p class="link"><a href="http://twitter.com/rob_pike" target="_blank">@rob_pike</a></p><p class="link"><a href="http://golang.org" target="_blank">http://golang.org</a></p>
          </div>
        
      </article>

    </section>

    <div id="help">
      Use the left and right arrow keys or click the left and right
      edges of the page to navigate between slides.<br>
      (Press 'H' or navigate to hide this message.)
    </div>

    
    <script src='/play.js'></script>
    

    <script>
      (function() {
        
        if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
          var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
          ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
          var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
        }
      })();
    </script>
  </body>
</html>
