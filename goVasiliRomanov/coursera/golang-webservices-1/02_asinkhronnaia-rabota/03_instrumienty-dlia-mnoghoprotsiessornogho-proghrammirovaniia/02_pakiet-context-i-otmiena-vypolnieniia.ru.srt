1
00:00:00,000 --> 00:00:06,724
[БЕЗ_ЗВУКА] В

2
00:00:06,724 --> 00:00:12,008
этом видео мы поговорим про пакет Context,
одна из областей которого

3
00:00:12,008 --> 00:00:17,622
является как раз отмена такого
рода асинхронных операций.

4
00:00:17,622 --> 00:00:20,450
Давайте посмотрим пример.

5
00:00:20,450 --> 00:00:20,988
Итак.

6
00:00:20,988 --> 00:00:26,020
Допустим, мы отправляем запросы
на несколько разных серверов,

7
00:00:26,020 --> 00:00:31,460
при этом нам нужен только первый из них,
и всех остальных мы не ждём.

8
00:00:31,460 --> 00:00:36,949
Можно, конечно, попробовать реализовать

9
00:00:36,949 --> 00:00:41,445
ожидания через какой-то
канал или ещё что-то,

10
00:00:41,445 --> 00:00:44,970
но обычно это делается
через как раз Context.

11
00:00:44,970 --> 00:00:46,492
Начнём создание.

12
00:00:46,492 --> 00:00:52,970
Итак, мы создаём контекст; контекст,
который имеет просто функцию отмены.

13
00:00:52,970 --> 00:00:56,832
Нам возвращается сам контекст
и функция отмены finish.

14
00:00:56,832 --> 00:01:00,380
ContextBackground — это
такой базовый контекст,

15
00:01:00,380 --> 00:01:03,724
от которого обычно всё наследуется.

16
00:01:03,724 --> 00:01:11,808
После этого мы запускаем десять воркеров;
первым параметром мы им передаём контекст.

17
00:01:11,808 --> 00:01:15,662
Контекст всегда передаётся первым
парметром практически во все функции,

18
00:01:15,662 --> 00:01:20,473
и вы тоже будете это делать,
потому что он содержит не только отмену,

19
00:01:20,473 --> 00:01:26,104
но и ещё кое-какие другие данные,
про которые мы поговорим в другом видео.

20
00:01:26,104 --> 00:01:27,218
Но вернёмся к отмене.

21
00:01:27,218 --> 00:01:31,730
Итак, мы запускаем воркер в отдельной
горутине, куда передаём контекст,

22
00:01:31,730 --> 00:01:34,130
номер воркера и канал с результатом.

23
00:01:34,130 --> 00:01:39,770
После этого мы дожидаемся
первого результата,

24
00:01:39,770 --> 00:01:42,700
выводим его на экран и
вызываем функцию finish.

25
00:01:42,700 --> 00:01:47,973
Finish даёт сигнал, что всё,
дальше продолжать не надо.

26
00:01:47,973 --> 00:01:51,240
Теперь, каким образом
обрабатывается finish,

27
00:01:51,240 --> 00:01:54,764
каким образом обрабатывается этот сигнал?

28
00:01:54,764 --> 00:01:59,362
Сигнал обрабатывается
посредством чтения канала,

29
00:01:59,362 --> 00:02:07,490
который возвращает нам функция «метод
контекста done», то есть ctx.Done.

30
00:02:07,490 --> 00:02:12,519
Это безопасно использовать
между несколькими горутинами.

31
00:02:12,519 --> 00:02:20,005
Давайте посмотрим на наш воркер; итак, мы
эмулируем работу просто каким-то sleep'ом,

32
00:02:20,005 --> 00:02:24,170
пишем, что такой-то воркер
будет спать столько-то.

33
00:02:24,170 --> 00:02:27,558
Как только подошло время этого воркера,

34
00:02:27,558 --> 00:02:33,065
мы запишем результат в канал и скажем,
что воркер отработал.

35
00:02:33,065 --> 00:02:39,070
Если вдруг нам пришёл сигнал, что нужно
закругляться, мы просто выйдем из функции.

36
00:02:39,070 --> 00:02:44,950
Итак, давайте это запустим и посмотрим,
как оно работает.

37
00:02:44,950 --> 00:02:46,117
Отлично.

38
00:02:46,117 --> 00:02:50,140
У нас запустилось десять воркеров.

39
00:02:50,140 --> 00:02:54,863
Меньше всего ждал девятый — всего
десять миллисекунд, вот он.

40
00:02:54,863 --> 00:02:58,430
Он отработал первым,
записал результат в канал,

41
00:02:58,430 --> 00:03:03,628
мы прочитали этот результат
— result found by 9 —

42
00:03:03,628 --> 00:03:09,160
и отмели всю последующую работу,
то есть вызвали функцию finish.

43
00:03:09,160 --> 00:03:12,540
Так.

44
00:03:12,540 --> 00:03:17,870
Теперь рассмотрим немножко другой пример,

45
00:03:17,870 --> 00:03:22,673
когда нам надо не вручную
завершить выполнение

46
00:03:22,673 --> 00:03:26,449
контекста, а по какому-то таймауту.

47
00:03:26,449 --> 00:03:32,305
В этом случае мы можем вызвать
функцию у пакета Context WithTimeout,

48
00:03:32,305 --> 00:03:37,626
которая также вернёт нам функцию finish,
— но я не буду ей пользоваться здесь,

49
00:03:37,626 --> 00:03:41,260
поэтому я её пропускаю,
— и просто сам контекст.

50
00:03:41,260 --> 00:03:45,090
Время ожидания будет 50 миллисекунд.

51
00:03:45,090 --> 00:03:48,930
После идёт фактически то же самое.

52
00:03:48,930 --> 00:03:51,980
А теперь на функцию «работа».

53
00:03:51,980 --> 00:03:59,215
Я буду либо ожидать окончания
контекста вот здесь и прерву цикл,

54
00:03:59,215 --> 00:04:04,635
либо я буду читать из
каналов результат и просто

55
00:04:04,635 --> 00:04:10,810
писать его на экран и запоминать,
сколько мне пришло результатов.

56
00:04:10,810 --> 00:04:11,866
Ну и всё.

57
00:04:11,866 --> 00:04:16,750
А функция воркера уже ничем не отличается.

58
00:04:16,750 --> 00:04:21,124
Он по-прежнему спит, он по-прежнему
обрабатывает ctx.Done для того,

59
00:04:21,124 --> 00:04:22,980
чтобы завершить свою функцию,

60
00:04:22,980 --> 00:04:28,800
либо пишет результат в канал через
определённый промежуток времени.

61
00:04:28,800 --> 00:04:36,800
Давайте это запустим.

62
00:04:36,800 --> 00:04:38,354
Итак.

63
00:04:38,354 --> 00:04:45,496
Вот наши воркеры,
они спят определённое время.

64
00:04:45,496 --> 00:04:49,750
За это время успели отработать воркеры 2,
7 и 8.

65
00:04:49,750 --> 00:04:57,065
Они записали свой номер в канал,
я его прочитал и вывел на экран,

66
00:04:57,065 --> 00:05:02,081
что мне пришло за этот промежуток
времени всего три результата.

67
00:05:02,081 --> 00:05:05,528
Поскольку я сплю случайное время,
то при следующем запуске

68
00:05:05,528 --> 00:05:08,580
программы результат у меня
получится немножко другой.

69
00:05:08,580 --> 00:05:16,144
Context очень широко используется в Go, вы
будете его видеть практически повсеместно,

70
00:05:16,144 --> 00:05:21,220
и одно из его основных назначений
— это отмена выполнения операции.

71
00:05:21,220 --> 00:05:26,437
Поэтому если вам нужно отменить
какую-то асинхронную операцию,

72
00:05:26,437 --> 00:05:29,190
то Context — это как раз ваш выбор.