[БЕЗ_ЗВУКА] А теперь
рассмотрим пул воркеров. Довольно часто в архитектуре
встречаются случаи, когда работа осуществляется
через какие-то очереди, с которыми работают какие-то
офлайновые уже «разгребаторы». Вот. Часто для этих целей есть
«форкающиеся демоны», но в Go можно поступить гораздо проще. Мы можем создать сразу
просто несколько горутин, которые будут читать из какого-то канала. И если нам приходит какая-то задача,
мы просто будем писать ее в этот канал. А там воркеры уже дальше сами разберутся. Давайте посмотрим это в работе. Вот смотрите: вы видите результат. У нас есть три воркера,
которые просто выводят что-то на экран. Я также показал номер
горутины и ту задачу, которую они получили; в данном
случае это просто времена месяцев. Как это работает внутри? Смотрите. Для начала мы просто имеем
какое-то количество горутин, и мы, используя в запуск горутины
функцию go, просто запускаем воркер, просто запускаем функцию. Внутри этой функции она просто
начинает читать из канала, и всё. Вот и вся работа. При этом если вдруг нам нужно
завершить этот пул воркеров, например, он отработал свою задачу,
то мы можем просто закрыть этот канал, и тогда цикл, в котором крутится
внутри воркер, закончится. При этом если вдруг не закрыть этот канал, то давайте посмотрим, что произойдет. Мы не дождались окончания работы воркера. Смотрите: после того как воркер
заканчивает свою работу, он пишет нам какой-то текст. Вот, например: «Я номер такой-то,
я закончил». В данном случае мы этого текста не видим. Что произошло? Произошло то, что наша программа, наша
функция main, она завершила свою работу, при этом она не стала ждать
каких-то других горутин, и поэтому воркер не завершился корректно. В каких-то других случаях это может
привести к утечкам горутин либо же к дедлоку. Будьте осторожны. Это был пул воркеров.