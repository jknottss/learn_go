[БЕЗ_ЗВУКА] В этом видео мы рассмотрим организацию
таймаутов и еще некоторых операций, когда нам нужно выполнить что-то
через небольшой промежуток времени. Начнем мы с таймаутов. Бывает, что нам нужно ждать операцию
фиксированное количество времени, то есть мы не можем ожидать бесконечно,
пользователь не будет ждать несколько часов, пока мы там что-то посчитаем,
и уйдет; поэтому нужны таймауты. Рассмотрим этот пример. Итак, для начала мы можем объявить timer, который находится в пакете time. У таймера есть канал,
и в случае если мы будем использовать мультиплексор select,
то мы можем поставить на чтение с этого канала,
и как только наступит нужное время, там появится событие, и он сработает. У NewTimer есть короткое объявление, когда нам сразу же возвращается канал без
промежуточной переменной, time.After. Но у них есть небольшие особенности. Мы можем остановить timer от выполнения, а time.After мы остановить не можем,
и пока он не выполнится, даже если мы завершили функцию,
он не освободит ресурсы. Поэтому если вам нужно лучше
контролировать расход ресурсов, расход памяти, пользуйтесь простым
таймером и останавливайте его, когда вам это требуется. Давайте запустим нашу программу. Отлично! Случился таймаут,
который мы указывали в таймере вот здесь. А если мы поменяем время на тройку,
например, то сработает наша какая-то длинная операция. Это организация таймаута
на какую-то операцию, делается она через мультиплексор select. Теперь рассмотрим какие-то
периодические события. Переодические события — это значит,
что с определенным интервалом времени вам приходят события,
и вы что-то делаете в это время. Делается это через конструкцию ticker, она тоже находится в пакете time,
ее можно создать через NewTicker. Если вы читаете из канала,
который предоставляет ticker, то вам возвращается время,
когда было срабатывание. Поэтому вы можете использовать это время, если вам нужно зафиксировать,
в какой момент было произведено событие. Давайте посмотрим на этот пример. Тут я жду всего лишь пять секунд и
после этого останавливаю ticker, чтобы он больше не посылал мне время,
не посылал мне тики, и завершаю. Итак, один, два, три, четыре, пять. Все, на пятом тике мы ticker
завершили и вышли из цикла. Опять-таки у тикера есть короткий alias, time.Tick, который Вам
возвращает сразу канал, с которого вы можете читать, но у него
есть особенность: он работает бесконечно, вы никак не можете его освободить. В данном случае, если я завершу
этот цикл и не выйду из программы, то ticker будет продолжать работать. Его надо использовать тогда, когда вы
точно не планируете его останавливать. Например, для сбора какого-то
мониторинга с вашей программы, то есть который запускается каждую минуту,
собирает метрики и куда-то их отсылает. Еще одна конструкция,
которую рассмотрим, это AfterFunc. AfterFunc, как это видно из названия, запускает функцию через
определенный промежуток времени. Как результат выполнения этой функции, вам возвращается таймер,
который Вы можете остановить, тем самым прервав выполнение
этой функции отложенной. Это тоже нужно запустить. [БЕЗ_ЗВУКА] Мы подождали, и функция вышла. Хорошо. В этом примере я хочу очень быстро прервать эту функцию, чтобы показать,
как работает timer.Stop. Смотрите, я запускаю программу, сразу же
нажимаю кнопку, и ничего не происходит. Моя функция не выполняется,
я остановил таймер, следовательно, функция никогда не будет вызвана. И теперь я могу просто выйти из программы. На этом все.