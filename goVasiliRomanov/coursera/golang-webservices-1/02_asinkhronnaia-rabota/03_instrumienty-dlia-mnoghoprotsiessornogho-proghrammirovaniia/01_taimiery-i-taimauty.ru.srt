1
00:00:00,000 --> 00:00:06,264
[БЕЗ_ЗВУКА] В

2
00:00:06,264 --> 00:00:12,340
этом видео мы рассмотрим организацию
таймаутов и еще некоторых операций,

3
00:00:12,340 --> 00:00:16,280
когда нам нужно выполнить что-то
через небольшой промежуток времени.

4
00:00:16,280 --> 00:00:19,865
Начнем мы с таймаутов.

5
00:00:19,865 --> 00:00:25,696
Бывает, что нам нужно ждать операцию
фиксированное количество времени,

6
00:00:25,696 --> 00:00:30,347
то есть мы не можем ожидать бесконечно,
пользователь не будет ждать несколько

7
00:00:30,347 --> 00:00:34,310
часов, пока мы там что-то посчитаем,
и уйдет; поэтому нужны таймауты.

8
00:00:34,310 --> 00:00:36,813
Рассмотрим этот пример.

9
00:00:36,813 --> 00:00:41,030
Итак, для начала мы можем объявить timer,

10
00:00:41,030 --> 00:00:45,340
который находится в пакете time.

11
00:00:45,340 --> 00:00:51,141
У таймера есть канал,
и в случае если мы будем использовать

12
00:00:51,141 --> 00:00:56,373
мультиплексор select,
то мы можем поставить на

13
00:00:56,373 --> 00:01:01,684
чтение с этого канала,
и как только наступит нужное время,

14
00:01:01,684 --> 00:01:06,710
там появится событие, и он сработает.

15
00:01:06,710 --> 00:01:11,613
У NewTimer есть короткое объявление,

16
00:01:11,613 --> 00:01:17,340
когда нам сразу же возвращается канал без
промежуточной переменной, time.After.

17
00:01:17,340 --> 00:01:20,772
Но у них есть небольшие особенности.

18
00:01:20,772 --> 00:01:24,918
Мы можем остановить timer от выполнения,

19
00:01:24,918 --> 00:01:29,816
а time.After мы остановить не можем,
и пока он не выполнится,

20
00:01:29,816 --> 00:01:33,100
даже если мы завершили функцию,
он не освободит ресурсы.

21
00:01:33,100 --> 00:01:38,608
Поэтому если вам нужно лучше
контролировать расход ресурсов,

22
00:01:38,608 --> 00:01:44,305
расход памяти, пользуйтесь простым
таймером и останавливайте его,

23
00:01:44,305 --> 00:01:46,350
когда вам это требуется.

24
00:01:46,350 --> 00:01:49,960
Давайте запустим нашу программу.

25
00:01:49,960 --> 00:01:51,247
Отлично!

26
00:01:51,247 --> 00:01:58,801
Случился таймаут,
который мы указывали в таймере вот здесь.

27
00:01:58,801 --> 00:02:04,410
А если мы поменяем время на тройку,
например,

28
00:02:04,410 --> 00:02:09,480
то сработает наша

29
00:02:09,480 --> 00:02:13,926
какая-то длинная операция.

30
00:02:13,926 --> 00:02:18,316
Это организация таймаута
на какую-то операцию,

31
00:02:18,316 --> 00:02:20,870
делается она через мультиплексор select.

32
00:02:20,870 --> 00:02:25,950
Теперь рассмотрим какие-то
периодические события.

33
00:02:25,950 --> 00:02:31,229
Переодические события — это значит,
что с определенным интервалом

34
00:02:31,229 --> 00:02:35,988
времени вам приходят события,
и вы что-то делаете в это время.

35
00:02:35,988 --> 00:02:39,000
Делается это через конструкцию ticker,

36
00:02:39,000 --> 00:02:43,540
она тоже находится в пакете time,
ее можно создать через NewTicker.

37
00:02:43,540 --> 00:02:48,393
Если вы читаете из канала,
который предоставляет ticker,

38
00:02:48,393 --> 00:02:54,330
то вам возвращается время,
когда было срабатывание.

39
00:02:54,330 --> 00:02:57,734
Поэтому вы можете использовать это время,

40
00:02:57,734 --> 00:03:03,590
если вам нужно зафиксировать,
в какой момент было произведено событие.

41
00:03:03,590 --> 00:03:08,008
Давайте посмотрим на этот пример.

42
00:03:08,008 --> 00:03:13,388
Тут я жду всего лишь пять секунд и
после этого останавливаю ticker,

43
00:03:13,388 --> 00:03:20,460
чтобы он больше не посылал мне время,
не посылал мне тики, и завершаю.

44
00:03:20,460 --> 00:03:28,477
Итак, один,

45
00:03:28,477 --> 00:03:32,946
два, три, четыре, пять.

46
00:03:32,946 --> 00:03:38,811
Все, на пятом тике мы ticker
завершили и вышли из цикла.

47
00:03:38,811 --> 00:03:43,210
Опять-таки у тикера есть короткий alias,

48
00:03:43,210 --> 00:03:49,506
time.Tick, который Вам
возвращает сразу канал,

49
00:03:49,506 --> 00:03:55,020
с которого вы можете читать, но у него
есть особенность: он работает бесконечно,

50
00:03:55,020 --> 00:03:57,330
вы никак не можете его освободить.

51
00:03:57,330 --> 00:04:01,571
В данном случае, если я завершу
этот цикл и не выйду из программы,

52
00:04:01,571 --> 00:04:04,090
то ticker будет продолжать работать.

53
00:04:04,090 --> 00:04:10,595
Его надо использовать тогда, когда вы
точно не планируете его останавливать.

54
00:04:10,595 --> 00:04:13,940
Например, для сбора какого-то
мониторинга с вашей программы,

55
00:04:13,940 --> 00:04:18,180
то есть который запускается каждую минуту,
собирает метрики и куда-то их отсылает.

56
00:04:18,180 --> 00:04:23,784
Еще одна конструкция,
которую рассмотрим, это AfterFunc.

57
00:04:23,784 --> 00:04:26,860
AfterFunc, как это видно из названия,

58
00:04:26,860 --> 00:04:30,830
запускает функцию через
определенный промежуток времени.

59
00:04:30,830 --> 00:04:36,851
Как результат выполнения этой функции,

60
00:04:36,851 --> 00:04:40,135
вам возвращается таймер,
который Вы можете остановить,

61
00:04:40,135 --> 00:04:43,300
тем самым прервав выполнение
этой функции отложенной.

62
00:04:43,300 --> 00:04:46,420
Это тоже нужно запустить.

63
00:04:46,420 --> 00:04:52,087
[БЕЗ_ЗВУКА] Мы

64
00:04:52,087 --> 00:04:57,000
подождали, и функция вышла.

65
00:04:57,000 --> 00:04:59,125
Хорошо.

66
00:04:59,125 --> 00:05:03,870
В этом примере я хочу очень быстро

67
00:05:03,870 --> 00:05:08,950
прервать эту функцию, чтобы показать,
как работает timer.Stop.

68
00:05:08,950 --> 00:05:13,220
Смотрите, я запускаю программу, сразу же
нажимаю кнопку, и ничего не происходит.

69
00:05:13,220 --> 00:05:17,646
Моя функция не выполняется,
я остановил таймер, следовательно,

70
00:05:17,646 --> 00:05:19,416
функция никогда не будет вызвана.

71
00:05:19,416 --> 00:05:21,550
И теперь я могу просто выйти из программы.

72
00:05:21,550 --> 00:05:26,220
На этом все.