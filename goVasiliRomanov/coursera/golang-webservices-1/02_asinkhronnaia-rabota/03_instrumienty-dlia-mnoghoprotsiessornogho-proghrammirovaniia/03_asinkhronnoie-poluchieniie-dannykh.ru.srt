1
00:00:00,000 --> 00:00:05,140
[БЕЗ_ЗВУКА] А

2
00:00:05,140 --> 00:00:10,100
теперь поговорим про прикладное
применение каналов и горутин.

3
00:00:10,100 --> 00:00:17,617
Начнём мы с ускорения работы некоторых
запросов путём их распараллеливания.

4
00:00:17,617 --> 00:00:20,906
Например, представьте,
что у вас есть страницы статьи,

5
00:00:20,906 --> 00:00:24,852
на которой есть комментарии,
и какие-то связанные статьи.

6
00:00:24,852 --> 00:00:29,470
При этом комментарии и статьи,
они между собой никак не связаны,

7
00:00:29,470 --> 00:00:32,910
хотя чаще всего они
получаются последовательно.

8
00:00:32,910 --> 00:00:37,499
В go вы можете распараллелить эту работу,

9
00:00:37,499 --> 00:00:42,719
внеся тяжёлую операцию
в отдельную горутину,

10
00:00:42,719 --> 00:00:47,715
которая будет общаться с
вашей программой через канал.

11
00:00:47,715 --> 00:00:52,061
То есть, давайте посмотрим,
как это работает на практике.

12
00:00:52,061 --> 00:00:57,290
Смотрите, мы вызывает функцию getComments,
которая возвращает нам канал.

13
00:00:57,290 --> 00:01:01,505
После этого мы не начинаем сразу
ждать ответ из этого канала,

14
00:01:01,505 --> 00:01:05,720
мы выполняем ещё какую-то работу,
например, получаем связанные статьи.

15
00:01:05,720 --> 00:01:10,779
И только после этого дожидаемся
результата этого канала.

16
00:01:10,779 --> 00:01:14,460
Получается, что в главной горутине,

17
00:01:14,460 --> 00:01:18,829
функции getPage,
мы получили связанные статьи,

18
00:01:18,829 --> 00:01:22,900
при этом параллельно с этим
мы получили комментарии.

19
00:01:22,900 --> 00:01:28,760
Давайте посмотрим, как это работает
внутри функции getComments():

20
00:01:28,760 --> 00:01:33,220
getComments() возвращает нам канал.

21
00:01:33,220 --> 00:01:38,092
Изначально мы сразу создаём его,
после этого запускаем горутину,

22
00:01:38,092 --> 00:01:41,305
куда передаём этот канал,
и возвращаем его.

23
00:01:41,305 --> 00:01:46,830
При этом сама работа, сама полезная
работа, будет выполняться уже в горутине.

24
00:01:46,830 --> 00:01:50,233
В данном случае это просто Sleep(),

25
00:01:50,233 --> 00:01:55,232
однако ничего не мешает нам добавить
туда SQL-запрос, например, и,

26
00:01:55,232 --> 00:02:01,350
когда операция закончится,
она в канал запишет результат.

27
00:02:01,350 --> 00:02:06,810
Однако есть один нюанс,
который стоит знать при таких операциях.

28
00:02:06,810 --> 00:02:10,535
В случае, если вы используете
небуферизированный канал, например,

29
00:02:10,535 --> 00:02:15,470
вот так, то что произойдёт,

30
00:02:15,470 --> 00:02:19,662
если по причине какой-то ошибки, например,

31
00:02:19,662 --> 00:02:24,680
той же ошибки с базой данных,
вы вернётесь из функции, например, return?

32
00:02:24,680 --> 00:02:25,563
Вот так.

33
00:02:25,563 --> 00:02:27,110
Что получится?

34
00:02:27,110 --> 00:02:31,108
Получится, что ваша корутина, вот эта,

35
00:02:31,108 --> 00:02:34,789
она пытается записать в канал синхронно,

36
00:02:34,789 --> 00:02:39,530
то есть ожидая с другой стороны чтение,
но оттуда уже никто не читает.

37
00:02:39,530 --> 00:02:43,580
И получится утечка горутин и,
как следствие, утечка памяти.

38
00:02:43,580 --> 00:02:49,290
Поэтому канал должен быть
буферизированным на одно значение.

39
00:02:49,290 --> 00:02:50,397
Что это даёт?

40
00:02:50,397 --> 00:02:57,140
Это даёт нам возможность записать хотя бы
одно значение в этот канал, не блокируясь.

41
00:02:57,140 --> 00:03:02,033
Тогда получается, что если вдруг мы не

42
00:03:02,033 --> 00:03:06,290
дошли до функции чтения из этого канала,

43
00:03:06,290 --> 00:03:10,770
то мы запишем туда результат,

44
00:03:10,770 --> 00:03:15,350
функция корректно выполнится, завершится,

45
00:03:15,350 --> 00:03:19,870
а сам канал уже после этого,
он уберётся сборщиком мусора,

46
00:03:19,870 --> 00:03:24,390
потому что из него никто не пытается
ни читать, никто туда не пишет.

47
00:03:24,390 --> 00:03:28,925
Это очень полезный инструмент в работе,

48
00:03:28,925 --> 00:03:33,460
и позволяет неплохо
оптимизировать некоторые операции.