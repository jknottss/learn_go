[БЕЗ_ЗВУКА] В этом видео мы поговорим про состояние гонки,
оно же race condition, или data race. Вам оно может быть знакомо, если вы занимались базами данных и
изучали транзакции, которые нужны, для того чтобы атомарно обновить
какое-то значение в базе данных. Но вернемся в Go. В этом примере, в этом примере мы будем обновлять мапу со счетчиками
из разных горутин. Вроде бы беды ничего не предвещает,
все должно быть хорошо, мы обновляем разные значения,
которые не пересекаются друг с другом. Но результат этой работы этой
программы нас может не порадовать. Почему? Дело в том, что map в Go — это
конкурентно небезопасный тир данных, то есть обращаясь к нему из разных
горутин, которые могут выполняться совершенно на разных процессорах,
можно как раз словить это состояние гонки. Почему это может произойти? Дело в том, что мапа внутри себя
— это ссылка на структуру данных, как хеш-таблица. И она может перестраиваться и
копироваться в другое место, или еще что-то с ней может происходить. При этом в кэше одного процессора может лежать одно значение,
в кэше другого — другое значение. И когда они попытаются обновить
это значение в основной памяти, произойдет коллапс. Но давайте запустим нашу программу. Как я говорил,
результат нас не очень порадует. Программа вылетела с ошибкой fatal error:
concurrent map read and map write. [НЕРАЗБОРЧИВО], но основное, что нас может
в этой программе заинтересовать — это, например, вот эта строчка,
где мы писали строчку номер 10. Строчка номер 10 — это
как раз запись в мапу, то есть как раз инкремент. Для начала, что вообще с этим можно
сделать и как ловить такие ошибки? Потому что они довольно нетривиальные
и не всегда воспроизводятся. Это может называться плавающим багом,
либо гейзенбагом. Для того чтобы ловить похожие ошибки, в Go есть специальная директива при
запуске программы или компиляции race. Давайте попробуем запустить
нашу программу с ней. Смотрите, эта директива называется race. В данном случае я сразу
запускаю программу. Она работает и завершается,
но завершается уже не с такими кишками, как было в прошлый раз, а как-то полегче. Что мы видим? Как минимум наши счетчики были выведены на
экран, то есть программа хотя бы не упала. И написала нам,
что нашлось два состояния гонки. И теперь давайте посморим, что там было. Итак, первый раз — это на строчке 10, второй раз — на строчке 12, вот здесь. Давайте посмотрим в коде, где это. Итого, первый раз — это строчка 10,
которая передалась вот отсюда. А другой раз — это строчка 15 вот здесь. То есть reading WARNING: DATA RACE, read, то есть читаю я на строчке 15,
вот тут, вот на этой строчке. А предыдущая запись была на строчке 10, которая была вызвана
горутиной на строчке 12. Вот вызов горутины вот здесь,
и вот строчка 20, где было произведено. Давайте теперь посмотрим,
как с этим бороться, раз уж мы это нашли.