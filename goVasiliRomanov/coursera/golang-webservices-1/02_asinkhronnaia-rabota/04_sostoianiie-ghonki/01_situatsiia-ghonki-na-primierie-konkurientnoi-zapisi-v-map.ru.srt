1
00:00:00,000 --> 00:00:06,047
[БЕЗ_ЗВУКА] В этом

2
00:00:06,047 --> 00:00:11,320
видео мы поговорим про состояние гонки,
оно же race condition, или data race.

3
00:00:11,320 --> 00:00:13,041
Вам оно может быть знакомо,

4
00:00:13,041 --> 00:00:17,526
если вы занимались базами данных и
изучали транзакции, которые нужны,

5
00:00:17,526 --> 00:00:21,820
для того чтобы атомарно обновить
какое-то значение в базе данных.

6
00:00:21,820 --> 00:00:23,899
Но вернемся в Go.

7
00:00:23,899 --> 00:00:28,474
В этом примере, в этом примере мы будем

8
00:00:28,474 --> 00:00:33,598
обновлять мапу со счетчиками
из разных горутин.

9
00:00:33,598 --> 00:00:37,730
Вроде бы беды ничего не предвещает,
все должно быть хорошо,

10
00:00:37,730 --> 00:00:41,460
мы обновляем разные значения,
которые не пересекаются друг с другом.

11
00:00:41,460 --> 00:00:46,433
Но результат этой работы этой
программы нас может не порадовать.

12
00:00:46,433 --> 00:00:47,150
Почему?

13
00:00:47,150 --> 00:00:52,370
Дело в том, что map в Go — это
конкурентно небезопасный тир данных,

14
00:00:52,370 --> 00:00:56,237
то есть обращаясь к нему из разных
горутин, которые могут выполняться

15
00:00:56,237 --> 00:01:02,110
совершенно на разных процессорах,
можно как раз словить это состояние гонки.

16
00:01:02,110 --> 00:01:05,760
Почему это может произойти?

17
00:01:05,760 --> 00:01:11,515
Дело в том, что мапа внутри себя
— это ссылка на структуру данных,

18
00:01:11,515 --> 00:01:13,010
как хеш-таблица.

19
00:01:13,010 --> 00:01:15,769
И она может перестраиваться и
копироваться в другое место,

20
00:01:15,769 --> 00:01:17,670
или еще что-то с ней может происходить.

21
00:01:17,670 --> 00:01:22,591
При этом в кэше одного

22
00:01:22,591 --> 00:01:26,270
процессора может лежать одно значение,
в кэше другого — другое значение.

23
00:01:26,270 --> 00:01:30,725
И когда они попытаются обновить
это значение в основной памяти,

24
00:01:30,725 --> 00:01:32,270
произойдет коллапс.

25
00:01:32,270 --> 00:01:39,270
Но давайте запустим нашу программу.

26
00:01:39,270 --> 00:01:44,540
Как я говорил,
результат нас не очень порадует.

27
00:01:44,540 --> 00:01:50,240
Программа вылетела с ошибкой fatal error:
concurrent map read and map write.

28
00:01:50,240 --> 00:01:57,729
[НЕРАЗБОРЧИВО], но основное, что нас может
в этой программе заинтересовать — это,

29
00:01:57,729 --> 00:02:02,356
например, вот эта строчка,
где мы писали строчку номер 10.

30
00:02:02,356 --> 00:02:06,693
Строчка номер 10 — это
как раз запись в мапу,

31
00:02:06,693 --> 00:02:11,420
то есть как раз инкремент.

32
00:02:11,420 --> 00:02:15,440
Для начала, что вообще с этим можно
сделать и как ловить такие ошибки?

33
00:02:15,440 --> 00:02:21,460
Потому что они довольно нетривиальные
и не всегда воспроизводятся.

34
00:02:21,460 --> 00:02:25,870
Это может называться плавающим багом,
либо гейзенбагом.

35
00:02:25,870 --> 00:02:28,492
Для того чтобы ловить похожие ошибки,

36
00:02:28,492 --> 00:02:33,953
в Go есть специальная директива при
запуске программы или компиляции race.

37
00:02:33,953 --> 00:02:39,560
Давайте попробуем запустить
нашу программу с ней.

38
00:02:39,560 --> 00:02:45,760
Смотрите, эта директива называется race.

39
00:02:45,760 --> 00:02:51,120
В данном случае я сразу
запускаю программу.

40
00:02:51,120 --> 00:02:56,528
Она работает и завершается,
но завершается уже не с такими кишками,

41
00:02:56,528 --> 00:03:00,859
как было в прошлый раз, а как-то полегче.

42
00:03:00,859 --> 00:03:02,620
Что мы видим?

43
00:03:02,620 --> 00:03:06,870
Как минимум наши счетчики были выведены на
экран, то есть программа хотя бы не упала.

44
00:03:06,870 --> 00:03:12,180
И написала нам,
что нашлось два состояния гонки.

45
00:03:12,180 --> 00:03:18,220
И теперь давайте посморим, что там было.

46
00:03:18,220 --> 00:03:22,510
Итак, первый раз — это на строчке 10,

47
00:03:22,510 --> 00:03:26,370
второй раз — на строчке 12, вот здесь.

48
00:03:26,370 --> 00:03:28,974
Давайте посмотрим в коде, где это.

49
00:03:28,974 --> 00:03:33,600
Итого, первый раз — это строчка 10,
которая передалась вот отсюда.

50
00:03:33,600 --> 00:03:38,900
А другой раз — это строчка 15 вот здесь.

51
00:03:38,900 --> 00:03:42,970
То есть reading WARNING: DATA RACE,

52
00:03:42,970 --> 00:03:47,730
read, то есть читаю я на строчке 15,
вот тут, вот на этой строчке.

53
00:03:47,730 --> 00:03:53,601
А предыдущая запись была на строчке 10,

54
00:03:53,601 --> 00:04:01,076
которая была вызвана
горутиной на строчке 12.

55
00:04:01,076 --> 00:04:06,620
Вот вызов горутины вот здесь,
и вот строчка 20, где было произведено.

56
00:04:06,620 --> 00:04:13,260
Давайте теперь посмотрим,
как с этим бороться, раз уж мы это нашли.