1
00:00:00,000 --> 00:00:07,961
[БЕЗ_ЗВУКА] В этом видео
мы рассмотрим функции,

2
00:00:07,961 --> 00:00:12,130
основной инструмент для декомпозиции
вашей программы на более простые блоки.

3
00:00:12,130 --> 00:00:17,110
Итак, функция в блок
объявляется через служебное

4
00:00:17,110 --> 00:00:21,229
слово func,
после которой следует имя функции,

5
00:00:21,229 --> 00:00:25,540
с скобочках параметра и
после возвращаемое значение.

6
00:00:25,540 --> 00:00:28,691
Результат из функции возвращается,

7
00:00:28,691 --> 00:00:34,470
используя оператор return,
как и в других языках, впрочем.

8
00:00:34,470 --> 00:00:40,749
При этом если у вас несколько
параметров одного типа,

9
00:00:40,749 --> 00:00:46,235
то вы можете объявить его только один раз,
а сами параметры указать через запятую.

10
00:00:46,235 --> 00:00:50,896
Либо же указывать тип для
каждого из параметров.

11
00:00:50,896 --> 00:00:54,762
В Go можно указывать сразу
возвращаемый результат,

12
00:00:54,762 --> 00:00:58,870
то есть сразу указывать переменную,
которая будет с возвращаемым результатом.

13
00:00:58,870 --> 00:01:03,520
При этом вы можете

14
00:01:03,520 --> 00:01:08,170
записать туда значение и написать пустой
return без имени этой переменной.

15
00:01:08,170 --> 00:01:11,421
И она вернет вам то, что вы записали.

16
00:01:11,421 --> 00:01:13,560
В данном случае это out.

17
00:01:13,560 --> 00:01:19,120
Впрочем вас никто не заставляет возвращать
именно out, вы можете написать,

18
00:01:19,120 --> 00:01:22,640
например, return 3, даже в таком
случае это будет корректная работа.

19
00:01:22,640 --> 00:01:29,560
В Go функции могут возвращать
несколько результатов.

20
00:01:29,560 --> 00:01:33,443
Чаще всего всего это используется для
возврата ошибки в качестве второго

21
00:01:33,443 --> 00:01:34,140
параметра.

22
00:01:34,140 --> 00:01:38,570
При этом параметров не обязательно может
быть два, их может быть три или более.

23
00:01:38,570 --> 00:01:43,476
Но очень многие служебные функции Go
из стандартной библиотеки возвращают

24
00:01:43,476 --> 00:01:46,885
как раз два параметра.

25
00:01:46,885 --> 00:01:51,640
При этом при написании return,
возвращаемого значения,

26
00:01:51,640 --> 00:01:56,276
вы должны каждый раз указывать
оба параметра через запятую.

27
00:01:56,276 --> 00:02:00,139
В данном случае я должен указать
сначала первый параметр in,

28
00:02:00,139 --> 00:02:01,960
потом второй параметр ошибку.

29
00:02:01,960 --> 00:02:10,561
На 26-й строчке я указываю возвращаемый
результат in и nil в качестве ошибки.

30
00:02:10,561 --> 00:02:16,371
Также вы можете вернуть несколько
именованных результатов.

31
00:02:16,371 --> 00:02:19,915
Для этого достаточно объявить у них имена.

32
00:02:19,915 --> 00:02:24,775
Еще раз напомню, что все
именованные возвращаемые результаты

33
00:02:24,775 --> 00:02:28,600
сразу инициализируются
значениями по умолчанию.

34
00:02:28,600 --> 00:02:34,060
То есть когда вы будете их возвращать,
будет возвращаться этот результат.

35
00:02:34,060 --> 00:02:38,490
Например, по умолчанию rez = 0,
и если я объявлю,

36
00:02:38,490 --> 00:02:41,890
положу туда какое-то значение,
например, rez = 1,

37
00:02:41,890 --> 00:02:46,839
то моя функция будет возвращать 1.

38
00:02:46,839 --> 00:02:52,236
Следовательно, если я присвою
что-то в ошибку на строчке 33,

39
00:02:52,236 --> 00:02:56,180
то это аналогично,
если бы я написал return rez, err.

40
00:02:56,180 --> 00:03:01,008
Что в общем-то опять-таки
никто не заставляет меня

41
00:03:01,008 --> 00:03:05,278
использовать именно
именованные результаты.

42
00:03:05,278 --> 00:03:07,950
Я могу вернуть сам 1 и ошибку.

43
00:03:07,950 --> 00:03:12,990
Ну и дальше я могу вернуть
что-то без ошибки.

44
00:03:12,990 --> 00:03:17,780
В Go функции могут принимать
неограниченное количество параметров,

45
00:03:17,780 --> 00:03:18,914
но только одно типа.

46
00:03:18,914 --> 00:03:22,570
Такие функции называются вариативными,
по английски variative.

47
00:03:22,570 --> 00:03:28,230
Для того чтобы так сделать,
нужно указать перед именем функции,

48
00:03:28,230 --> 00:03:33,125
перед именем параметра троеточие.

49
00:03:33,125 --> 00:03:38,020
В этом случае на вход, в данном случае
в переменную in, вам придет slice.

50
00:03:38,020 --> 00:03:43,254
slice int'ов,
по которым вы можете проитерироваться,

51
00:03:43,254 --> 00:03:45,720
используя цикл for range.

52
00:03:45,720 --> 00:03:49,500
Давайте посмотрим немножко,
как оно работает.

53
00:03:49,500 --> 00:03:54,578
Давайте вызовем
multiplenamedReturn с входным

54
00:03:54,578 --> 00:03:59,300
параметром true, вот эта функция.

55
00:03:59,300 --> 00:04:04,200
Если мы ее вызовем,

56
00:04:04,200 --> 00:04:10,381
то она вернет нам 1,
потому что мы указали 1 вот здесь.

57
00:04:10,381 --> 00:04:15,900
Мы в именованный параметр
присвоили значение 1.

58
00:04:15,900 --> 00:04:21,550
И когда мы написали return потом,
присвоив в err какую-то ошибку,

59
00:04:21,550 --> 00:04:25,548
оно написало нам, что тут было 1.

60
00:04:25,548 --> 00:04:29,834
Конечно, я могу написать и вот так,

61
00:04:29,834 --> 00:04:34,810
например, давайте сделаем не 1, а 3.

62
00:04:34,810 --> 00:04:37,988
И мне вернется 3.

63
00:04:37,988 --> 00:04:41,623
То есть я не должен использовать
именованный параметр обязательно,

64
00:04:41,623 --> 00:04:43,560
я могу вернуть какие-то
любые другие значения.

65
00:04:43,560 --> 00:04:48,670
Если же я передам в эту функцию false,

66
00:04:48,670 --> 00:04:53,880
то блок с ошибкой не выполнится,

67
00:04:53,880 --> 00:04:58,770
и в rez присвоится 2, и я верну 2 и nil.

68
00:04:58,770 --> 00:05:00,160
Вот, пожалуйста.

69
00:05:00,160 --> 00:05:05,080
Теперь давайте посмотрим на
использование вариативных параметров.

70
00:05:05,080 --> 00:05:09,960
Если бы я передал просто nums,

71
00:05:09,960 --> 00:05:14,950
у меня есть слайс nums,
если бы я передал сумму просто слайс,

72
00:05:14,950 --> 00:05:19,510
то компилятор в этом
случае будет ругаться,

73
00:05:19,510 --> 00:05:24,662
потому что это отдельный тип слайс.

74
00:05:24,662 --> 00:05:29,171
Это не какое-то количество
повторяющихся параметров одиночных,

75
00:05:29,171 --> 00:05:30,852
это отдельный тип слайс.

76
00:05:30,852 --> 00:05:33,610
В этом случае компилятор будет ругаться.

77
00:05:33,610 --> 00:05:40,552
Но иногда бывает надо передать как
раз-таки слайс как вариативный параметр,

78
00:05:40,552 --> 00:05:45,569
для этого используется
троеточие после имени слайса.

79
00:05:45,569 --> 00:05:52,625
Это распаковывает вам слайс в одиночные
аргументы, которые передаются функции.

80
00:05:52,625 --> 00:05:53,980
Давайте вызовем.

81
00:05:53,980 --> 00:05:56,055
Вот смотрите.

82
00:05:56,055 --> 00:06:01,575
Функция, она мне вывела
тип входящей переменной,

83
00:06:01,575 --> 00:06:06,269
то есть in — это пришел слайс,
то есть это фактически слайс.

84
00:06:06,269 --> 00:06:07,939
Ну и значение.

85
00:06:07,939 --> 00:06:10,770
Посчитала его и вернула.

86
00:06:10,770 --> 00:06:15,220
Ну я вывел в Println сам

87
00:06:15,220 --> 00:06:19,679
слайс и результат, их суммирование.

88
00:06:19,679 --> 00:06:25,122
Кстати, функция Println — как
раз-таки пример вариативной функции.

89
00:06:25,122 --> 00:06:29,490
Она принимает множество параметров и
выводит их в строковое представление.