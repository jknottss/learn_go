[БЕЗ_ЗВУКА] В этом видео мы рассмотрим такие
понятия как отложенное выполнение, панику и восстановление после паники. В Go есть возможность
отложенного выполнения функции. Это когда какая-то работа будет
выполнена после завершения функции. Чаще всего это используется,
когда вам нужно посчитать, например, время работы функции,
либо закрыть какой-то ресурс, например, сетевое соединение
либо файловый дескриптор. Причем если у вас много
условий и много returns, каждый раз руками писать это бывает не
очень удобно и довольно утомительно. Поэтому вы можете объявить один раз
отложенное выполнение на закрытие какого-то ресурса, сразу же после
открытия это делается, и забыть о нем. Давайте посмотрим, как это работает. Вот у нас есть функция, функция main. Вначале мы определяем,
что нужно выполнить какую-то функцию отложенную,
то есть не сейчас, а в конце. Определяется это через
ключевое слово defer, и потом вы уже должны написать
непосредственно одну строчку кода, которая будет выполнена,
то есть обычную функцию. В данном случае это было бы вот так. go run defer. То есть смотрите, after work вывелось
вначале, а потом some useful work. Добавляем defer. Выполняем еще раз и, смотрите, теперь after work выполнилось
уже в конце функции. При этом если вы используете
несколько отложенных функций, то они выполняются в порядке,
обратном их объявлению. В данном случае сначала выполнится second,
а потом обычное. Some useful work, second и обычное. Теперь стоит отметить такую вещь как аргументы,
которые передаются в эти функции. Дело в том, что аргументы в эти функции вычисляются на момент
объявления отложенной функции. Смотрите, как это работает. Представим, что у нас есть какая-то
функция, которая что-то возвращает. Например, вот так. GetSomeVars. Для того чтобы понять,
когда она была вызвана, я напечатал определенную строку. Теперь смотрите. Я хочу сделать вот так. То есть я говорю, что напечатай мне, пожалуйста, результат
выполнения вот этой функции. Давайте запустим и посмотрим, что будет. Смотрите. Сначала выполнилась GetSomeVars execution, то есть выполнилась вот эта функция,
потому что, повторюсь, аргументы отложенных функций
вычисляются при объявлении блока defer, не когда функция будет вызвана,
а при объявлении. То есть сначала выполнилась функция, которая вычисляет аргументы, потом
выполнилась какая-то полезная работа, потом только вывелся результат,
который вернула нам эта функция, GetSomeVars, и потом
вызвался первый блок defer. Иногда это бывает не очень удобно,
поэтому часто используется подход, когда мы объявляем анонимную функцию,
и она будет вызвана в конце. Например, смотрите. Func, вызов этой функции, и теперь я в ней вызову функцию
печати каких-то аргументов. Давайте посмотрим, к чему это привело. Смотрите, сначала
выполнилась полезная работа, вот эта, потом выполнился вот этот
блок defer, то есть уже внутри него выполнилась функция,
то есть она выполнилась в конце. Потом напечаталась вот эта строчка,
вернулся результат, напечатался результат в строчке 13,
и потом вызвался самый первый defer. Полезная работа,
выполнение и получение аргументов, печать аргументов, которые вернулись,
и самый первый defer. Конструкции с defer очень полезны
при восстановлении из паники. Сначала давайте рассмотрим,
что такое вообще паника. Представьте, у нас есть какая-то функция,
defer test. Она делает какую-то
работу и потом паникует. Паника это служебная функция, которая останавливает выполнение работы
программы, то есть вся программа крашится. Давайте посмотрим, как это работает. [БЕЗ_ЗВУКА] Смотрите, выполнилась какая-то полезная работа, потом вызвалась паника и
напечатался стек трейс. Дело в том, что паника вообще штука не очень хорошая,
и завершать работающий демон в продакшене, когда там еще много параллельных запросов
отрабатывается, не очень хорошо. Паника это абсолютно
исключительная ситуация. И как-то это надо отлавливать. Отлавливается она с помощью блока defer. Давайте я вам это продемонстрирую. Смотрите, сначала мы должны объявить,
собственно, блок, defer. Дело в том, что блок defer будет
выполнен все равно после функции, я вам это покажу. [БЕЗ_ЗВУКА] panic mode. Смотрите, in panic mode нам напечатался,
то есть defer работает. Как же теперь восстановиться после паники? У нас есть функция recover,
которая возвращает нам результат, ошибку, которая была вброшена паникой. Смотрите, recover, получаем ошибку. Теперь, если ошибка вообще была, err = nil [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] Давайте теперь попробуем выполнить. Обратите внимание, наша программа
теперь завершилась корректно, то есть она не упала в панику, это значит,
что эта функция отработала корректно. То есть выполнилась какая-то
полезная работа и дальше мы успешно восстановились после паники. Это может вам показаться немножко
похожим на блок try-catch, но я это отмечу особо,
никогда не используйте панику и восстановление после паники
как эмуляцию блока try-catch. Они для этого не предназначены. Паника это абсолютная
исключительная ситуация, которая обычно приводит к краху программы. Она ловится для того чтобы другие запросы, которые выполняются этой программой,
не затронулись. Естественно, иногда бывает,
что в defer выводы случайно тоже упали в панику. Другие функции,
которые после этого выполняются, они могут поймать эту панику, но вообще бросать панику в восстановлении
это очень плохая практика. Давайте посмотрим. Смотрите, сначала я выполнил панику первый раз:
что-то плохое случилось. Да?
То есть текст, который я вот здесь запаниковал. Потом я запаниковал вот здесь. Этот блок обработался
следующим recover-ом. А если бы я не паниковал, то второй recover ничего бы не получил. Так работает паника. Пользуйтесь ею с осторожностью.