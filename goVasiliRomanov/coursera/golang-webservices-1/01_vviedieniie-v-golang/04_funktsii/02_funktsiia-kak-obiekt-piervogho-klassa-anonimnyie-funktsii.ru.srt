1
00:00:00,000 --> 00:00:04,872
[БЕЗ_ЗВУКА] А

2
00:00:04,872 --> 00:00:09,570
теперь поговорим о функциях,
как об объектах первого класса.

3
00:00:09,570 --> 00:00:12,429
Функция как объект
первого класса означает,

4
00:00:12,429 --> 00:00:17,295
что вы можете присваивать функцию в
какую-то переменную, принимать функцию,

5
00:00:17,295 --> 00:00:21,091
как аргумент в другую
функцию и возвращать функцию,

6
00:00:21,091 --> 00:00:24,267
как результат работы какой-то функции.

7
00:00:24,267 --> 00:00:29,456
Ну а также иметь функцию,
как поле какой-то структуры.

8
00:00:29,456 --> 00:00:35,432
Например, обычная функция,
она определяется в отдельном блоке,

9
00:00:35,432 --> 00:00:39,130
то есть она имеет имя,
в данном случае doNothing.

10
00:00:39,130 --> 00:00:43,388
Но анонимная функция, анонимная функция,

11
00:00:43,388 --> 00:00:49,115
она не имеет имени и определяется там,
где вы захотите.

12
00:00:49,115 --> 00:00:53,910
Например, я объявляю анонимную функцию,

13
00:00:53,910 --> 00:01:00,117
то есть я не указываю имя, после ключевого
слова func я сразу указываю принимающие...

14
00:01:00,117 --> 00:01:01,890
входящие параметры.

15
00:01:01,890 --> 00:01:05,337
И сразу же вызываю эту
функцию на строке 14,

16
00:01:05,337 --> 00:01:08,660
передавая в качестве
параметра строчку nobody.

17
00:01:08,660 --> 00:01:17,910
И она мне выведет, что что-то.

18
00:01:17,910 --> 00:01:19,728
anon func out: nobody.

19
00:01:19,728 --> 00:01:25,890
То есть nobody — это параметр анонимной
функции, который я вывожу в этой Println.

20
00:01:25,890 --> 00:01:30,820
Также анонимную функцию можно присвоить

21
00:01:30,820 --> 00:01:35,499
в какую-то переменную и потом вызвать ее.

22
00:01:35,499 --> 00:01:39,410
То есть я вызову функцию уже, как...

23
00:01:39,410 --> 00:01:43,478
я обращусь к этой переменной,
как к функции.

24
00:01:43,478 --> 00:01:48,428
Например, на строке 17 я
присваиваю в переменную printer

25
00:01:48,428 --> 00:01:53,270
какую-то функцию, которая просто
выводит текст, который в нее передали.

26
00:01:53,270 --> 00:01:55,850
А теперь вызываю: printer("as variable").

27
00:01:55,850 --> 00:01:57,553
Давайте посмотрим.

28
00:01:57,553 --> 00:02:01,530
Вот, наш printer напечатал,
что он был вызван,

29
00:02:01,530 --> 00:02:05,370
как переменная.

30
00:02:05,370 --> 00:02:09,918
Иногда случается так, что вам приходится

31
00:02:09,918 --> 00:02:14,790
много где объявлять функции,
передавать их куда-то,

32
00:02:14,790 --> 00:02:19,769
поэтому вы можете определить специальный
тип функции, например, так же,

33
00:02:19,769 --> 00:02:23,850
как и другие все типы, он определяется
при помощи ключевого слова type,

34
00:02:23,850 --> 00:02:29,092
дальше вы определяете имя этого типа,
ну и базовую переменную.

35
00:02:29,092 --> 00:02:32,994
В данном случае определение функции,

36
00:02:32,994 --> 00:02:37,354
сигнатура функции тоже может
выступать базовым типом.

37
00:02:37,354 --> 00:02:42,460
При этом вы можете указать как входящие
параметры, несколько входящих параметров,

38
00:02:42,460 --> 00:02:45,900
string, так и возвращаемые значения,

39
00:02:45,900 --> 00:02:51,550
string или даже вот так.

40
00:02:51,550 --> 00:02:53,230
Вот.

41
00:02:53,230 --> 00:02:56,790
То есть это корректное определение типа.

42
00:02:56,790 --> 00:02:57,322
Вот.

43
00:02:57,322 --> 00:03:01,687
Теперь давайте рассмотрим
следующий вариант,

44
00:03:01,687 --> 00:03:07,394
что мы можем передавать функцию,
как параметр, в другую функцию.

45
00:03:07,394 --> 00:03:13,390
Например, определим функцию worker,

46
00:03:13,390 --> 00:03:17,244
определим анонимную функцию и
положим ее в переменную worker,

47
00:03:17,244 --> 00:03:22,280
которая будет принимать переменную,
которая называется callback типа...

48
00:03:22,280 --> 00:03:23,812
какого-то типа.

49
00:03:23,812 --> 00:03:26,876
В данном случае мы его объявили выше,

50
00:03:26,876 --> 00:03:32,050
это какой-то строково-функциональный тип.

51
00:03:32,050 --> 00:03:34,955
Вот.
Ну и потом просто будут ее вызывать.

52
00:03:34,955 --> 00:03:36,820
В данном случае смотрите.

53
00:03:36,820 --> 00:03:40,731
Я объявил worker, и теперь я
передаю туда нашу функцию printer,

54
00:03:40,731 --> 00:03:43,867
которая будет выводить то,
что в нее напечатали.

55
00:03:43,867 --> 00:03:46,370
Давайте посмотрим, как это работает.

56
00:03:46,370 --> 00:03:51,213
Вот наша функция printer вывела,

57
00:03:51,213 --> 00:03:57,678
что в нее передали текст as callback,
то есть она была вызвана, как callback.

58
00:03:57,678 --> 00:04:00,420
Callback-и полезны,

59
00:04:00,420 --> 00:04:05,100
когда вы хотите выполнить какую-то функцию
по завершении какой-то работы или в

60
00:04:05,100 --> 00:04:10,090
зависимости от разных условий выполнить
разную логику какой-то другой функции.

61
00:04:10,090 --> 00:04:13,776
Теперь рассмотрим замыкание.

62
00:04:13,776 --> 00:04:20,138
Замыкание — это такая функция,
которая обращается к переменным,

63
00:04:20,138 --> 00:04:24,965
которые были объявлены вне ее блока,
вне ее объявления.

64
00:04:24,965 --> 00:04:27,033
То есть как это выглядит?

65
00:04:27,033 --> 00:04:30,520
Смотрите: я определяю функцию prefixer,

66
00:04:30,520 --> 00:04:35,268
которая принимает строчку prefix, да?

67
00:04:35,268 --> 00:04:40,640
И возвращает,
возвращает функцию определенного типа.

68
00:04:40,640 --> 00:04:46,460
И я определяю теперь эту
функцию — return func,

69
00:04:46,460 --> 00:04:51,237
я определяю входящий параметр,

70
00:04:51,237 --> 00:04:55,377
и теперь эта функция,
то есть я определяю функцию,

71
00:04:55,377 --> 00:05:00,650
которая будет мне выводить то, что в нее
передали, в каком-то отдельном формате.

72
00:05:00,650 --> 00:05:06,110
И самое интересное: она
будет использовать prefix,

73
00:05:06,110 --> 00:05:10,930
то есть переменная,
которая была объявлена не в контексте

74
00:05:10,930 --> 00:05:16,020
вот этом, в строчках 33‒35,

75
00:05:16,020 --> 00:05:20,298
а в более в контексте
более высокого уровня,

76
00:05:20,298 --> 00:05:25,060
то есть в строчках 32‒36.

77
00:05:25,060 --> 00:05:29,340
Это значит замыкание,
то есть функция замкнулась на что-то.

78
00:05:29,340 --> 00:05:32,493
Конечно, поскольку Go —
язык со сборщиком мусора,

79
00:05:32,493 --> 00:05:37,058
переменная prefix не удалится сразу,
как мы вернем значение,

80
00:05:37,058 --> 00:05:43,032
а будет существовать до тех пор,
пока кто-то использует эту переменную.

81
00:05:43,032 --> 00:05:45,943
Давайте посмотрим, как это работает.

82
00:05:45,943 --> 00:05:46,630
Смотрите.

83
00:05:46,630 --> 00:05:51,333
Я объявил функцию prefixer, которая
просто возвращает мне другую функцию,

84
00:05:51,333 --> 00:05:54,835
которая будет печатать с
определенным префиксом.

85
00:05:54,835 --> 00:05:59,530
То есть я вызвал функцию prefixer,
передал туда функцию SUCCESS,

86
00:05:59,530 --> 00:06:03,379
то есть «успех», и сказал,
что это теперь другая функция.

87
00:06:03,379 --> 00:06:07,846
И эту функцию, successlogger,
я вызвал с каким-то другим текстом,

88
00:06:07,846 --> 00:06:09,920
что «поведение ожидаемое».

89
00:06:09,920 --> 00:06:13,595
Давайте посмотрим, как это работает.

90
00:06:13,595 --> 00:06:14,135
Вот.

91
00:06:14,135 --> 00:06:18,374
То есть функция,
которую вернула мне другая функция,

92
00:06:18,374 --> 00:06:20,830
сейчас напечатала мне результат.

93
00:06:20,830 --> 00:06:26,710
Это бывает довольно удобно,
мы в практических примерах рассмотрим это.