[БЕЗ_ЗВУКА] В этом видео
мы рассмотрим функции, основной инструмент для декомпозиции
вашей программы на более простые блоки. Итак, функция в блок
объявляется через служебное слово func,
после которой следует имя функции, с скобочках параметра и
после возвращаемое значение. Результат из функции возвращается, используя оператор return,
как и в других языках, впрочем. При этом если у вас несколько
параметров одного типа, то вы можете объявить его только один раз,
а сами параметры указать через запятую. Либо же указывать тип для
каждого из параметров. В Go можно указывать сразу
возвращаемый результат, то есть сразу указывать переменную,
которая будет с возвращаемым результатом. При этом вы можете записать туда значение и написать пустой
return без имени этой переменной. И она вернет вам то, что вы записали. В данном случае это out. Впрочем вас никто не заставляет возвращать
именно out, вы можете написать, например, return 3, даже в таком
случае это будет корректная работа. В Go функции могут возвращать
несколько результатов. Чаще всего всего это используется для
возврата ошибки в качестве второго параметра. При этом параметров не обязательно может
быть два, их может быть три или более. Но очень многие служебные функции Go
из стандартной библиотеки возвращают как раз два параметра. При этом при написании return,
возвращаемого значения, вы должны каждый раз указывать
оба параметра через запятую. В данном случае я должен указать
сначала первый параметр in, потом второй параметр ошибку. На 26-й строчке я указываю возвращаемый
результат in и nil в качестве ошибки. Также вы можете вернуть несколько
именованных результатов. Для этого достаточно объявить у них имена. Еще раз напомню, что все
именованные возвращаемые результаты сразу инициализируются
значениями по умолчанию. То есть когда вы будете их возвращать,
будет возвращаться этот результат. Например, по умолчанию rez = 0,
и если я объявлю, положу туда какое-то значение,
например, rez = 1, то моя функция будет возвращать 1. Следовательно, если я присвою
что-то в ошибку на строчке 33, то это аналогично,
если бы я написал return rez, err. Что в общем-то опять-таки
никто не заставляет меня использовать именно
именованные результаты. Я могу вернуть сам 1 и ошибку. Ну и дальше я могу вернуть
что-то без ошибки. В Go функции могут принимать
неограниченное количество параметров, но только одно типа. Такие функции называются вариативными,
по английски variative. Для того чтобы так сделать,
нужно указать перед именем функции, перед именем параметра троеточие. В этом случае на вход, в данном случае
в переменную in, вам придет slice. slice int'ов,
по которым вы можете проитерироваться, используя цикл for range. Давайте посмотрим немножко,
как оно работает. Давайте вызовем
multiplenamedReturn с входным параметром true, вот эта функция. Если мы ее вызовем, то она вернет нам 1,
потому что мы указали 1 вот здесь. Мы в именованный параметр
присвоили значение 1. И когда мы написали return потом,
присвоив в err какую-то ошибку, оно написало нам, что тут было 1. Конечно, я могу написать и вот так, например, давайте сделаем не 1, а 3. И мне вернется 3. То есть я не должен использовать
именованный параметр обязательно, я могу вернуть какие-то
любые другие значения. Если же я передам в эту функцию false, то блок с ошибкой не выполнится, и в rez присвоится 2, и я верну 2 и nil. Вот, пожалуйста. Теперь давайте посмотрим на
использование вариативных параметров. Если бы я передал просто nums, у меня есть слайс nums,
если бы я передал сумму просто слайс, то компилятор в этом
случае будет ругаться, потому что это отдельный тип слайс. Это не какое-то количество
повторяющихся параметров одиночных, это отдельный тип слайс. В этом случае компилятор будет ругаться. Но иногда бывает надо передать как
раз-таки слайс как вариативный параметр, для этого используется
троеточие после имени слайса. Это распаковывает вам слайс в одиночные
аргументы, которые передаются функции. Давайте вызовем. Вот смотрите. Функция, она мне вывела
тип входящей переменной, то есть in — это пришел слайс,
то есть это фактически слайс. Ну и значение. Посчитала его и вернула. Ну я вывел в Println сам слайс и результат, их суммирование. Кстати, функция Println — как
раз-таки пример вариативной функции. Она принимает множество параметров и
выводит их в строковое представление.