1
00:00:00,000 --> 00:00:05,364
[БЕЗ_ЗВУКА] В

2
00:00:05,364 --> 00:00:10,550
этом видео мы рассмотрим такие
понятия как отложенное выполнение,

3
00:00:10,550 --> 00:00:14,620
панику и восстановление после паники.

4
00:00:14,620 --> 00:00:20,118
В Go есть возможность
отложенного выполнения функции.

5
00:00:20,118 --> 00:00:24,950
Это когда какая-то работа будет
выполнена после завершения функции.

6
00:00:24,950 --> 00:00:29,076
Чаще всего это используется,
когда вам нужно посчитать, например,

7
00:00:29,076 --> 00:00:35,058
время работы функции,
либо закрыть какой-то ресурс,

8
00:00:35,058 --> 00:00:38,560
например, сетевое соединение
либо файловый дескриптор.

9
00:00:38,560 --> 00:00:42,350
Причем если у вас много
условий и много returns,

10
00:00:42,350 --> 00:00:47,430
каждый раз руками писать это бывает не
очень удобно и довольно утомительно.

11
00:00:47,430 --> 00:00:52,778
Поэтому вы можете объявить один раз
отложенное выполнение на закрытие

12
00:00:52,778 --> 00:00:58,059
какого-то ресурса, сразу же после
открытия это делается, и забыть о нем.

13
00:00:58,059 --> 00:01:00,517
Давайте посмотрим, как это работает.

14
00:01:00,517 --> 00:01:02,910
Вот у нас есть функция, функция main.

15
00:01:02,910 --> 00:01:07,319
Вначале мы определяем,
что нужно выполнить какую-то

16
00:01:07,319 --> 00:01:11,976
функцию отложенную,
то есть не сейчас, а в конце.

17
00:01:11,976 --> 00:01:17,470
Определяется это через
ключевое слово defer,

18
00:01:17,470 --> 00:01:21,220
и потом вы уже должны написать
непосредственно одну строчку кода,

19
00:01:21,220 --> 00:01:26,030
которая будет выполнена,
то есть обычную функцию.

20
00:01:26,030 --> 00:01:30,398
В данном случае это было бы вот так.

21
00:01:30,398 --> 00:01:31,716
go run defer.

22
00:01:31,716 --> 00:01:37,077
То есть смотрите, after work вывелось
вначале, а потом some useful work.

23
00:01:37,077 --> 00:01:38,430
Добавляем defer.

24
00:01:38,430 --> 00:01:41,219
Выполняем еще раз и, смотрите,

25
00:01:41,219 --> 00:01:45,890
теперь after work выполнилось
уже в конце функции.

26
00:01:45,890 --> 00:01:52,233
При этом если вы используете
несколько отложенных функций,

27
00:01:52,233 --> 00:01:57,896
то они выполняются в порядке,
обратном их объявлению.

28
00:01:57,896 --> 00:02:03,307
В данном случае сначала выполнится second,
а потом обычное.

29
00:02:03,307 --> 00:02:07,920
Some useful work, second и обычное.

30
00:02:07,920 --> 00:02:12,777
Теперь стоит отметить такую вещь

31
00:02:12,777 --> 00:02:17,890
как аргументы,
которые передаются в эти функции.

32
00:02:17,890 --> 00:02:23,326
Дело в том, что аргументы в эти функции

33
00:02:23,326 --> 00:02:28,045
вычисляются на момент
объявления отложенной функции.

34
00:02:28,045 --> 00:02:30,267
Смотрите, как это работает.

35
00:02:30,267 --> 00:02:35,487
Представим, что у нас есть какая-то
функция, которая что-то возвращает.

36
00:02:35,487 --> 00:02:36,813
Например, вот так.

37
00:02:36,813 --> 00:02:37,780
GetSomeVars.

38
00:02:37,780 --> 00:02:43,243
Для того чтобы понять,
когда она была вызвана,

39
00:02:43,243 --> 00:02:46,596
я напечатал определенную строку.

40
00:02:46,596 --> 00:02:48,209
Теперь смотрите.

41
00:02:48,209 --> 00:02:50,230
Я хочу сделать вот так.

42
00:02:50,230 --> 00:02:53,790
То есть я говорю, что напечатай мне,

43
00:02:53,790 --> 00:02:57,510
пожалуйста, результат
выполнения вот этой функции.

44
00:02:57,510 --> 00:03:00,030
Давайте запустим и посмотрим, что будет.

45
00:03:00,030 --> 00:03:04,550
Смотрите.

46
00:03:04,550 --> 00:03:09,070
Сначала выполнилась GetSomeVars execution,

47
00:03:09,070 --> 00:03:14,550
то есть выполнилась вот эта функция,
потому что, повторюсь,

48
00:03:14,550 --> 00:03:21,559
аргументы отложенных функций
вычисляются при объявлении блока defer,

49
00:03:21,559 --> 00:03:25,460
не когда функция будет вызвана,
а при объявлении.

50
00:03:25,460 --> 00:03:29,197
То есть сначала выполнилась функция,

51
00:03:29,197 --> 00:03:35,561
которая вычисляет аргументы, потом
выполнилась какая-то полезная работа,

52
00:03:35,561 --> 00:03:40,257
потом только вывелся результат,
который вернула нам эта функция,

53
00:03:40,257 --> 00:03:43,840
GetSomeVars, и потом
вызвался первый блок defer.

54
00:03:43,840 --> 00:03:50,646
Иногда это бывает не очень удобно,
поэтому часто используется подход,

55
00:03:50,646 --> 00:03:56,998
когда мы объявляем анонимную функцию,
и она будет вызвана в конце.

56
00:03:56,998 --> 00:03:59,610
Например, смотрите.

57
00:03:59,610 --> 00:04:04,670
Func, вызов этой функции,

58
00:04:04,670 --> 00:04:10,619
и теперь я в ней вызову функцию
печати каких-то аргументов.

59
00:04:10,619 --> 00:04:12,850
Давайте посмотрим, к чему это привело.

60
00:04:12,850 --> 00:04:18,758
Смотрите, сначала
выполнилась полезная работа,

61
00:04:18,758 --> 00:04:23,837
вот эта, потом выполнился вот этот
блок defer, то есть уже внутри него

62
00:04:23,837 --> 00:04:28,776
выполнилась функция,
то есть она выполнилась в конце.

63
00:04:28,776 --> 00:04:33,830
Потом напечаталась вот эта строчка,
вернулся результат,

64
00:04:33,830 --> 00:04:39,110
напечатался результат в строчке 13,
и потом вызвался самый первый defer.

65
00:04:39,110 --> 00:04:44,450
Полезная работа,
выполнение и получение аргументов,

66
00:04:44,450 --> 00:04:48,650
печать аргументов, которые вернулись,
и самый первый defer.

67
00:04:48,650 --> 00:04:55,919
Конструкции с defer очень полезны
при восстановлении из паники.

68
00:04:55,919 --> 00:04:59,730
Сначала давайте рассмотрим,
что такое вообще паника.

69
00:04:59,730 --> 00:05:03,840
Представьте, у нас есть какая-то функция,
defer test.

70
00:05:03,840 --> 00:05:08,505
Она делает какую-то
работу и потом паникует.

71
00:05:08,505 --> 00:05:11,064
Паника это служебная функция,

72
00:05:11,064 --> 00:05:15,857
которая останавливает выполнение работы
программы, то есть вся программа крашится.

73
00:05:15,857 --> 00:05:17,590
Давайте посмотрим, как это работает.

74
00:05:17,590 --> 00:05:22,562
[БЕЗ_ЗВУКА] Смотрите,

75
00:05:22,562 --> 00:05:25,760
выполнилась какая-то полезная работа,

76
00:05:25,760 --> 00:05:31,040
потом вызвалась паника и
напечатался стек трейс.

77
00:05:31,040 --> 00:05:35,918
Дело в том, что паника вообще штука не

78
00:05:35,918 --> 00:05:41,429
очень хорошая,
и завершать работающий демон в продакшене,

79
00:05:41,429 --> 00:05:47,231
когда там еще много параллельных запросов
отрабатывается, не очень хорошо.

80
00:05:47,231 --> 00:05:50,800
Паника это абсолютно
исключительная ситуация.

81
00:05:50,800 --> 00:05:52,585
И как-то это надо отлавливать.

82
00:05:52,585 --> 00:05:54,890
Отлавливается она с помощью блока defer.

83
00:05:54,890 --> 00:05:57,435
Давайте я вам это продемонстрирую.

84
00:05:57,435 --> 00:06:01,790
Смотрите, сначала мы должны объявить,
собственно, блок,

85
00:06:01,790 --> 00:06:06,580
defer.

86
00:06:06,580 --> 00:06:11,570
Дело в том, что блок defer будет
выполнен все равно после функции,

87
00:06:11,570 --> 00:06:17,190
я вам это покажу.

88
00:06:17,190 --> 00:06:27,010
[БЕЗ_ЗВУКА] panic mode.

89
00:06:27,010 --> 00:06:31,680
Смотрите, in panic mode нам напечатался,
то есть defer работает.

90
00:06:31,680 --> 00:06:35,184
Как же теперь восстановиться после паники?

91
00:06:35,184 --> 00:06:41,560
У нас есть функция recover,
которая возвращает нам результат,

92
00:06:41,560 --> 00:06:45,977
ошибку, которая была вброшена паникой.

93
00:06:45,977 --> 00:06:52,830
Смотрите, recover, получаем ошибку.

94
00:06:52,830 --> 00:06:58,390
Теперь, если ошибка вообще была,

95
00:06:58,390 --> 00:07:05,455
err = nil [БЕЗ_ЗВУКА]

96
00:07:05,455 --> 00:07:12,251
[БЕЗ_ЗВУКА] Давайте

97
00:07:12,251 --> 00:07:16,530
теперь попробуем выполнить.

98
00:07:16,530 --> 00:07:23,542
Обратите внимание, наша программа
теперь завершилась корректно,

99
00:07:23,542 --> 00:07:27,850
то есть она не упала в панику, это значит,
что эта функция отработала корректно.

100
00:07:27,850 --> 00:07:31,810
То есть выполнилась какая-то
полезная работа и дальше мы

101
00:07:31,810 --> 00:07:34,570
успешно восстановились после паники.

102
00:07:34,570 --> 00:07:42,165
Это может вам показаться немножко
похожим на блок try-catch,

103
00:07:42,165 --> 00:07:47,170
но я это отмечу особо,
никогда не используйте

104
00:07:47,170 --> 00:07:51,150
панику и восстановление после паники
как эмуляцию блока try-catch.

105
00:07:51,150 --> 00:07:53,195
Они для этого не предназначены.

106
00:07:53,195 --> 00:07:56,336
Паника это абсолютная
исключительная ситуация,

107
00:07:56,336 --> 00:07:59,120
которая обычно приводит к краху программы.

108
00:07:59,120 --> 00:08:03,350
Она ловится для того чтобы другие запросы,

109
00:08:03,350 --> 00:08:06,780
которые выполняются этой программой,
не затронулись.

110
00:08:06,780 --> 00:08:12,130
Естественно, иногда бывает,
что в defer выводы случайно тоже

111
00:08:12,130 --> 00:08:17,790
упали в панику.

112
00:08:17,790 --> 00:08:21,750
Другие функции,
которые после этого выполняются,

113
00:08:21,750 --> 00:08:30,674
они могут поймать эту панику,

114
00:08:30,674 --> 00:08:38,065
но вообще бросать панику в восстановлении
это очень плохая практика.

115
00:08:38,065 --> 00:08:39,840
Давайте посмотрим.

116
00:08:39,840 --> 00:08:45,099
Смотрите, сначала

117
00:08:45,099 --> 00:08:49,840
я выполнил панику первый раз:
что-то плохое случилось.

118
00:08:49,840 --> 00:08:51,118
Да?
То есть текст,

119
00:08:51,118 --> 00:08:53,304
который я вот здесь запаниковал.

120
00:08:53,304 --> 00:08:55,350
Потом я запаниковал вот здесь.

121
00:08:55,350 --> 00:09:02,340
Этот блок обработался
следующим recover-ом.

122
00:09:02,340 --> 00:09:06,790
А если бы я не паниковал,

123
00:09:06,790 --> 00:09:10,640
то второй recover ничего бы не получил.

124
00:09:10,640 --> 00:09:13,192
Так работает паника.

125
00:09:13,192 --> 00:09:17,090
Пользуйтесь ею с осторожностью.