1
00:00:00,000 --> 00:00:08,428
[БЕЗ_ЗВУКА] В этом видео мы
рассмотрим управляющие структуры,

2
00:00:08,428 --> 00:00:11,710
благодаря которым вы сможете
делать всю логику вашей программы.

3
00:00:11,710 --> 00:00:14,707
Начнем мы с условного оператора.

4
00:00:14,707 --> 00:00:19,183
Условный оператор в if,
как и в других языках программирования,

5
00:00:19,183 --> 00:00:22,512
представлен конструкцией
if и условное выражение.

6
00:00:22,512 --> 00:00:26,755
А в качестве условия в Go может
быть только булевая переменная,

7
00:00:26,755 --> 00:00:31,574
поскольку в Go нет приведения типов
автоматически, то вы не можете, как,

8
00:00:31,574 --> 00:00:38,707
например, в C PHP, написать пустую строку
или ноль, чтобы ваше выражение прошло.

9
00:00:38,707 --> 00:00:42,583
Нет.
Вы должны четко свести это к условному

10
00:00:42,583 --> 00:00:43,824
выражению.

11
00:00:43,824 --> 00:00:49,729
Кроме того, кроме простых условий,
есть условие с блоком инициализации,

12
00:00:49,729 --> 00:00:54,094
где вы можете получить результат
какой-то функции, либо, например,

13
00:00:54,094 --> 00:00:59,530
получить значение существования
ключа в map'е, как на примере.

14
00:00:59,530 --> 00:01:03,934
После того как вы провели
блок инициализации,

15
00:01:03,934 --> 00:01:08,314
вы можете поставить точку с запятой
и уже там написать ваши выражения,

16
00:01:08,314 --> 00:01:11,550
которые будут проверяться для
выполнения этого условия.

17
00:01:11,550 --> 00:01:16,410
В данном случае мы проверяем,
что ключ существует или не существует.

18
00:01:16,410 --> 00:01:22,668
Также, если вам в данном
случае не нужно само значение,

19
00:01:22,668 --> 00:01:27,710
которое вы получаете,
а только проверка на существование ключа,

20
00:01:27,710 --> 00:01:30,668
то вы можете пропустить само значение,

21
00:01:30,668 --> 00:01:34,603
используя пустую переменную,
то есть символ подчеркивания так,

22
00:01:34,603 --> 00:01:37,460
чтобы компилятор Go не ругался
на неиспользуемую переменную.

23
00:01:37,460 --> 00:01:43,269
В Go также есть множественный if else,

24
00:01:43,269 --> 00:01:48,094
когда вы можете комбинировать их в одну
длинную цепочку, Это не всегда бывает

25
00:01:48,094 --> 00:01:53,140
удобно, поэтому в Go также в дополнение
к этому есть оператор switch.

26
00:01:53,140 --> 00:01:58,110
Оператор switch может
работать по одной переменной,

27
00:01:58,110 --> 00:02:00,849
и в блоке case вы будете
указывать условия,

28
00:02:00,849 --> 00:02:05,990
которым должна удовлетворять
эта переменная.

29
00:02:05,990 --> 00:02:07,754
Но есть нюансы.

30
00:02:07,754 --> 00:02:12,853
Во-первых, нюанс, что в отличие,
например, от C, где по

31
00:02:12,853 --> 00:02:18,442
умолчанию в switch case у вас происходит
проваливание в следующее условие и вам

32
00:02:18,442 --> 00:02:24,091
нужно писать везде break, в Go такого нет,
и проваливание по умолчанию отсутствует.

33
00:02:24,091 --> 00:02:27,076
Вам, наоборот, нужно писать fallthrough,

34
00:02:27,076 --> 00:02:32,270
для того чтобы ваша программа
провалилась в следующее условие.

35
00:02:32,270 --> 00:02:37,708
Также в условиях, то есть в блоке case,

36
00:02:37,708 --> 00:02:41,700
может стоять не одно значение,
а несколько, перечисленные через запятые.

37
00:02:41,700 --> 00:02:47,052
Ну и конечно же, есть блок default,
который будет выполнен тогда,

38
00:02:47,052 --> 00:02:50,080
когда ни одно из этих
условий не применилось.

39
00:02:50,080 --> 00:02:56,320
Кроме выполнения switch

40
00:02:56,320 --> 00:03:01,852
по одной переменной,
можно использовать разные условия.

41
00:03:01,852 --> 00:03:06,532
Тогда этот оператор больше
похож на замену многим if else.

42
00:03:06,532 --> 00:03:13,100
Например, мы можем проверить, что либо
одно условие, либо другое выполняется.

43
00:03:13,100 --> 00:03:17,768
При этом в этих условиях будут
использованы совершенно разные переменные,

44
00:03:17,768 --> 00:03:20,290
то есть это будут совсем разные условия.

45
00:03:20,290 --> 00:03:26,325
Также иногда бывает
нужно вам выйти из case,

46
00:03:26,325 --> 00:03:29,760
завершить его где-то на середине.

47
00:03:29,760 --> 00:03:33,210
Для этого вы можете
использовать оператор break.

48
00:03:33,210 --> 00:03:40,048
Тогда вы не пройдете в следующее условие,
а выйдете из switch.

49
00:03:40,048 --> 00:03:44,920
В данном примере строчка 57
не будет выведена на экран,

50
00:03:44,920 --> 00:03:51,350
потому что у оператора break до нее мы
сказали, что, пожалуйста, не ходи дальше.

51
00:03:51,350 --> 00:03:52,298
Хватит.

52
00:03:52,298 --> 00:04:01,005
Но иногда бывает нужно, чтобы в операторе
switch вы завершили какой-то цикл.

53
00:04:01,005 --> 00:04:05,486
В этом случае вам нужно
указать метку этому циклу,

54
00:04:05,486 --> 00:04:10,519
в данном случае она находится на
строчке 51, и поставить эту метку

55
00:04:10,519 --> 00:04:15,190
после break,
как это сделано на строчке 60.

56
00:04:15,190 --> 00:04:19,502
Ну и раз уж мы заговорили про циклы,
давайте рассмотрим те циклы,

57
00:04:19,502 --> 00:04:20,740
которые есть в Go.

58
00:04:20,740 --> 00:04:26,370
Итак, циклы.

59
00:04:26,370 --> 00:04:30,442
В Go цикл представлен только
одной конструкцией for,

60
00:04:30,442 --> 00:04:34,723
но она может принимать
совершенно разные формы.

61
00:04:34,723 --> 00:04:41,158
Во-первых, есть конструкция, когда у
вас нет условия и это бесконечный цикл.

62
00:04:41,158 --> 00:04:45,252
Это аналог while(true) либо for (;;;).

63
00:04:45,252 --> 00:04:50,506
В этом случае вам этот цикл
нужно прервать самостоятельно.

64
00:04:50,506 --> 00:04:53,290
Для этого используется конструкция break.

65
00:04:53,290 --> 00:04:57,830
Следующим видом цикла является
цикл с одиночным условием.

66
00:04:57,830 --> 00:05:01,890
То есть цикл будет выполняться до тех пор,
пока это условие истинно.

67
00:05:01,890 --> 00:05:06,060
Это аналог while переменная.

68
00:05:06,060 --> 00:05:10,230
В данном случае у нас в строчке
14 как раз указан такой цикл.

69
00:05:10,230 --> 00:05:15,370
Он будет выполняться до тех пор,
пока переменная isRun = true.

70
00:05:15,370 --> 00:05:19,740
И в первой же итерации цикла
мы isRun устанавливаем false,

71
00:05:19,740 --> 00:05:23,068
и цикл завершает свою работу.

72
00:05:23,068 --> 00:05:27,922
Третьим вариантом цикла,
который указан на строчке 20,

73
00:05:27,922 --> 00:05:32,290
является классический for из C,
когда вы указываете блок инициализации,

74
00:05:32,290 --> 00:05:37,145
блок с условием и блок,
который выполняется после итерации цикла.

75
00:05:37,145 --> 00:05:42,165
Чаще всего там автоинкремент индекса,
по которому идет цикл.

76
00:05:42,165 --> 00:05:49,310
В данном случае мы выполняем
всего лишь две итерации.

77
00:05:49,310 --> 00:05:53,270
И если у нас i = 1 на строчке 22,

78
00:05:53,270 --> 00:05:57,280
то мы выполняем переход к
следующей итерации цикла.

79
00:05:57,280 --> 00:06:01,290
Для этого в Go есть
ключевое слово continue.

80
00:06:01,290 --> 00:06:11,210
Еще одним примером будет
операция по слайсам.

81
00:06:11,210 --> 00:06:15,010
Например, объявим слайс
на строчке 28 какой-то,

82
00:06:15,010 --> 00:06:19,080
и давайте попробуем
проитерироваться по нему.

83
00:06:19,080 --> 00:06:24,525
Самый простой способ — это
использовать одно условие,

84
00:06:24,525 --> 00:06:27,674
пока мы не дошли до конца.

85
00:06:27,674 --> 00:06:29,970
Это аналог while.

86
00:06:29,970 --> 00:06:36,370
Мы будем печатать значение, печатать
индекс и сами делать автоинкремент.

87
00:06:36,370 --> 00:06:41,469
Такое не очень удобно, поэтому гораздо

88
00:06:41,469 --> 00:06:48,398
чаще используется цикл с инициализацией,
с условием и операцией после цикла.

89
00:06:48,398 --> 00:06:52,751
В данном случае мы объявляем
в одной строчке индекс,

90
00:06:52,751 --> 00:06:56,370
условие и автоинкремент для этого индекса.

91
00:06:56,370 --> 00:07:01,996
Ну и четвертым типом цикла, который
есть в Go, это цикл с оператором range.

92
00:07:01,996 --> 00:07:07,785
Оператор range заменяет всю рутину,
как указать первоначальный индекс,

93
00:07:07,785 --> 00:07:11,695
указать условие,
указать инкремент для этого индекса,

94
00:07:11,695 --> 00:07:15,940
вам достаточно просто проитерироваться,
используя оператор range.

95
00:07:15,940 --> 00:07:20,180
Оператор range может вам
вернуть либо индекс,

96
00:07:20,180 --> 00:07:24,525
только индекс из этого слайса,

97
00:07:24,525 --> 00:07:28,870
и вы уже сами можете вывести у
него значение, например, вот так.

98
00:07:28,870 --> 00:07:34,075
Вот так вот.

99
00:07:34,075 --> 00:07:34,699
sl dx.

100
00:07:34,699 --> 00:07:40,623
Либо он может вам вернуть сразу
значение и индекса, и значение,

101
00:07:40,623 --> 00:07:46,289
и вам не придется уже обращаться
к самому элементу слайса.

102
00:07:46,289 --> 00:07:50,540
При этом происходит создание
копии этого значения.

103
00:07:50,540 --> 00:07:56,147
Также вы можете итерироваться
в цикле по map.

104
00:07:56,147 --> 00:08:02,721
Вы можете итерироваться
как только по ключам

105
00:08:02,721 --> 00:08:07,869
этой map и сами обращаться к ее значениям.

106
00:08:07,869 --> 00:08:10,976
В этом случае стоит заметить,

107
00:08:10,976 --> 00:08:15,719
что в map порядок включений не определен.

108
00:08:15,719 --> 00:08:20,895
Это значит,
что в разных запусках программы

109
00:08:20,895 --> 00:08:26,880
ключи в памяти во внутреннюю структуру map
могут располагаться совершенно по-разному.

110
00:08:26,880 --> 00:08:30,129
Это обусловлено особенностями реализации.

111
00:08:30,129 --> 00:08:34,560
То есть не ожидайте,
что ключи будут в map ровно в том порядке,

112
00:08:34,560 --> 00:08:36,350
в котором вы их добавляли.

113
00:08:36,350 --> 00:08:41,457
Также вы можете сразу проитерироваться

114
00:08:41,457 --> 00:08:46,650
по ключу и по значению из map,
также используя оператор range.

115
00:08:46,650 --> 00:08:50,455
Либо если вам ключ не нужен,
вы можете использовать, как всегда,

116
00:08:50,455 --> 00:08:57,760
пустую переменную — символ подчеркивания —
и итерироваться только по значениям map.

117
00:08:57,760 --> 00:09:02,360
Отдельно стоит отметить
итерирование по строке.

118
00:09:02,360 --> 00:09:06,858
Строка внутри себя
представляет слайс байт,

119
00:09:06,858 --> 00:09:10,065
но range для строки определен отдельно.

120
00:09:10,065 --> 00:09:14,285
Это значит, что,
итерируясь по строке по типу string,

121
00:09:14,285 --> 00:09:20,156
вы будете итерироваться не по байтам,
а уже по отдельным символам.

122
00:09:20,156 --> 00:09:25,289
И в том,
что вам возвращает range для строки,

123
00:09:25,289 --> 00:09:29,346
будет позиция, то есть номер,

124
00:09:29,346 --> 00:09:34,562
на котором находится ваш символ,
и непосредственно символ,

125
00:09:34,562 --> 00:09:38,620
то есть руна,
которую представляет собой utf-ный символ.

126
00:09:38,620 --> 00:09:44,310
В этом видео я рассказал вам
про управляющие структуры,

127
00:09:44,310 --> 00:09:46,939
которые будут жить в вашей программе.

128
00:09:46,939 --> 00:09:52,830
Это оператор if, оператор switch и циклы,
использующие ключевое слово for.