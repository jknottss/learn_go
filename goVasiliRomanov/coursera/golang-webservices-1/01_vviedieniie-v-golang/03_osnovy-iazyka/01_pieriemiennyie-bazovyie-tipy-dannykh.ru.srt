1
00:00:00,000 --> 00:00:05,808
[БЕЗ_ЗВУКА] В

2
00:00:05,808 --> 00:00:11,430
этом видео мы поговорим про
самые-самые основы языка — переменные.

3
00:00:11,430 --> 00:00:15,878
С переменными вы будете работать большую
часть своей программистской жизни,

4
00:00:15,878 --> 00:00:18,997
потому что программирование
в основном состоит в том,

5
00:00:18,997 --> 00:00:22,448
чтобы переложить данные из
одной переменной в другую.

6
00:00:22,448 --> 00:00:23,484
Итак, начнем.

7
00:00:23,484 --> 00:00:27,340
Переменная в go объявляется при
помощи ключевого слова var,

8
00:00:27,340 --> 00:00:31,675
после которой следует имя
переменной и тип переменной.

9
00:00:31,675 --> 00:00:36,010
При этом вы можете не указывать
значения по умолчанию,

10
00:00:36,010 --> 00:00:42,830
при этом вы можете не указывать
значения при инициализации,

11
00:00:42,830 --> 00:00:47,290
и тогда переменная будет
инициализирована значением по умолчанию.

12
00:00:47,290 --> 00:00:50,278
В данном случае для int это ноль.

13
00:00:50,278 --> 00:00:53,810
Это одна из основных особенностей go,

14
00:00:53,810 --> 00:00:59,500
потому что нет риска получить какую-то
неинициализированную переменную,

15
00:00:59,500 --> 00:01:04,760
в которой осталось что-то из предыдущей
области памяти, от предыдущего владельца.

16
00:01:04,760 --> 00:01:08,638
Итак, вы можете просто
объявить переменную через var,

17
00:01:08,638 --> 00:01:11,400
вы можете сразу присвоить ей значение.

18
00:01:11,400 --> 00:01:16,805
Для некоторых типов данных вы
можете пропустить указание типа,

19
00:01:16,805 --> 00:01:20,929
и компилятор определит
этот тип автоматически.

20
00:01:20,929 --> 00:01:24,411
В данном случае в
переменную num2 я кладу 20,

21
00:01:24,411 --> 00:01:27,330
и компилятор определяет, что это тип int.

22
00:01:27,330 --> 00:01:30,392
Далее, короткое объявление переменной.

23
00:01:30,392 --> 00:01:35,501
Иногда бывает так, что вам нужно
что-то вернуть из функции и очень не

24
00:01:35,501 --> 00:01:40,910
хочется писать имя и тип переменной,
которая там будет.

25
00:01:40,910 --> 00:01:44,040
Для этих целей в go есть
короткое объявление.

26
00:01:44,040 --> 00:01:47,890
Оно осуществляется при
помощи оператора :=.

27
00:01:47,890 --> 00:01:54,490
Однако используя короткое объявление, вы
можете объявить только новую переменную,

28
00:01:54,490 --> 00:01:58,913
то есть присвоить значение в
уже существующую переменную,

29
00:01:58,913 --> 00:02:01,695
используя этот оператор, вы не сможете.

30
00:02:01,695 --> 00:02:05,955
В данном случае, если я попробую выполнить
эту программу, компилятор ругнется,

31
00:02:05,955 --> 00:02:07,340
что нет новых переменных.

32
00:02:07,340 --> 00:02:12,015
Конечно, есть +1, есть постфиксный

33
00:02:12,015 --> 00:02:16,900
инкремент, но нет префиксного инкремента.

34
00:02:16,900 --> 00:02:21,480
На самом деле это базово
всё для переменных.

35
00:02:21,480 --> 00:02:23,348
Немножко про стиль.

36
00:02:23,348 --> 00:02:30,620
В go принят camelCase стиль,
under_score стиль не очень приветствуется.

37
00:02:30,620 --> 00:02:34,774
Если вы будете использовать какие-то
синтаксические анализаторы,

38
00:02:34,774 --> 00:02:36,510
то они могут на это ругаться.

39
00:02:36,510 --> 00:02:37,825
Привыкайте сразу.

40
00:02:37,825 --> 00:02:42,465
В go можно объявить сразу несколько
переменных через запятую и сразу же

41
00:02:42,465 --> 00:02:44,250
проинициализировать их.

42
00:02:44,250 --> 00:02:48,483
Можно присвоить им
значение после объявления.

43
00:02:48,483 --> 00:02:52,852
Также вы можете использовать
короткое присваивание для объявления

44
00:02:52,852 --> 00:02:57,630
нескольких переменных, однако хотя бы одна
из этих переменных должна быть новой.

45
00:02:57,630 --> 00:03:02,930
Например, если здесь я напишу height,
то компилятор будет ругаться,

46
00:03:02,930 --> 00:03:06,899
потому что ни одна из
этих переменных не новая.

47
00:03:06,899 --> 00:03:09,081
Если же одна из них новая,

48
00:03:09,081 --> 00:03:13,410
то уже существующим присвоится значение
и будет объявлена новая переменная.

49
00:03:13,410 --> 00:03:20,682
Итак, а теперь давайте рассмотрим,
какие еще есть типы данных.

50
00:03:20,682 --> 00:03:22,203
Мы начинали с int.

51
00:03:22,203 --> 00:03:25,540
int вообще платформозависимый тип в go.

52
00:03:25,540 --> 00:03:31,470
Он имеет разрядность либо 32 бита, либо 64
бита в зависимости от вашей операционки.

53
00:03:31,470 --> 00:03:36,220
int, конечно, выбирается автоматически.

54
00:03:36,220 --> 00:03:41,715
Если вас не устраивает разрядность
или вы хотите большего контроля, то

55
00:03:41,715 --> 00:03:47,210
в go поддержка от int8 до int64, которая
позволяет хранить очень большие значения.

56
00:03:47,210 --> 00:03:54,006
Есть беззнаковый int — uint,
он тоже может быть платформозависимым.

57
00:03:54,006 --> 00:03:58,130
Если опять-таки платформозависимость
вас не устраивает,

58
00:03:58,130 --> 00:04:04,084
к вашим услугам от uint8 до uint64
Числа с плавающей точкой представлены

59
00:04:04,084 --> 00:04:09,720
как одинарной точности float 32,
так и двойной точности.

60
00:04:09,720 --> 00:04:13,709
Для них тоже есть автоподстановка типа,
автоугадывание типа,

61
00:04:13,709 --> 00:04:17,200
для них тоже есть значение по
умолчанию — это тоже ноль.

62
00:04:17,200 --> 00:04:19,504
Булевая переменная.

63
00:04:19,504 --> 00:04:23,442
В булевых переменных
значение по умолчанию ноль,

64
00:04:23,442 --> 00:04:26,180
и оно тоже может
угадываться автоматически.

65
00:04:26,180 --> 00:04:27,503
Ничего нового.

66
00:04:27,503 --> 00:04:30,340
В go есть комплексные переменные.

67
00:04:30,340 --> 00:04:35,122
Один из создателей языка очень хотел,
чтобы они там были,

68
00:04:35,122 --> 00:04:38,727
но на практике мне их использовать
никогда не приходилось.

69
00:04:38,727 --> 00:04:41,010
Однако вдруг вам они могут быть полезны,

70
00:04:41,010 --> 00:04:43,670
и в go есть полный набор
функций для работы с ними.

71
00:04:43,670 --> 00:04:44,500
Строки.

72
00:04:44,500 --> 00:04:51,250
Строки — это очень важный тип данных,
вы будете очень много с ним работать.

73
00:04:51,250 --> 00:04:56,960
По умолчанию для строки
— это пустая строка.

74
00:04:56,960 --> 00:05:00,880
Строка объявляется в двойных кавычках,

75
00:05:00,880 --> 00:05:06,076
и при этом внутри этих двойных
кавычек могут быть спецсимволы,

76
00:05:06,076 --> 00:05:10,538
такие как перенос строки
либо символ табуляции.

77
00:05:10,538 --> 00:05:13,615
Если же вы хотите писать как есть,

78
00:05:13,615 --> 00:05:19,007
то вы можете использовать backtick'и,
обратные кавычки,

79
00:05:19,007 --> 00:05:25,160
и символ новой строки либо табуляции там
будет прямо, как мы описали, слэш n.

80
00:05:25,160 --> 00:05:30,412
В go строки из коробки поддерживают UTF-8,
поэтому вы можете

81
00:05:30,412 --> 00:05:35,790
там писать на практически любых алфавитах,
на русском, в данном случае на китайском.

82
00:05:35,790 --> 00:05:40,000
Одинарные кавычки в go
используются для символов byte,

83
00:05:40,000 --> 00:05:46,840
который является по сути
alias'ом для uint8.

84
00:05:46,840 --> 00:05:52,150
Либо же для rune, который представляет
собой полноценный UTF-8 символ.

85
00:05:52,150 --> 00:05:56,298
Внутри это uint32.

86
00:05:56,298 --> 00:06:00,671
Итак, строки в go вы можете компилировать,

87
00:06:00,671 --> 00:06:05,631
то есть соединять между собой
при помощи оператора плюс.

88
00:06:05,631 --> 00:06:11,400
Однако строки в go незаменяемы, вы не
можете заменить там какой-то один символ.

89
00:06:11,400 --> 00:06:16,340
Вот в данном случае
программа будет ругаться.

90
00:06:16,340 --> 00:06:19,364
Если вы попробуете получить длину строки,

91
00:06:19,364 --> 00:06:24,030
используя встроенную функцию len,
то вы получите длину в байтах.

92
00:06:24,030 --> 00:06:30,290
Иногда это может запутать,
потому что это не символы.

93
00:06:30,290 --> 00:06:35,544
Если там лежит внутри utf, то один символ
может занимать больше одного байта.

94
00:06:35,544 --> 00:06:38,480
Если же вы хотите получить
именно количество символов,

95
00:06:38,480 --> 00:06:42,900
вам придется воспользоваться специальной
функцией RunCountInString из пакета utf8.

96
00:06:42,900 --> 00:06:49,122
Также вы можете получить часть строки,

97
00:06:49,122 --> 00:06:53,030
подстроку, используя оператор срез.

98
00:06:53,030 --> 00:06:57,230
Вы можете получить,
начиная с какого байта и по какой байт.

99
00:06:57,230 --> 00:07:01,199
Еще одной особенностью строк является то,

100
00:07:01,199 --> 00:07:07,687
что их можно конвертировать в слайс байт,
про слайс мы поговорим дальше, и обратно.

101
00:07:07,687 --> 00:07:10,670
Из слайс байт вы можете
конвертировать в строку.

102
00:07:10,670 --> 00:07:16,070
Иногда это бывает очень полезно и удобно.

103
00:07:16,070 --> 00:07:17,331
А теперь константа.

104
00:07:17,331 --> 00:07:22,392
Константа в go определяется при помощи
ключевого слова const, после которой

105
00:07:22,392 --> 00:07:28,120
идет имя переменной,
имя этой константы и опционально ее тип.

106
00:07:28,120 --> 00:07:33,290
При этом вы можете объявить
сразу блок констант,

107
00:07:33,290 --> 00:07:38,410
то есть не указывая ключевое
слово перед каждой константой.

108
00:07:38,410 --> 00:07:42,470
Еще в go есть очень полезная вещь,
называется iota.

109
00:07:42,470 --> 00:07:46,180
iota — это такой
автоинкремент для константы.

110
00:07:46,180 --> 00:07:51,497
Довольно часто бывают случаи,
когда вам надо объявить пачку констант,

111
00:07:51,497 --> 00:07:54,470
которые отличаются между собой на единицу.

112
00:07:54,470 --> 00:07:59,180
Например, значения битов
в какой-то битовой маске.

113
00:07:59,180 --> 00:08:02,410
Автоинкремент тут очень кстати.

114
00:08:02,410 --> 00:08:06,542
Вы указываете iota на первом месте,

115
00:08:06,542 --> 00:08:11,088
а дальше вам не нужно указывать ничего,

116
00:08:11,088 --> 00:08:17,410
в данном случае константа
3 объявилась через iota.

117
00:08:17,410 --> 00:08:21,384
Если вам нужно пропустить
вдруг какую-то константу,

118
00:08:21,384 --> 00:08:26,220
вы можете использовать символом
подчеркивания, это в go пустая переменная,

119
00:08:26,220 --> 00:08:31,050
которая говорит, что, да, здесь должно
быть значение, но мы его проигнорируем.

120
00:08:31,050 --> 00:08:37,538
При этом iota может
выступать не только каким-то

121
00:08:37,538 --> 00:08:42,620
простым автоинкрементом, но и
участвовать в математических выражениях.

122
00:08:42,620 --> 00:08:46,967
Вот, например, в данном случае константа

123
00:08:46,967 --> 00:08:51,620
мегабайт определяется тоже через iota,

124
00:08:51,620 --> 00:08:57,500
используя то выражение,
которое я написал в определении килобайта.

125
00:08:57,500 --> 00:09:02,780
Еще одной особенностью go является то,

126
00:09:02,780 --> 00:09:07,880
что нетипизированная константа,
которой вы не объявили тип сами,

127
00:09:07,880 --> 00:09:11,170
она так и остается
внутри нетипизированной.

128
00:09:11,170 --> 00:09:15,440
И может в нужное место
подставиться уже с нужным типом.

129
00:09:15,440 --> 00:09:20,540
За счет этого, например,
константы в go иметь

130
00:09:20,540 --> 00:09:25,620
целочисленные значения,
значительно превышающие 64 бита.

131
00:09:25,620 --> 00:09:30,156
Но вот в данном случае у меня есть

132
00:09:30,156 --> 00:09:34,950
переменная «месяц»,
которая имеет тип int32.

133
00:09:34,950 --> 00:09:41,811
Я могу добавить к ней год, year,
потому что это нетипизированная константа.

134
00:09:41,811 --> 00:09:45,514
При этом если я попробую добавить
типизированную константу,

135
00:09:45,514 --> 00:09:50,866
то компилятор заругается, что так нельзя,
надо преобразовывать тип.

136
00:09:50,866 --> 00:09:53,770
Итак, определение типов.

137
00:09:53,770 --> 00:09:58,316
В go вы можете определять собственные
типы, либо основываясь на каких-то базовых

138
00:09:58,316 --> 00:10:02,590
примитивах, либо используя
более сложные конструкции,

139
00:10:02,590 --> 00:10:07,949
такие как структуры,
о которых мы будем говорить отдельно.

140
00:10:07,949 --> 00:10:14,168
Тип очень полезно А определять, если вы
хотите моделировать уже какие-то сущности.

141
00:10:14,168 --> 00:10:16,470
В данном случае у меня тип UserID.

142
00:10:16,470 --> 00:10:18,812
Особенностью Go является то,

143
00:10:18,812 --> 00:10:24,854
что здесь нет никакого автоматического
приведения типов никуда.

144
00:10:24,854 --> 00:10:30,414
И для того чтобы привести какую-то

145
00:10:30,414 --> 00:10:35,320
переменную базового типа к другому типу,

146
00:10:35,320 --> 00:10:39,430
который тоже основан на базовом типе,

147
00:10:39,430 --> 00:10:45,955
мне придётся сделать конвертацию,
в данном случае это типы совместимые,

148
00:10:45,955 --> 00:10:52,693
я могу, используя объявление типа и
скобки, привести его к нужному мне UserID.

149
00:10:52,693 --> 00:11:00,220
То есть idx у меня типа int,
а myID будет тип UserID.

150
00:11:00,220 --> 00:11:05,480
Также вы можете конвертировать
простые int'ы между собой,

151
00:11:05,480 --> 00:11:10,010
или, как я уже показывал,
строку со слайсом байт.

152
00:11:10,010 --> 00:11:13,920
...данных, про которые мы поговорим,
это указатели.

153
00:11:13,920 --> 00:11:19,482
Начать надо с того,
что в Go нет адресной арифметики.

154
00:11:19,482 --> 00:11:24,300
Вы не можете прибавить какое-то
значение к указателю и получить

155
00:11:24,300 --> 00:11:28,430
указатель на другую область памяти.

156
00:11:28,430 --> 00:11:31,670
В Go указатель — это отдельный тип данных.

157
00:11:31,670 --> 00:11:32,981
Что это значит?

158
00:11:32,981 --> 00:11:38,695
Это значит, что если вы объявляете
какую-то переменную как указатель

159
00:11:38,695 --> 00:11:44,780
на другую, то внутри этой
переменной будет лежать значение

160
00:11:44,780 --> 00:11:49,810
адреса на другую переменную.

161
00:11:49,810 --> 00:11:53,000
То есть это не является
полноценной ссылкой,

162
00:11:53,000 --> 00:11:57,430
которая указывает ровно туда же,
куда и основная переменная.

163
00:11:57,430 --> 00:12:02,810
Итак, в данном случае я
объявляю переменную a,

164
00:12:02,810 --> 00:12:07,267
и в переменную b я кладу указатель на a.

165
00:12:07,267 --> 00:12:13,270
Теперь я могу положить внутрь значение,
которое лежит за b,

166
00:12:13,270 --> 00:12:18,210
используя оператор *, я могу положить 3,
и внутри a значение изменится.

167
00:12:18,210 --> 00:12:23,310
Через c я создам новый указатель на a.

168
00:12:23,310 --> 00:12:28,340
Если же вам нужно

169
00:12:28,340 --> 00:12:34,027
создать указатель на какой-то тип данных,
что часто используют, например,

170
00:12:34,027 --> 00:12:39,105
в структурах, то вы можете
использовать ключевое слово int,

171
00:12:39,105 --> 00:12:45,392
точнее встроенную функцию int,
которая создаст вам

172
00:12:45,392 --> 00:12:50,780
переменную нужного типа,
заполнит её значением по умолчанию,

173
00:12:50,780 --> 00:12:56,920
что важно, у вас там не будет мусора,
и вернёт вам указатель на эту переменную.

174
00:12:56,920 --> 00:12:59,261
Теперь в данном случае...

175
00:12:59,261 --> 00:13:02,858
Итак, я сделал, получив указатель на int.

176
00:13:02,858 --> 00:13:06,480
Теперь я могу изменить какое-то значение.

177
00:13:06,480 --> 00:13:10,291
Также я могу в c, в значение,

178
00:13:10,291 --> 00:13:16,147
которое лежит за c, положить значение,
которое лежит внутри d.

179
00:13:16,147 --> 00:13:23,601
И, таким образом, переменная a, указателем
на которую является c, она изменится.

180
00:13:23,601 --> 00:13:31,210
При этом теперь я меняю d,
и c и a уже не меняются,

181
00:13:31,210 --> 00:13:36,108
потому что c указывает

182
00:13:36,108 --> 00:13:40,777
на a,
а не становится сразу же ссылкой на d.

183
00:13:40,777 --> 00:13:46,587
Однако теперь дальше я говорю,
что c теперь — указатель на d,

184
00:13:46,587 --> 00:13:54,160
точнее в c теперь находится тот же
указатель, который находится внутри d.

185
00:13:54,160 --> 00:13:57,987
И если я изменю c, изменю значение,

186
00:13:57,987 --> 00:14:02,148
которое лежит за c, то изменится значение,

187
00:14:02,148 --> 00:14:07,640
которое лежит внутри d, но не значение,
которое лежит внутри a.

188
00:14:07,640 --> 00:14:12,262
Работа с указателями —
довольно важная часть в Go,

189
00:14:12,262 --> 00:14:18,140
но вы ознакомитесь с ней
уже во время практики.