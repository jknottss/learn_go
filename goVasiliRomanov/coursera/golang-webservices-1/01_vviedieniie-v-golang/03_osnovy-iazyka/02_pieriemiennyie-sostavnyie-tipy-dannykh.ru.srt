1
00:00:00,000 --> 00:00:05,084
[БЕЗ_ЗВУКА] В

2
00:00:05,084 --> 00:00:09,970
это видео мы проговорим уже
про более сложный тип данных.

3
00:00:09,970 --> 00:00:13,599
И начнем мы с массива.

4
00:00:13,599 --> 00:00:21,931
Массив — это какой-то набор из
нескольких данных, одного типа.

5
00:00:21,931 --> 00:00:26,516
Особенностью массивов в Go является то,

6
00:00:26,516 --> 00:00:30,212
что размер массива —
это часть типа данных.

7
00:00:30,212 --> 00:00:31,467
Что это значит?

8
00:00:31,467 --> 00:00:36,827
Это значит, что массив размерностью
2 и массив размерностью 3

9
00:00:36,827 --> 00:00:43,400
— это два совершенно разных типа
данных и они между собой несовместимы.

10
00:00:43,400 --> 00:00:49,482
Причем размерность массива
задается при компиляции,

11
00:00:49,482 --> 00:00:52,290
она не может быть изменена динамически.

12
00:00:52,290 --> 00:00:54,923
Как объявляется массив?

13
00:00:54,923 --> 00:01:00,860
Массив объявляется,
используя квадратные скобки,

14
00:01:00,860 --> 00:01:04,554
в которых указан его размер,

15
00:01:04,554 --> 00:01:10,194
и потом тип данных,
который находится внутри этого массива.

16
00:01:10,194 --> 00:01:13,860
Вот в данном случае я создам
массив из трех элементов,

17
00:01:13,860 --> 00:01:18,693
под них сразу же будет выделена память,
и эти элементы сразу же

18
00:01:18,693 --> 00:01:22,541
будут проинициализированы
значениями по умолчанию.

19
00:01:22,541 --> 00:01:23,860
Для int'а это 0.

20
00:01:23,860 --> 00:01:28,508
Я могу использовать константы для

21
00:01:28,508 --> 00:01:31,920
определения размера массива,
но не переменные.

22
00:01:31,920 --> 00:01:37,750
То есть написать вот так уже нельзя,

23
00:01:37,750 --> 00:01:40,590
компилятор будет ругаться.

24
00:01:40,590 --> 00:01:44,510
Еще можно определить
массив при инициализации.

25
00:01:44,510 --> 00:01:48,872
То есть я могу указать три точки,
это значит, что возьми столько элементов,

26
00:01:48,872 --> 00:01:51,502
сколько я тебе скажу, в фигурных скобках.

27
00:01:51,502 --> 00:01:55,750
И в фигурных скобках могу сразу
же инициализировать этот массив.

28
00:01:55,750 --> 00:01:59,150
В данном случае у меня
тут будет три элемента.

29
00:01:59,150 --> 00:02:06,440
Если же я попробую обратиться к массиву,
выходя за его пределы,

30
00:02:06,440 --> 00:02:11,163
то это будет проверено при инициализации.

31
00:02:11,163 --> 00:02:15,463
Если это константа,
и код просто не скомпилируется.

32
00:02:15,463 --> 00:02:22,090
Если же там будет такой id индекс,
то это будет проверено уже в run time,

33
00:02:22,090 --> 00:02:26,840
и программа завершится паникой.

34
00:02:26,840 --> 00:02:31,953
Итак, поскольку мы

35
00:02:31,953 --> 00:02:37,145
не всегда знаем,
какого размера точно нам нужен

36
00:02:37,145 --> 00:02:42,326
массив и мы никак не можем это
определить в run time, то массив

37
00:02:42,326 --> 00:02:47,100
— это довольно низкоуровневый тип данных,
он используется не очень часто.

38
00:02:47,100 --> 00:02:49,500
Гораздо чаще используется другой тип,

39
00:02:49,500 --> 00:02:52,740
который основывается на
массиве и называется он слайс.

40
00:02:52,740 --> 00:02:56,291
Итак, слайсы.

41
00:02:56,291 --> 00:03:02,145
Слайс — это чуть-чуть более
сложная структура данных,

42
00:03:02,145 --> 00:03:08,825
чем массив,
потому что у слайса есть его длина,

43
00:03:08,825 --> 00:03:15,040
то есть то количество элементов,
которое там уже есть.

44
00:03:15,040 --> 00:03:20,771
И capacity,
то есть то количество элементов,

45
00:03:20,771 --> 00:03:26,920
которое влезет еще в этот слайс без
аллоцирования дополнительной памяти.

46
00:03:26,920 --> 00:03:35,610
Для начала рассмотрим
просто создание слайса.

47
00:03:35,610 --> 00:03:39,090
Слайс можно создать,

48
00:03:39,090 --> 00:03:44,000
просто не указывая размерность
в квадратных скобках.

49
00:03:44,000 --> 00:03:45,964
Очень похоже на массив.

50
00:03:45,964 --> 00:03:48,870
Такое писать вы будете очень часто.

51
00:03:48,870 --> 00:03:54,145
В данном случае на этой строчке я
создам совершенно пустой слайс,

52
00:03:54,145 --> 00:03:59,570
у него не будет ни длины, ни capacity,
он не инициализирован, там nil внутри.

53
00:03:59,570 --> 00:04:03,710
Следующим образом я создаю пустой слайс,

54
00:04:03,710 --> 00:04:07,347
который уже инициализирован,
но у которого значения по-прежнему нет.

55
00:04:07,347 --> 00:04:08,800
Длина его 0, и capacity 0.

56
00:04:08,800 --> 00:04:13,330
Могу инициализировать чем-то сразу.

57
00:04:13,330 --> 00:04:18,380
В данном случае я кладу туда 42,
и под это сразу выделяется

58
00:04:18,380 --> 00:04:24,630
массив размерностью 1 элемент,
то есть его длина 1 и capacity тоже 1.

59
00:04:24,630 --> 00:04:31,196
Но гораздо чаще используется
встроенная функция make,

60
00:04:31,196 --> 00:04:36,631
которая создает массив нужной
размерности и capacity.

61
00:04:36,631 --> 00:04:44,522
Например, make слайс int'ов 0 создает
мне вообще совсем пустой слайс.

62
00:04:44,522 --> 00:04:47,580
То есть у него нет ни значений,

63
00:04:47,580 --> 00:04:51,423
ни какой-нибудь памяти под
него не инициализировано.

64
00:04:51,423 --> 00:04:55,513
Однако если я укажу тут
5 вторым параметром,

65
00:04:55,513 --> 00:05:00,601
то я уже создам слайс,
который будет проинициализирован

66
00:05:00,601 --> 00:05:05,084
пятью элементами, которые конечно же,
будут иметь значения по умолчанию.

67
00:05:05,084 --> 00:05:07,240
При этом capacity будет являться также 5.

68
00:05:07,240 --> 00:05:10,908
И я могу указать сразу capacity,

69
00:05:10,908 --> 00:05:16,410
то есть сразу размерность
нижележащего массива,

70
00:05:16,410 --> 00:05:22,310
уже на слайс, на который ссылается
этот слайс этой области памяти.

71
00:05:22,310 --> 00:05:25,643
Это очень полезно, если вдруг вы знаете,

72
00:05:25,643 --> 00:05:29,170
сколько элементов у вас
будет в этом слайсе.

73
00:05:29,170 --> 00:05:34,680
Например, вы создаете
слайс из нуля элементов,

74
00:05:34,680 --> 00:05:39,590
но вы сразу аллоцируете память для

75
00:05:39,590 --> 00:05:43,700
десяти элементов.

76
00:05:43,700 --> 00:05:48,270
Это очень положительно сказывается
на быстродействии программы,

77
00:05:48,270 --> 00:05:53,192
потому что если вы доходите

78
00:05:53,192 --> 00:05:58,096
до конца, если вы упираетесь в capacity,

79
00:05:58,096 --> 00:06:03,140
то тогда ваша программа
выделит новую область памяти,

80
00:06:03,140 --> 00:06:09,339
вдвое большего размера, и скопирует туда
все значения из одной области в другую.

81
00:06:09,339 --> 00:06:12,850
А старые значения уберется
уже сборщиком мусора.

82
00:06:12,850 --> 00:06:18,115
Итак, обращаться к элементам слайса
можно также через квадратные скобки,

83
00:06:18,115 --> 00:06:19,250
как к массивам.

84
00:06:19,250 --> 00:06:22,975
При этом если вдруг вы
обратитесь к элементу,

85
00:06:22,975 --> 00:06:26,420
который выходит за границы этого слайса,

86
00:06:26,420 --> 00:06:31,410
то выкинетеся run time паника.

87
00:06:31,410 --> 00:06:34,439
Итак, добавление элементов.

88
00:06:34,439 --> 00:06:38,370
Для того чтобы добавить элемент в слайс,

89
00:06:38,370 --> 00:06:43,936
есть специальная функция append,
первым параметром которой

90
00:06:43,936 --> 00:06:49,390
передается сам слайс, а далее идут
значения, которые вы хотите добавить.

91
00:06:49,390 --> 00:06:53,730
Вот в данном случае у нас
сначала там нет ничего,

92
00:06:53,730 --> 00:06:58,540
после в массив в слайс

93
00:06:58,540 --> 00:07:03,151
добавлено два элемента — 9 и 10.

94
00:07:03,151 --> 00:07:08,160
И теперь я на следующей строчке
добавляю туда еще один элемент,

95
00:07:08,160 --> 00:07:13,857
и уже capacity у меня становится не 3,
а 4, потому

96
00:07:13,857 --> 00:07:20,730
что при увеличении размерности run time
просто делает x2 от предыдущего размера.

97
00:07:20,730 --> 00:07:26,260
Если у вас есть слайс,
вы хотите его домержить в текущий слайс,

98
00:07:26,260 --> 00:07:31,050
то для этого есть специальный
оператор троеточие, Дело в том,

99
00:07:31,050 --> 00:07:35,725
что если бы мы написали вот так,
то получилось,

100
00:07:35,725 --> 00:07:43,294
что в первоначальный слайс мы бы захотели
добавить уже не int'ы, а другой слайс.

101
00:07:43,294 --> 00:07:46,980
Это получаются несовместимые типы данных.

102
00:07:46,980 --> 00:07:51,388
Поэтому для того чтобы
добавить туда элементы

103
00:07:51,388 --> 00:07:55,850
другого слайса, используется троеточие.

104
00:07:55,850 --> 00:07:59,855
Ну и какие-то данные о
слайсе вы можете получить,

105
00:07:59,855 --> 00:08:03,850
используя встроенную функцию len,
которая говорит вам длину массива,

106
00:08:03,850 --> 00:08:08,860
то есть сколько там уже элементов,
и функцию cap, capacity,

107
00:08:08,860 --> 00:08:13,075
которая говорит,
сколько памяти аллоцировано.

108
00:08:13,075 --> 00:08:17,983
То есть len — это, условно говоря,
вот это, а capacity — это может

109
00:08:17,983 --> 00:08:22,451
быть вот столько,
то есть сколько всего туда может влезть,

110
00:08:22,451 --> 00:08:27,520
до того как будет аллоцирована еще память,
до того как слайс

111
00:08:27,520 --> 00:08:32,950
будет расширен.

112
00:08:32,950 --> 00:08:37,941
Еще одной особенностью слайса является то,

113
00:08:37,941 --> 00:08:43,060
что вы можете взять какой-то кусок его,

114
00:08:43,060 --> 00:08:48,480
который будет ссылаться ровно
на ту же область памяти,

115
00:08:48,480 --> 00:08:52,920
на которую ссылается оригинальный слайс.

116
00:08:52,920 --> 00:08:59,030
Вот в данном примере у меня объявлен
слайс из пяти элементов от 1 до 5.

117
00:08:59,030 --> 00:09:04,192
Для того чтобы взять уже именно...

118
00:09:04,192 --> 00:09:09,159
Это как раз и называется слайс,
получение среза.

119
00:09:09,159 --> 00:09:12,417
Для того чтобы получить элементы,

120
00:09:12,417 --> 00:09:18,169
сослаться на какую-то его часть,
вы можете в квадратных скобках указать,

121
00:09:18,169 --> 00:09:22,040
с какого по какой элемент не
включительно вы хотите сослаться.

122
00:09:22,040 --> 00:09:27,420
В данном случае я ссылаюсь на середину,
при этом можно пропустить либо

123
00:09:27,420 --> 00:09:32,422
первое значение и сослаться от
нуля до в данном случае двойки,

124
00:09:32,422 --> 00:09:37,860
либо же пропустить второе значение
и сказать: вот отсюда и до конца.

125
00:09:37,860 --> 00:09:42,555
В этом есть очень

126
00:09:42,555 --> 00:09:46,580
важная особенность при работе со слайсами,
которую нужно понимать.

127
00:09:46,580 --> 00:09:50,153
Если вы ссылаетесь на
ту же область памяти,

128
00:09:50,153 --> 00:09:55,981
вот в данном случае я создал
новый слайс такой же размерности,

129
00:09:55,981 --> 00:10:01,030
указав «дай мне все»,
и я изменю там какое-либо значение,

130
00:10:01,030 --> 00:10:05,160
то изменится в обоих слайсах.

131
00:10:05,160 --> 00:10:10,840
Однако если я добавлю

132
00:10:10,840 --> 00:10:14,720
значение вот в этой новый слайс,

133
00:10:14,720 --> 00:10:20,330
то тогда произойдет увеличение
размерности этого слайса,

134
00:10:20,330 --> 00:10:26,480
потому что я создал слайс, у которого
capacity 5, и в нем лежит 5 элементов.

135
00:10:26,480 --> 00:10:31,180
Если я добавлю туда 6-й элемент,
то слайс должен будет расшириться,

136
00:10:31,180 --> 00:10:32,450
а что это значит?

137
00:10:32,450 --> 00:10:38,538
Это значит, что создастся другая область
памяти, и туда скопируются значения,

138
00:10:38,538 --> 00:10:43,290
то есть он уже будет ссылаться
на другую область памяти.

139
00:10:43,290 --> 00:10:49,048
И теперь если я поменяю какое-то значение,

140
00:10:49,048 --> 00:10:53,540
то оно то оно

141
00:10:53,540 --> 00:10:57,930
изменится уже в новом слайсе,
а в старом не изменится.

142
00:10:57,930 --> 00:11:02,660
Это очень важная особенность,
поиграйтесь с примером,

143
00:11:02,660 --> 00:11:06,246
посмотрите, как оно работает.

144
00:11:06,246 --> 00:11:09,886
Теперь еще момент копирования слайса.

145
00:11:09,886 --> 00:11:14,852
Иногда бывает нужно скопировать
один слайс в другой: не создать

146
00:11:14,852 --> 00:11:19,790
именно ссылку на ту же область памяти,
а именно честно скопировать.

147
00:11:19,790 --> 00:11:23,432
Вот такой способ неправильный,
как я показываю,

148
00:11:23,432 --> 00:11:28,249
когда вы просто создаете вообще пустой
слайс и вызываете функцию копии.

149
00:11:28,249 --> 00:11:31,362
Да, копии, конечно же, копируют элементы.

150
00:11:31,362 --> 00:11:32,260
Почему?

151
00:11:32,260 --> 00:11:38,807
Потому что она копирует в уже
существующий, уже в занятые элементы,

152
00:11:38,807 --> 00:11:43,213
то есть то,
что показывает нам переменная len.

153
00:11:43,213 --> 00:11:48,660
В данном случае len для этого слайса
равна 0, и мы ничего не скопируем.

154
00:11:48,660 --> 00:11:53,634
Для того чтобы скопировать полноценно,

155
00:11:53,634 --> 00:11:59,707
нам нужно создать новый слайс,
такой же размерности и такой же длины,

156
00:11:59,707 --> 00:12:06,145
сразу [НЕРАЗБОРЧИВО] с данными,
и уже скопировать в него.

157
00:12:06,145 --> 00:12:10,200
Тогда это будет правильный вариант,
вы получите ожидаемое поведение.

158
00:12:10,200 --> 00:12:18,120
Еще копии может копировать — это не
обязательно должна быть переменная,

159
00:12:18,120 --> 00:12:23,938
это может быть срез, слайс,
который вы только что получили,

160
00:12:23,938 --> 00:12:27,390
который ссылается на какую-то
другую область памяти,

161
00:12:27,390 --> 00:12:31,955
то есть на другой слайс,
на часть другого слайса.

162
00:12:31,955 --> 00:12:38,839
Это очень полезный трюк, когда вам
нужно сначала записать длину данных,

163
00:12:38,839 --> 00:12:43,820
а потом сами данные, при этом сами
данные — вы еще их размер не знаете,

164
00:12:43,820 --> 00:12:47,030
например, там какая-то бинарная упаковка.

165
00:12:47,030 --> 00:12:51,938
Поэтому вы пишете сначала нулевой размер,
потом пишете данные,

166
00:12:51,938 --> 00:12:55,176
а потом, используя вот такой трюк,

167
00:12:55,176 --> 00:13:01,159
вы пишете в это место,
в это место вы уже пишете длину.

168
00:13:01,159 --> 00:13:04,800
Слайсы очень широко используются в Go.

169
00:13:04,800 --> 00:13:08,165
Вы практически никогда не
будете использовать массивы,

170
00:13:08,165 --> 00:13:11,330
и практически всегда вы
будете использовать слайсы.

171
00:13:11,330 --> 00:13:17,895
Еще одним типом данных,
про которые мы поговорим — это map.

172
00:13:17,895 --> 00:13:22,200
map, он же хеш-таблица,
он же ассоциативный массив,

173
00:13:22,200 --> 00:13:26,270
он же сложное слово «отображение».

174
00:13:26,270 --> 00:13:34,291
map позволяет по ключу
быстро получить значение.

175
00:13:34,291 --> 00:13:38,882
Это очень удобно,
когда у вас значений довольно много.

176
00:13:38,882 --> 00:13:42,881
И если бы они лежали в слайсе,
вам бы пришлось все перебирать,

177
00:13:42,881 --> 00:13:46,114
а так вы сразу идете в нужное место.

178
00:13:46,114 --> 00:13:48,640
Как определяется map?

179
00:13:48,640 --> 00:13:51,090
При помощи ключевого слова map,

180
00:13:51,090 --> 00:13:55,565
потом в квадратных скобках
идет тип ключа и тип данных.

181
00:13:55,565 --> 00:14:00,923
При этом вы можете,
конечно же, сделать вот так,

182
00:14:00,923 --> 00:14:06,908
то есть мапа, мап, мапа — мапов.

183
00:14:06,908 --> 00:14:13,344
Что может выступать в ключе,
в качестве ключа.

184
00:14:13,344 --> 00:14:18,300
В качестве ключа может выступать
любая сравниваемая структура данных.

185
00:14:18,300 --> 00:14:21,272
Итак, объявление.

186
00:14:21,272 --> 00:14:27,197
В данном случае я объявляю мапу
сразу же при инициализации, вот так.

187
00:14:27,197 --> 00:14:31,745
И если я скажу «там будет nil»,
то есть нужно инициализировать.

188
00:14:31,745 --> 00:14:33,373
Вот так я инициализирую.

189
00:14:33,373 --> 00:14:36,930
Я указываю ключ,
через двоеточие я указываю значение.

190
00:14:36,930 --> 00:14:41,670
И запятая, чтобы сказать компилятору,
что там что-то идет дальше.

191
00:14:41,670 --> 00:14:47,750
При этом мапу можно точно так же создать,

192
00:14:47,750 --> 00:14:52,650
выделив сразу нужно место под то
количество элементов, которое я там хочу,

193
00:14:52,650 --> 00:14:56,800
чтобы тоже не приходилось
расширять ее в рантайме.

194
00:14:56,800 --> 00:15:02,460
Через len я могу получить
количество элементов в мапе.

195
00:15:02,460 --> 00:15:07,806
Через обращение к

196
00:15:07,806 --> 00:15:14,347
элементу в квадратных скобках я обращаюсь
уже к тем данным, которые там лежат.

197
00:15:14,347 --> 00:15:20,460
Но есть одна особенность: если там
этого элемента нету по этому ключу,

198
00:15:20,460 --> 00:15:24,130
то вам вернется значение по умолчанию.

199
00:15:24,130 --> 00:15:29,710
Про это надо знать,
потому что если вдруг у вас мапа,

200
00:15:29,710 --> 00:15:36,730
которая состоит из булов, то значение
по умолчанию для була — это false.

201
00:15:36,730 --> 00:15:43,618
И вам вернется false, то есть вы должны
как-то отличать что вам вернулось:

202
00:15:43,618 --> 00:15:49,156
это значение false вам вернулось,
оно там реально лежит, либо его там нет.

203
00:15:49,156 --> 00:15:55,400
Для разрешения этой ситуации можно
получить признак существования ключа.

204
00:15:55,400 --> 00:15:59,980
Он может быть получен,

205
00:15:59,980 --> 00:16:03,448
используя вторую переменную
при обращении к мапе.

206
00:16:03,448 --> 00:16:08,245
В данном случае я получаю
признак существования ключа в

207
00:16:08,245 --> 00:16:10,705
переменную nNameExist.

208
00:16:10,705 --> 00:16:14,929
То есть и в нем уже будет лежать булевая
переменная, которая будет говорить,

209
00:16:14,929 --> 00:16:16,850
был там ключ либо не было там ключа.

210
00:16:16,850 --> 00:16:21,435
Вы будете очень часто это использовать,
запомните это.

211
00:16:21,435 --> 00:16:26,020
Если же мне нужно только проверить,
есть там значение или нет,

212
00:16:26,020 --> 00:16:28,015
то я могу пропустить первую переменную,

213
00:16:28,015 --> 00:16:31,834
используя символ подчеркивания —
пустую переменную, говоря: да, я знаю,

214
00:16:31,834 --> 00:16:36,660
что там должна быть переменная, но она мне
не нужна, не надо ее никуда присваивать.

215
00:16:36,660 --> 00:16:38,718
И, наконец, удаление ключа.

216
00:16:38,718 --> 00:16:42,770
Удаление ключа происходит через
встроенную функцию delete.

217
00:16:42,770 --> 00:16:48,200
delete, указываете мапу и
указываете ключ — все просто.

218
00:16:48,200 --> 00:16:54,260
На этом со сложными типами
данных мы закончили,

219
00:16:54,260 --> 00:16:58,980
теперь давайте поговорим про структуры.