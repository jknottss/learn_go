[БЕЗ_ЗВУКА] В этом видео мы
рассмотрим управляющие структуры, благодаря которым вы сможете
делать всю логику вашей программы. Начнем мы с условного оператора. Условный оператор в if,
как и в других языках программирования, представлен конструкцией
if и условное выражение. А в качестве условия в Go может
быть только булевая переменная, поскольку в Go нет приведения типов
автоматически, то вы не можете, как, например, в C PHP, написать пустую строку
или ноль, чтобы ваше выражение прошло. Нет.
Вы должны четко свести это к условному выражению. Кроме того, кроме простых условий,
есть условие с блоком инициализации, где вы можете получить результат
какой-то функции, либо, например, получить значение существования
ключа в map'е, как на примере. После того как вы провели
блок инициализации, вы можете поставить точку с запятой
и уже там написать ваши выражения, которые будут проверяться для
выполнения этого условия. В данном случае мы проверяем,
что ключ существует или не существует. Также, если вам в данном
случае не нужно само значение, которое вы получаете,
а только проверка на существование ключа, то вы можете пропустить само значение, используя пустую переменную,
то есть символ подчеркивания так, чтобы компилятор Go не ругался
на неиспользуемую переменную. В Go также есть множественный if else, когда вы можете комбинировать их в одну
длинную цепочку, Это не всегда бывает удобно, поэтому в Go также в дополнение
к этому есть оператор switch. Оператор switch может
работать по одной переменной, и в блоке case вы будете
указывать условия, которым должна удовлетворять
эта переменная. Но есть нюансы. Во-первых, нюанс, что в отличие,
например, от C, где по умолчанию в switch case у вас происходит
проваливание в следующее условие и вам нужно писать везде break, в Go такого нет,
и проваливание по умолчанию отсутствует. Вам, наоборот, нужно писать fallthrough, для того чтобы ваша программа
провалилась в следующее условие. Также в условиях, то есть в блоке case, может стоять не одно значение,
а несколько, перечисленные через запятые. Ну и конечно же, есть блок default,
который будет выполнен тогда, когда ни одно из этих
условий не применилось. Кроме выполнения switch по одной переменной,
можно использовать разные условия. Тогда этот оператор больше
похож на замену многим if else. Например, мы можем проверить, что либо
одно условие, либо другое выполняется. При этом в этих условиях будут
использованы совершенно разные переменные, то есть это будут совсем разные условия. Также иногда бывает
нужно вам выйти из case, завершить его где-то на середине. Для этого вы можете
использовать оператор break. Тогда вы не пройдете в следующее условие,
а выйдете из switch. В данном примере строчка 57
не будет выведена на экран, потому что у оператора break до нее мы
сказали, что, пожалуйста, не ходи дальше. Хватит. Но иногда бывает нужно, чтобы в операторе
switch вы завершили какой-то цикл. В этом случае вам нужно
указать метку этому циклу, в данном случае она находится на
строчке 51, и поставить эту метку после break,
как это сделано на строчке 60. Ну и раз уж мы заговорили про циклы,
давайте рассмотрим те циклы, которые есть в Go. Итак, циклы. В Go цикл представлен только
одной конструкцией for, но она может принимать
совершенно разные формы. Во-первых, есть конструкция, когда у
вас нет условия и это бесконечный цикл. Это аналог while(true) либо for (;;;). В этом случае вам этот цикл
нужно прервать самостоятельно. Для этого используется конструкция break. Следующим видом цикла является
цикл с одиночным условием. То есть цикл будет выполняться до тех пор,
пока это условие истинно. Это аналог while переменная. В данном случае у нас в строчке
14 как раз указан такой цикл. Он будет выполняться до тех пор,
пока переменная isRun = true. И в первой же итерации цикла
мы isRun устанавливаем false, и цикл завершает свою работу. Третьим вариантом цикла,
который указан на строчке 20, является классический for из C,
когда вы указываете блок инициализации, блок с условием и блок,
который выполняется после итерации цикла. Чаще всего там автоинкремент индекса,
по которому идет цикл. В данном случае мы выполняем
всего лишь две итерации. И если у нас i = 1 на строчке 22, то мы выполняем переход к
следующей итерации цикла. Для этого в Go есть
ключевое слово continue. Еще одним примером будет
операция по слайсам. Например, объявим слайс
на строчке 28 какой-то, и давайте попробуем
проитерироваться по нему. Самый простой способ — это
использовать одно условие, пока мы не дошли до конца. Это аналог while. Мы будем печатать значение, печатать
индекс и сами делать автоинкремент. Такое не очень удобно, поэтому гораздо чаще используется цикл с инициализацией,
с условием и операцией после цикла. В данном случае мы объявляем
в одной строчке индекс, условие и автоинкремент для этого индекса. Ну и четвертым типом цикла, который
есть в Go, это цикл с оператором range. Оператор range заменяет всю рутину,
как указать первоначальный индекс, указать условие,
указать инкремент для этого индекса, вам достаточно просто проитерироваться,
используя оператор range. Оператор range может вам
вернуть либо индекс, только индекс из этого слайса, и вы уже сами можете вывести у
него значение, например, вот так. Вот так вот. sl dx. Либо он может вам вернуть сразу
значение и индекса, и значение, и вам не придется уже обращаться
к самому элементу слайса. При этом происходит создание
копии этого значения. Также вы можете итерироваться
в цикле по map. Вы можете итерироваться
как только по ключам этой map и сами обращаться к ее значениям. В этом случае стоит заметить, что в map порядок включений не определен. Это значит,
что в разных запусках программы ключи в памяти во внутреннюю структуру map
могут располагаться совершенно по-разному. Это обусловлено особенностями реализации. То есть не ожидайте,
что ключи будут в map ровно в том порядке, в котором вы их добавляли. Также вы можете сразу проитерироваться по ключу и по значению из map,
также используя оператор range. Либо если вам ключ не нужен,
вы можете использовать, как всегда, пустую переменную — символ подчеркивания —
и итерироваться только по значениям map. Отдельно стоит отметить
итерирование по строке. Строка внутри себя
представляет слайс байт, но range для строки определен отдельно. Это значит, что,
итерируясь по строке по типу string, вы будете итерироваться не по байтам,
а уже по отдельным символам. И в том,
что вам возвращает range для строки, будет позиция, то есть номер, на котором находится ваш символ,
и непосредственно символ, то есть руна,
которую представляет собой utf-ный символ. В этом видео я рассказал вам
про управляющие структуры, которые будут жить в вашей программе. Это оператор if, оператор switch и циклы,
использующие ключевое слово for.