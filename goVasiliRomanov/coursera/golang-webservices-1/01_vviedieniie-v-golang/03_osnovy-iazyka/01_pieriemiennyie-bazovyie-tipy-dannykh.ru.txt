[БЕЗ_ЗВУКА] В этом видео мы поговорим про
самые-самые основы языка — переменные. С переменными вы будете работать большую
часть своей программистской жизни, потому что программирование
в основном состоит в том, чтобы переложить данные из
одной переменной в другую. Итак, начнем. Переменная в go объявляется при
помощи ключевого слова var, после которой следует имя
переменной и тип переменной. При этом вы можете не указывать
значения по умолчанию, при этом вы можете не указывать
значения при инициализации, и тогда переменная будет
инициализирована значением по умолчанию. В данном случае для int это ноль. Это одна из основных особенностей go, потому что нет риска получить какую-то
неинициализированную переменную, в которой осталось что-то из предыдущей
области памяти, от предыдущего владельца. Итак, вы можете просто
объявить переменную через var, вы можете сразу присвоить ей значение. Для некоторых типов данных вы
можете пропустить указание типа, и компилятор определит
этот тип автоматически. В данном случае в
переменную num2 я кладу 20, и компилятор определяет, что это тип int. Далее, короткое объявление переменной. Иногда бывает так, что вам нужно
что-то вернуть из функции и очень не хочется писать имя и тип переменной,
которая там будет. Для этих целей в go есть
короткое объявление. Оно осуществляется при
помощи оператора :=. Однако используя короткое объявление, вы
можете объявить только новую переменную, то есть присвоить значение в
уже существующую переменную, используя этот оператор, вы не сможете. В данном случае, если я попробую выполнить
эту программу, компилятор ругнется, что нет новых переменных. Конечно, есть +1, есть постфиксный инкремент, но нет префиксного инкремента. На самом деле это базово
всё для переменных. Немножко про стиль. В go принят camelCase стиль,
under_score стиль не очень приветствуется. Если вы будете использовать какие-то
синтаксические анализаторы, то они могут на это ругаться. Привыкайте сразу. В go можно объявить сразу несколько
переменных через запятую и сразу же проинициализировать их. Можно присвоить им
значение после объявления. Также вы можете использовать
короткое присваивание для объявления нескольких переменных, однако хотя бы одна
из этих переменных должна быть новой. Например, если здесь я напишу height,
то компилятор будет ругаться, потому что ни одна из
этих переменных не новая. Если же одна из них новая, то уже существующим присвоится значение
и будет объявлена новая переменная. Итак, а теперь давайте рассмотрим,
какие еще есть типы данных. Мы начинали с int. int вообще платформозависимый тип в go. Он имеет разрядность либо 32 бита, либо 64
бита в зависимости от вашей операционки. int, конечно, выбирается автоматически. Если вас не устраивает разрядность
или вы хотите большего контроля, то в go поддержка от int8 до int64, которая
позволяет хранить очень большие значения. Есть беззнаковый int — uint,
он тоже может быть платформозависимым. Если опять-таки платформозависимость
вас не устраивает, к вашим услугам от uint8 до uint64
Числа с плавающей точкой представлены как одинарной точности float 32,
так и двойной точности. Для них тоже есть автоподстановка типа,
автоугадывание типа, для них тоже есть значение по
умолчанию — это тоже ноль. Булевая переменная. В булевых переменных
значение по умолчанию ноль, и оно тоже может
угадываться автоматически. Ничего нового. В go есть комплексные переменные. Один из создателей языка очень хотел,
чтобы они там были, но на практике мне их использовать
никогда не приходилось. Однако вдруг вам они могут быть полезны, и в go есть полный набор
функций для работы с ними. Строки. Строки — это очень важный тип данных,
вы будете очень много с ним работать. По умолчанию для строки
— это пустая строка. Строка объявляется в двойных кавычках, и при этом внутри этих двойных
кавычек могут быть спецсимволы, такие как перенос строки
либо символ табуляции. Если же вы хотите писать как есть, то вы можете использовать backtick'и,
обратные кавычки, и символ новой строки либо табуляции там
будет прямо, как мы описали, слэш n. В go строки из коробки поддерживают UTF-8,
поэтому вы можете там писать на практически любых алфавитах,
на русском, в данном случае на китайском. Одинарные кавычки в go
используются для символов byte, который является по сути
alias'ом для uint8. Либо же для rune, который представляет
собой полноценный UTF-8 символ. Внутри это uint32. Итак, строки в go вы можете компилировать, то есть соединять между собой
при помощи оператора плюс. Однако строки в go незаменяемы, вы не
можете заменить там какой-то один символ. Вот в данном случае
программа будет ругаться. Если вы попробуете получить длину строки, используя встроенную функцию len,
то вы получите длину в байтах. Иногда это может запутать,
потому что это не символы. Если там лежит внутри utf, то один символ
может занимать больше одного байта. Если же вы хотите получить
именно количество символов, вам придется воспользоваться специальной
функцией RunCountInString из пакета utf8. Также вы можете получить часть строки, подстроку, используя оператор срез. Вы можете получить,
начиная с какого байта и по какой байт. Еще одной особенностью строк является то, что их можно конвертировать в слайс байт,
про слайс мы поговорим дальше, и обратно. Из слайс байт вы можете
конвертировать в строку. Иногда это бывает очень полезно и удобно. А теперь константа. Константа в go определяется при помощи
ключевого слова const, после которой идет имя переменной,
имя этой константы и опционально ее тип. При этом вы можете объявить
сразу блок констант, то есть не указывая ключевое
слово перед каждой константой. Еще в go есть очень полезная вещь,
называется iota. iota — это такой
автоинкремент для константы. Довольно часто бывают случаи,
когда вам надо объявить пачку констант, которые отличаются между собой на единицу. Например, значения битов
в какой-то битовой маске. Автоинкремент тут очень кстати. Вы указываете iota на первом месте, а дальше вам не нужно указывать ничего, в данном случае константа
3 объявилась через iota. Если вам нужно пропустить
вдруг какую-то константу, вы можете использовать символом
подчеркивания, это в go пустая переменная, которая говорит, что, да, здесь должно
быть значение, но мы его проигнорируем. При этом iota может
выступать не только каким-то простым автоинкрементом, но и
участвовать в математических выражениях. Вот, например, в данном случае константа мегабайт определяется тоже через iota, используя то выражение,
которое я написал в определении килобайта. Еще одной особенностью go является то, что нетипизированная константа,
которой вы не объявили тип сами, она так и остается
внутри нетипизированной. И может в нужное место
подставиться уже с нужным типом. За счет этого, например,
константы в go иметь целочисленные значения,
значительно превышающие 64 бита. Но вот в данном случае у меня есть переменная «месяц»,
которая имеет тип int32. Я могу добавить к ней год, year,
потому что это нетипизированная константа. При этом если я попробую добавить
типизированную константу, то компилятор заругается, что так нельзя,
надо преобразовывать тип. Итак, определение типов. В go вы можете определять собственные
типы, либо основываясь на каких-то базовых примитивах, либо используя
более сложные конструкции, такие как структуры,
о которых мы будем говорить отдельно. Тип очень полезно А определять, если вы
хотите моделировать уже какие-то сущности. В данном случае у меня тип UserID. Особенностью Go является то, что здесь нет никакого автоматического
приведения типов никуда. И для того чтобы привести какую-то переменную базового типа к другому типу, который тоже основан на базовом типе, мне придётся сделать конвертацию,
в данном случае это типы совместимые, я могу, используя объявление типа и
скобки, привести его к нужному мне UserID. То есть idx у меня типа int,
а myID будет тип UserID. Также вы можете конвертировать
простые int'ы между собой, или, как я уже показывал,
строку со слайсом байт. ...данных, про которые мы поговорим,
это указатели. Начать надо с того,
что в Go нет адресной арифметики. Вы не можете прибавить какое-то
значение к указателю и получить указатель на другую область памяти. В Go указатель — это отдельный тип данных. Что это значит? Это значит, что если вы объявляете
какую-то переменную как указатель на другую, то внутри этой
переменной будет лежать значение адреса на другую переменную. То есть это не является
полноценной ссылкой, которая указывает ровно туда же,
куда и основная переменная. Итак, в данном случае я
объявляю переменную a, и в переменную b я кладу указатель на a. Теперь я могу положить внутрь значение,
которое лежит за b, используя оператор *, я могу положить 3,
и внутри a значение изменится. Через c я создам новый указатель на a. Если же вам нужно создать указатель на какой-то тип данных,
что часто используют, например, в структурах, то вы можете
использовать ключевое слово int, точнее встроенную функцию int,
которая создаст вам переменную нужного типа,
заполнит её значением по умолчанию, что важно, у вас там не будет мусора,
и вернёт вам указатель на эту переменную. Теперь в данном случае... Итак, я сделал, получив указатель на int. Теперь я могу изменить какое-то значение. Также я могу в c, в значение, которое лежит за c, положить значение,
которое лежит внутри d. И, таким образом, переменная a, указателем
на которую является c, она изменится. При этом теперь я меняю d,
и c и a уже не меняются, потому что c указывает на a,
а не становится сразу же ссылкой на d. Однако теперь дальше я говорю,
что c теперь — указатель на d, точнее в c теперь находится тот же
указатель, который находится внутри d. И если я изменю c, изменю значение, которое лежит за c, то изменится значение, которое лежит внутри d, но не значение,
которое лежит внутри a. Работа с указателями —
довольно важная часть в Go, но вы ознакомитесь с ней
уже во время практики.