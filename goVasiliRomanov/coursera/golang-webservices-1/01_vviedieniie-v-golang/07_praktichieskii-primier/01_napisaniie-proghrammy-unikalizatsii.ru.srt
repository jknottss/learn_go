1
00:00:00,000 --> 00:00:07,079
[БЕЗ_ЗВУКА] В этом видео мы напишем

2
00:00:07,079 --> 00:00:11,760
простую программу для уникализации строк,
которые подаются ей на стандартный ввод.

3
00:00:11,760 --> 00:00:14,138
Начнем мы с описания пакета main,

4
00:00:14,138 --> 00:00:18,740
из которого будет вызываться
функция main при старте программы.

5
00:00:18,740 --> 00:00:23,470
Также нам потребуется
несколько стандартных пакетов:

6
00:00:23,470 --> 00:00:29,516
[БЕЗ_ЗВУКА] «os» для того,

7
00:00:29,516 --> 00:00:34,344
чтобы получить доступ к спинартному вводу,
«fnt» для того,

8
00:00:34,344 --> 00:00:41,835
чтобы делать форматированный вывод,
и буферизированный ввод-вывод.

9
00:00:41,835 --> 00:00:44,240
Ну и функция main.

10
00:00:44,240 --> 00:00:49,071
Для начала нам нужно
как-то читать просто ввод.

11
00:00:49,071 --> 00:00:54,245
Для того чтобы читать ввод,
— мы будем его не посимвольно,

12
00:00:54,245 --> 00:01:03,395
а сразу всей строкой,
— для этого нам нужен сканер ввода.

13
00:01:03,395 --> 00:01:10,632
[БЕЗ_ЗВУКА] Теперь

14
00:01:10,632 --> 00:01:16,300
мы будем построчно двигаться по вводу.

15
00:01:16,300 --> 00:01:21,102
Когда сканировать будет больше нечего,

16
00:01:21,102 --> 00:01:25,600
то scan вернет false,
и мы выйдем из цикла.

17
00:01:25,600 --> 00:01:29,820
Теперь текст, который мы считали.

18
00:01:29,820 --> 00:01:35,569
Ну и давайте его просто

19
00:01:35,569 --> 00:01:45,415
выведем и запустим.

20
00:01:45,415 --> 00:01:50,784
Данные, которые мы будем посылать,

21
00:01:50,784 --> 00:01:57,180
это просто набор чисел: 1, 3, 2, 1, 2.

22
00:01:57,180 --> 00:02:02,570
[БЕЗ_ЗВУКА]

23
00:02:02,570 --> 00:02:10,942
[БЕЗ_ЗВУКА] Вот

24
00:02:10,942 --> 00:02:13,546
мы просто вывели текст.

25
00:02:13,546 --> 00:02:16,006
Теперь давайте сделаем так,

26
00:02:16,006 --> 00:02:19,750
чтобы выводить только уникальные строчки,
которых не было.

27
00:02:19,750 --> 00:02:24,701
В данном случае мы попробуем
использовать структуру map,

28
00:02:24,701 --> 00:02:28,280
чтобы запоминать те данные,
которые мы уже видели.

29
00:02:28,280 --> 00:02:32,130
Давайте ее создадим.

30
00:02:32,130 --> 00:02:40,130
[БЕЗ_ЗВУКА]

31
00:02:40,130 --> 00:02:46,812
[БЕЗ_ЗВУКА] Создали map.

32
00:02:46,812 --> 00:02:53,622
Теперь давайте проверять, что если мы еще
этого текста не видели, то мы будем только

33
00:02:53,622 --> 00:02:58,815
в этом случае его писать, если видели,
мы будем это запоминать и не печатать.

34
00:02:58,815 --> 00:03:04,860
[БЕЗ_ЗВУКА]

35
00:03:04,860 --> 00:03:12,860
[БЕЗ_ЗВУКА]

36
00:03:12,860 --> 00:03:19,193
[БЕЗ_ЗВУКА] В

37
00:03:19,193 --> 00:03:25,340
данной конструкции мы будем просто
пропускать строчку, если ее уже видели.

38
00:03:25,340 --> 00:03:30,190
Теперь нам нужно запомнить строчку,
чтобы в следующий раз

39
00:03:30,190 --> 00:03:34,810
уже к ней не возвращаться.

40
00:03:34,810 --> 00:03:38,065
Давайте попробуем запустить.

41
00:03:38,065 --> 00:03:41,080
Вот, вывелось 1, 3, 2.

42
00:03:41,080 --> 00:03:46,874
То есть наша программа уже работает,

43
00:03:46,874 --> 00:03:50,520
но использовать map для того,
чтобы определять,

44
00:03:50,520 --> 00:03:55,744
видели ли мы уже строчку или нет, может
быть, не очень выгодно в случае, если

45
00:03:55,744 --> 00:04:00,620
у нас очень большой массив входных данных,
то есть мы можем просто уйти по памяти.

46
00:04:00,620 --> 00:04:05,940
Давайте немножко переделаем нашу
программу, для того чтобы она была

47
00:04:05,940 --> 00:04:11,950
похожа на команду стандартной
поставки GNU Coreutils  uniq.

48
00:04:11,950 --> 00:04:17,531
Команда uniq принимает на вход
отсортированный набор данных,

49
00:04:17,531 --> 00:04:22,833
и за счет этого она может сравнить,
что если мы уже пришли на

50
00:04:22,833 --> 00:04:27,892
эту позицию, мы уже видели, это значит,

51
00:04:27,892 --> 00:04:32,650
что все, что до этого было,
оно должно быть меньше.

52
00:04:32,650 --> 00:04:34,379
Давайте попробуем.

53
00:04:34,379 --> 00:04:39,090
Нам больше не нужна map,
нам нужно предыдущее значение.

54
00:04:39,090 --> 00:04:44,848
[БЕЗ_ЗВУКА] Теперь мы можем просто

55
00:04:44,848 --> 00:04:50,608
сравнивать с предыдущей строкой:
если эта строка равна текущей,

56
00:04:50,608 --> 00:04:55,824
значит это значение мы уже напечатали
и печатать его больше не надо.

57
00:04:55,824 --> 00:05:00,872
Если эта строка меньше текущей,
— будем сравнивать просто по байтам,

58
00:05:00,872 --> 00:05:04,960
— это значит, что файл не отсортирован,

59
00:05:04,960 --> 00:05:11,320
и наша программа в этом случае работать
не может, мы просто запаникуем.

60
00:05:11,320 --> 00:05:17,560
Давайте попробуем.

61
00:05:17,560 --> 00:05:20,178
Если текущий текст равен предыдущему,

62
00:05:20,178 --> 00:05:23,880
значит мы его просто не выводим
и перескакиваем строку.

63
00:05:23,880 --> 00:05:32,539
Если текст меньше предыдущего,

64
00:05:32,539 --> 00:05:36,510
нам нужно запаниковать.

65
00:05:36,510 --> 00:05:43,647
И теперь нам нужно установить

66
00:05:43,647 --> 00:05:48,430
предыдущее значение на текущее, чтобы в
следующий раз с этим корректно сравниться.

67
00:05:48,430 --> 00:05:52,080
Можно напечатать наши значения,

68
00:05:52,080 --> 00:05:58,335
давайте пробовать.

69
00:05:58,335 --> 00:06:02,405
Файл не отсортирован, потому что файл,
который мы использовали,

70
00:06:02,405 --> 00:06:04,590
он действительно не отсортирован.

71
00:06:04,590 --> 00:06:08,190
Давайте возьмем другой файл,
например, вот этот,

72
00:06:08,190 --> 00:06:12,474
который корректно отсортирован,

73
00:06:12,474 --> 00:06:16,190
и попробуем запустить на нем.

74
00:06:16,190 --> 00:06:23,265
Наша программа успешно отработала.

75
00:06:23,265 --> 00:06:27,680
Но давайте теперь попробуем вставить
несколько неуникальных значений,

76
00:06:27,680 --> 00:06:31,735
чтобы проверить, что действительно
она отрабатывает корректно.

77
00:06:31,735 --> 00:06:32,801
Запустим.

78
00:06:32,801 --> 00:06:39,243
Вывелось 1, 2, 3, 4, 5, в то время как у
нас было несколько повторяющихся значений.

79
00:06:39,243 --> 00:06:42,904
Это значит,
что наша программа работает корректно.

80
00:06:42,904 --> 00:06:46,940
В данном видео мы написали
небольшую программу,

81
00:06:46,940 --> 00:06:53,650
которая демонстрирует работу
со стандартным вводом.

82
00:06:53,650 --> 00:06:56,596
Но вдруг мы сделали какую-то ошибку в ней,

83
00:06:56,596 --> 00:06:59,762
и на каких-то условиях она
будет работать некорректно?

84
00:06:59,762 --> 00:07:04,200
Поэтому в следующем видео мы напишем тесты
для нашей программы, чтобы быть уверенным,

85
00:07:04,200 --> 00:07:09,170
что она всегда отрабатывает, даже если
мы внесли в нее какие-то модификации.