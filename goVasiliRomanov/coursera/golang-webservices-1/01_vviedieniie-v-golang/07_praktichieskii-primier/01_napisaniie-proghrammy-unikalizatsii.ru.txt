[БЕЗ_ЗВУКА] В этом видео мы напишем простую программу для уникализации строк,
которые подаются ей на стандартный ввод. Начнем мы с описания пакета main, из которого будет вызываться
функция main при старте программы. Также нам потребуется
несколько стандартных пакетов: [БЕЗ_ЗВУКА] «os» для того, чтобы получить доступ к спинартному вводу,
«fnt» для того, чтобы делать форматированный вывод,
и буферизированный ввод-вывод. Ну и функция main. Для начала нам нужно
как-то читать просто ввод. Для того чтобы читать ввод,
— мы будем его не посимвольно, а сразу всей строкой,
— для этого нам нужен сканер ввода. [БЕЗ_ЗВУКА] Теперь мы будем построчно двигаться по вводу. Когда сканировать будет больше нечего, то scan вернет false,
и мы выйдем из цикла. Теперь текст, который мы считали. Ну и давайте его просто выведем и запустим. Данные, которые мы будем посылать, это просто набор чисел: 1, 3, 2, 1, 2. [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] Вот мы просто вывели текст. Теперь давайте сделаем так, чтобы выводить только уникальные строчки,
которых не было. В данном случае мы попробуем
использовать структуру map, чтобы запоминать те данные,
которые мы уже видели. Давайте ее создадим. [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] Создали map. Теперь давайте проверять, что если мы еще
этого текста не видели, то мы будем только в этом случае его писать, если видели,
мы будем это запоминать и не печатать. [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] В данной конструкции мы будем просто
пропускать строчку, если ее уже видели. Теперь нам нужно запомнить строчку,
чтобы в следующий раз уже к ней не возвращаться. Давайте попробуем запустить. Вот, вывелось 1, 3, 2. То есть наша программа уже работает, но использовать map для того,
чтобы определять, видели ли мы уже строчку или нет, может
быть, не очень выгодно в случае, если у нас очень большой массив входных данных,
то есть мы можем просто уйти по памяти. Давайте немножко переделаем нашу
программу, для того чтобы она была похожа на команду стандартной
поставки GNU Coreutils  uniq. Команда uniq принимает на вход
отсортированный набор данных, и за счет этого она может сравнить,
что если мы уже пришли на эту позицию, мы уже видели, это значит, что все, что до этого было,
оно должно быть меньше. Давайте попробуем. Нам больше не нужна map,
нам нужно предыдущее значение. [БЕЗ_ЗВУКА] Теперь мы можем просто сравнивать с предыдущей строкой:
если эта строка равна текущей, значит это значение мы уже напечатали
и печатать его больше не надо. Если эта строка меньше текущей,
— будем сравнивать просто по байтам, — это значит, что файл не отсортирован, и наша программа в этом случае работать
не может, мы просто запаникуем. Давайте попробуем. Если текущий текст равен предыдущему, значит мы его просто не выводим
и перескакиваем строку. Если текст меньше предыдущего, нам нужно запаниковать. И теперь нам нужно установить предыдущее значение на текущее, чтобы в
следующий раз с этим корректно сравниться. Можно напечатать наши значения, давайте пробовать. Файл не отсортирован, потому что файл,
который мы использовали, он действительно не отсортирован. Давайте возьмем другой файл,
например, вот этот, который корректно отсортирован, и попробуем запустить на нем. Наша программа успешно отработала. Но давайте теперь попробуем вставить
несколько неуникальных значений, чтобы проверить, что действительно
она отрабатывает корректно. Запустим. Вывелось 1, 2, 3, 4, 5, в то время как у
нас было несколько повторяющихся значений. Это значит,
что наша программа работает корректно. В данном видео мы написали
небольшую программу, которая демонстрирует работу
со стандартным вводом. Но вдруг мы сделали какую-то ошибку в ней, и на каких-то условиях она
будет работать некорректно? Поэтому в следующем видео мы напишем тесты
для нашей программы, чтобы быть уверенным, что она всегда отрабатывает, даже если
мы внесли в нее какие-то модификации.