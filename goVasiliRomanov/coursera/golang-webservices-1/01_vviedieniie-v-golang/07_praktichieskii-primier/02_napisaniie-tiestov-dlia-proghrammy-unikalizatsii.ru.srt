1
00:00:00,000 --> 00:00:09,164
[БЕЗ СЛОВ] В этом видео мы
напишем тесты к нашей программе,

2
00:00:09,164 --> 00:00:12,890
которая локализирует поток ввода,
который подается ей на вход.

3
00:00:12,890 --> 00:00:16,703
Для того чтобы это сделать, нам нужно
нашу программу немножко «прифакторить»,

4
00:00:16,703 --> 00:00:19,560
потому что сейчас она не очень
подходит для написания тестов,

5
00:00:19,560 --> 00:00:22,791
разве что какими-то внешними программами.

6
00:00:22,791 --> 00:00:26,334
Для начала давайте вынесем весь
наш код в отдельную функцию,

7
00:00:26,334 --> 00:00:28,680
которая будет просто принимать параметры.

8
00:00:28,680 --> 00:00:31,568
И уже тестировать будем
именно эту функцию.

9
00:00:31,568 --> 00:00:34,610
Назовем нашу функцию,
как ни странно, uniq.

10
00:00:34,610 --> 00:00:41,325
Наша функция должна
принимать на вход поток,

11
00:00:41,325 --> 00:00:47,950
из которого мы будем читать и поток,
куда мы будем писать результат.

12
00:00:47,950 --> 00:00:52,067
Это все реализуется через
интерфейс Reader и Writer.

13
00:00:52,067 --> 00:00:54,850
Для этого нам понадобится пакет io.

14
00:00:54,850 --> 00:01:01,860
И тут мы теперь будем принимать параметры.

15
00:01:01,860 --> 00:01:07,641
Input для входящего потока io.Reader

16
00:01:07,641 --> 00:01:14,810
и output для вывода io.

17
00:01:14,810 --> 00:01:15,518
Writer.

18
00:01:15,518 --> 00:01:20,750
И для случая ошибки мы можем вернуть
ошибку в этой программе — error.

19
00:01:20,750 --> 00:01:27,054
Теперь переместим нашу программу
в новую функцию и читать

20
00:01:27,054 --> 00:01:33,320
мы теперь будем не из стандартного потока,

21
00:01:33,320 --> 00:01:37,200
а из под поданного во вход Reader.

22
00:01:37,200 --> 00:01:38,896
Заменяем.

23
00:01:38,896 --> 00:01:44,615
Теперь нам нужно писать опять-таки
не в стандартный вывод,

24
00:01:44,615 --> 00:01:46,793
а в output, который нам передали.

25
00:01:46,793 --> 00:01:53,490
Для этого в пакете fmt есть
специальная функция: fmt.Println,

26
00:01:53,490 --> 00:01:59,422
который первым аргументом
принимает на вход в Reader.

27
00:01:59,422 --> 00:02:00,690
Почти всё.

28
00:02:00,690 --> 00:02:05,404
Теперь нам хорошо бы не паниковать,
а просто возвращать ошибку,

29
00:02:05,404 --> 00:02:10,640
что всё плохо: return fmt.

30
00:02:10,640 --> 00:02:11,467
Errof.

31
00:02:11,467 --> 00:02:14,303
Теперь возвращаем ошибку.

32
00:02:14,303 --> 00:02:19,314
И последний штрих, нам нужно в
конце нашей программы вернуть nill,

33
00:02:19,314 --> 00:02:21,690
чтобы сказать, что никакой ошибки не было.

34
00:02:21,690 --> 00:02:23,138
Вот тут nill.

35
00:02:23,138 --> 00:02:27,984
Вот, вроде бы наша программа выглядит так,
как надо.

36
00:02:27,984 --> 00:02:30,640
Теперь давайте вызовем эту функцию.

37
00:02:30,640 --> 00:02:39,406
err := uniq (os.Stdin,

38
00:02:39,406 --> 00:02:46,285
и на выход os.Stdout).

39
00:02:46,285 --> 00:02:47,350
И проверим ошибку.

40
00:02:47,350 --> 00:02:50,870
И будем паниковать в случае,
если нам что-то вернулось плохое.

41
00:02:50,870 --> 00:02:54,434
if err != nul.

42
00:02:54,434 --> 00:02:58,510
Просто паникуем.

43
00:02:58,510 --> 00:03:05,025
panic(err.Error()) Вроде бы мы закончили.

44
00:03:05,025 --> 00:03:08,440
И давайте посмотрим,
работает ли наша программа.

45
00:03:08,440 --> 00:03:14,285
$ go run

46
00:03:14,285 --> 00:03:21,932
[БЕЗ СЛОВ] Нет,

47
00:03:21,932 --> 00:03:26,260
не работает.

48
00:03:26,260 --> 00:03:32,714
Errorf Отлично, наша программа заработала.

49
00:03:32,714 --> 00:03:39,327
То есть она действительно выводит
стандартный тот поток, который мы ей дали.

50
00:03:39,327 --> 00:03:43,902
Теперь давайте посмотрим,
работает ли она корректно.

51
00:03:43,902 --> 00:03:46,931
Да, действительно, мы подали на вход дату,

52
00:03:46,931 --> 00:03:50,580
в которой были дублирующие значения
и она их отфильтровала нормально.

53
00:03:50,580 --> 00:03:51,197
Всё хорошо.

54
00:03:51,197 --> 00:03:54,860
Теперь давайте попробуем приступить
к написанию непосредственно тестов.

55
00:03:54,860 --> 00:04:00,745
Пакеты, тесты

56
00:04:00,745 --> 00:04:06,279
в go должны лежать в пакете,
который имеет суффикс test.

57
00:04:06,279 --> 00:04:09,062
То есть main_test.go.

58
00:04:09,062 --> 00:04:10,960
Давайте начнем.

59
00:04:10,960 --> 00:04:11,838
package main.

60
00:04:11,838 --> 00:04:14,336
Мы должны будем находиться
в том же пакете.

61
00:04:14,336 --> 00:04:18,632
Нам понадобятся некоторые
функции из стандартных пакетов.

62
00:04:18,632 --> 00:04:20,900
Давайте их импортируем.

63
00:04:20,900 --> 00:04:22,068
import.

64
00:04:22,068 --> 00:04:27,426
Нам понадобится strings, bytes и testing

65
00:04:27,426 --> 00:04:33,420
— непосредственно пакет для тестирований.

66
00:04:33,420 --> 00:04:41,310
Все тесты в go начинаются с префикса test.

67
00:04:41,310 --> 00:04:45,865
Test (давайте напишем) Ok.

68
00:04:45,865 --> 00:04:50,420
И принимает на вход единственный
параметр тестирующего модуля.

69
00:04:50,420 --> 00:04:56,900
(t *testing.T)

70
00:04:56,900 --> 00:05:02,155
Теперь нам надо вызвать нашу

71
00:05:02,155 --> 00:05:07,410
программу с чем-то: err :=

72
00:05:07,410 --> 00:05:15,134
uniq () if err != nii.

73
00:05:15,134 --> 00:05:19,430
Теперь мы должны сказать, если нам err,

74
00:05:19,430 --> 00:05:23,838
если наша программа
вернула какую-то ошибку,

75
00:05:23,838 --> 00:05:28,680
то мы должны сказать,
что тест свебился: t.Errorf

76
00:05:28,680 --> 00:05:35,806
("test for OK Failed").

77
00:05:35,806 --> 00:05:39,880
Теперь нужно что-то подать на вход.

78
00:05:39,880 --> 00:05:46,051
Для начала нам нужны
какие-то тестовые данные.

79
00:05:46,051 --> 00:05:48,714
Давайте их создадим.

80
00:05:48,714 --> 00:05:52,707
var testOk (используем «бэктики» для того,

81
00:05:52,707 --> 00:05:58,469
чтобы у нас сохранялся
перевод строки) 1 2 3

82
00:05:58,469 --> 00:06:05,140
4 5 Теперь создадим новый Reader,

83
00:06:05,140 --> 00:06:14,275
[БЕЗ СЛОВ] NewReader,

84
00:06:14,275 --> 00:06:19,310
который принимает (strings.

85
00:06:19,310 --> 00:06:24,735
NewReader).

86
00:06:24,735 --> 00:06:30,828
А в него уже передадим нашу строку.

87
00:06:30,828 --> 00:06:32,023
Вот так.

88
00:06:32,023 --> 00:06:35,170
То есть ввод у нас готов.

89
00:06:35,170 --> 00:06:38,181
Передаём его в uniq.

90
00:06:38,181 --> 00:06:41,700
Теперь нам нужен вывод.

91
00:06:41,700 --> 00:06:47,426
Воспользуемся функцией New и
создадим просто буфер-байт,

92
00:06:47,426 --> 00:06:55,070
куда будет писаться вывод: new(bytes.

93
00:06:55,070 --> 00:06:57,736
Buffer) — новый буфер.

94
00:06:57,736 --> 00:06:59,800
И будем писать его.

95
00:06:59,800 --> 00:07:03,800
Хорошо.

96
00:07:03,800 --> 00:07:09,610
Теперь наша программа вроде бы
должна заработать — наш тест.

97
00:07:09,610 --> 00:07:17,510
Давайте попробуем его
запустить: $ go test − v.

98
00:07:17,510 --> 00:07:19,205
v — это значит verbals.

99
00:07:19,205 --> 00:07:25,200
Мы хотим видеть результаты: какие тесты
заработали, а какие закончились неудачей.

100
00:07:25,200 --> 00:07:30,845
main_test.go.

101
00:07:30,845 --> 00:07:36,490
Что-то я импортировал неправильно.

102
00:07:36,490 --> 00:07:44,490
Var.

103
00:07:44,490 --> 00:07:53,863
Ага, Var не нужен.

104
00:07:53,863 --> 00:07:59,150
Итератор короткого присваивания.

105
00:07:59,150 --> 00:08:03,195
Отлично, теперь запустим.

106
00:08:03,195 --> 00:08:05,950
undefined: uniq.

107
00:08:05,950 --> 00:08:07,530
Тут fails.

108
00:08:07,530 --> 00:08:10,374
Давайте без ничего.

109
00:08:10,374 --> 00:08:12,750
Просто тест − v.

110
00:08:12,750 --> 00:08:16,880
Отлично, наш тест прошел корректно.

111
00:08:16,880 --> 00:08:19,082
То есть никакой ошибки не было.

112
00:08:19,082 --> 00:08:22,894
Однако мы не проверили то,
что нам записалось в вывод.

113
00:08:22,894 --> 00:08:26,328
Это значит,
что наша программа могла отработать,

114
00:08:26,328 --> 00:08:30,036
ошибку не вернуть,
но в вывод записать что-то неправильно.

115
00:08:30,036 --> 00:08:31,290
Это нужно исправить.

116
00:08:31,290 --> 00:08:35,170
Для этого я, собственно, делал out,

117
00:08:35,170 --> 00:08:38,170
куда будет записываться
результат работы программы.

118
00:08:38,170 --> 00:08:42,846
Теперь нам нужен эталон результата,
с которым мы будем сравнивать.

119
00:08:42,846 --> 00:08:47,920
Давайте его создадим: var testOkResult

120
00:08:47,920 --> 00:08:52,123
= 1 2 3 4

121
00:08:52,123 --> 00:08:57,330
5 Хорошо, теперь проверяем.

122
00:08:57,330 --> 00:09:03,760
if out.

123
00:09:03,760 --> 00:09:10,190
String () результат в виде строки,
который записался в наш буфер.

124
00:09:10,190 --> 00:09:15,189
Если он не равен нашему эталонному
результату testOkResult,

125
00:09:15,189 --> 00:09:20,380
то мы должны сказать,
что тест вернулся плохой.

126
00:09:20,380 --> 00:09:25,061
("test for Ok Failed- error") ("test for

127
00:09:25,061 --> 00:09:32,395
Ok Failed- results not match")
Давайте попробуем запустить.

128
00:09:32,395 --> 00:09:35,216
Смотрите, мы что-то вывели неправильно.

129
00:09:35,216 --> 00:09:40,700
Давайте попробуем посмотреть, что (%v %v).

130
00:09:40,700 --> 00:09:46,724
В данном случае я пытаюсь
вывести те данные,

131
00:09:46,724 --> 00:09:49,890
которые к нам приходят и результат.

132
00:09:49,890 --> 00:09:58,108
result := out.String () result,

133
00:09:58,108 --> 00:10:04,739
result и testOkResult.

134
00:10:04,739 --> 00:10:07,960
Запускаем.

135
00:10:07,960 --> 00:10:10,973
И что нам выводится?

136
00:10:10,973 --> 00:10:17,340
1 2 3 4 5 Вроде бы все
должно быть нормально.

137
00:10:17,340 --> 00:10:23,200
[БЕЗ СЛОВ]

138
00:10:23,200 --> 00:10:29,060
1 2 3 4 5 6

139
00:10:29,060 --> 00:10:35,106
1 2 3 4 5 6 Ага,

140
00:10:35,106 --> 00:10:40,780
дело в том, что мы использовали Println,

141
00:10:40,780 --> 00:10:45,680
который в конце выводит перевод строки.

142
00:10:45,680 --> 00:10:50,500
Нам также нужно вывести в нашем результате
перевод строки, чтобы понять, что не так.

143
00:10:50,500 --> 00:10:54,620
Давайте попробуем запустить еще раз.

144
00:10:54,620 --> 00:10:57,325
И теперь наши тесты проходят корректно.

145
00:10:57,325 --> 00:10:58,020
Отлично.

146
00:10:58,020 --> 00:11:00,270
Но это не все, что можно сделать.

147
00:11:00,270 --> 00:11:03,961
Еще у нас остался случай,
когда мы должны вернуть ошибку в случае,

148
00:11:03,961 --> 00:11:05,920
если поток ввода не отсортирован.

149
00:11:05,920 --> 00:11:11,602
Давайте напишем еще один тест.

150
00:11:11,602 --> 00:11:16,042
func testFor Error()t.

151
00:11:16,042 --> 00:11:23,626
"testing.T) [БЕЗ СЛОВ] var.

152
00:11:23,626 --> 00:11:27,580
Теперь нам нужны какие-то входящие данные,

153
00:11:27,580 --> 00:11:31,109
на которых наша программа
просто заругается.

154
00:11:31,109 --> 00:11:32,790
Давайте их создадим.

155
00:11:32,790 --> 00:11:38,252
Например, 1

156
00:11:38,252 --> 00:11:43,260
var testFail

157
00:11:43,260 --> 00:11:49,299
= 1 2 1 И на самом деле
этого будет достаточно,

158
00:11:49,299 --> 00:11:54,180
чтобы проверить, что программа выходит
с ошибкой, если вход не отсортирован.

159
00:11:54,180 --> 00:11:58,565
Теперь на самом деле нам достаточно
скопировать фактически то же самое.

160
00:11:58,565 --> 00:12:06,209
И теперь мы должны ругаться
только на том случае,

161
00:12:06,209 --> 00:12:10,109
если нам программа не вернула
никакую ошибку в нашу функцию.

162
00:12:10,109 --> 00:12:14,900
Давайте теперь будем ругаться,
что если вернулся nill в ошибке,

163
00:12:14,900 --> 00:12:17,810
то в этом случае мы ругаемся.

164
00:12:17,810 --> 00:12:20,466
Запустим еще раз.

165
00:12:20,466 --> 00:12:25,285
Test должен быть с большой буквы.

166
00:12:25,285 --> 00:12:31,098
err 1 2

167
00:12:31,098 --> 00:12:35,724
3 Смотрите, нам вернулась какая-то ошибка.

168
00:12:35,724 --> 00:12:37,700
Давайте посмотрим, что там.

169
00:12:37,700 --> 00:12:45,700
[БЕЗ СЛОВ]

170
00:12:45,700 --> 00:12:50,740
[БЕЗ СЛОВ]

171
00:12:50,740 --> 00:12:55,780
Ага.

172
00:12:55,780 --> 00:13:01,580
[БЕЗ СЛОВ] err

173
00:13:01,580 --> 00:13:07,309
!= [БЕЗ

174
00:13:07,309 --> 00:13:12,566
СЛОВ] Давайте

175
00:13:12,566 --> 00:13:18,900
теперь укажем правильные входящие данные.

176
00:13:18,900 --> 00:13:23,890
Вот теперь всё,
программа должна отрабатывать корректно.

177
00:13:23,890 --> 00:13:25,460
Давайте запустим еще раз.

178
00:13:25,460 --> 00:13:27,781
И наша программа успешно выполняется.

179
00:13:27,781 --> 00:13:31,211
Это значит,
что мы написали не просто программу,

180
00:13:31,211 --> 00:13:35,940
которая уникализирует в стандартный вход,
но и написали тесты к ней.

181
00:13:35,940 --> 00:13:38,486
Это значит, что мы будем уверены,
что завтра,

182
00:13:38,486 --> 00:13:42,558
когда мы будем вносить изменения в эту
программу, то ничего не сломается.

183
00:13:42,558 --> 00:13:46,730
У нас есть тесты, которые в случае,
если мы допустили какие-то ошибки,

184
00:13:46,730 --> 00:13:51,850
эти тесты запустятся и нам отсигналят.