1
00:00:00,000 --> 00:00:04,632
[БЕЗ_ЗВУКА] В

2
00:00:04,632 --> 00:00:09,050
этом видео мы поговорим
про пустые интерфейсы.

3
00:00:09,050 --> 00:00:12,770
Пустой интерфейс — это интерфейс,

4
00:00:12,770 --> 00:00:18,445
который может принять в себя
вообще любую переменную,

5
00:00:18,445 --> 00:00:22,680
потому что у него нет никаких
требований к реализации.

6
00:00:22,680 --> 00:00:28,000
Начнём рассматривать пустые
интерфейсы с демонстрации

7
00:00:28,000 --> 00:00:32,060
их работы.

8
00:00:32,060 --> 00:00:37,760
У нас есть вывод, у нас есть наш кошелёк,

9
00:00:37,760 --> 00:00:42,185
и есть вывод нашего
кошелька в двух форматах.

10
00:00:42,185 --> 00:00:47,863
Первый формат — это полное
Go-шное представление

11
00:00:47,863 --> 00:00:53,193
структуры, второй формат — это строка.

12
00:00:53,193 --> 00:00:54,720
Запустим.

13
00:00:54,720 --> 00:01:03,697
Итак, первый

14
00:01:03,697 --> 00:01:08,436
вывод вывел нам прямо

15
00:01:08,436 --> 00:01:14,060
имя структуры вместе со всеми полями
и значениями, которые там есть.

16
00:01:14,060 --> 00:01:20,930
Второй вывод вывел нам какой-то
текст: кошелёк, в котором 100 денег.

17
00:01:20,930 --> 00:01:26,254
Теперь я вам расскажу,
каким образом это получилось,

18
00:01:26,254 --> 00:01:32,980
каким образом функция Printf() догадалась,
что там надо видеть.

19
00:01:32,980 --> 00:01:37,840
Явно, что функция стандартной
библиотеки не знает ничего про тип,

20
00:01:37,840 --> 00:01:40,625
который я только что определил.

21
00:01:40,625 --> 00:01:44,800
На самом деле функция Printf()
принимает в себя пустой интерфейс.

22
00:01:44,800 --> 00:01:50,523
Поэтому мы туда можем передавать
абсолютно любые параметры,

23
00:01:50,523 --> 00:01:54,040
одни за другими, она все из них выведет.

24
00:01:54,040 --> 00:02:00,911
Но каким образом получилось,
что вывелось то, что надо?

25
00:02:00,911 --> 00:02:05,531
Дело в том, что если нашу структуру,

26
00:02:05,531 --> 00:02:11,170
наш тип данных даже реализует
интерфейс Stringer,

27
00:02:11,170 --> 00:02:14,710
который выглядит вот так,

28
00:02:14,710 --> 00:02:22,060
[ЗВУК] это

29
00:02:22,060 --> 00:02:27,310
внутренний тип,

30
00:02:27,310 --> 00:02:34,998
то тогда функция Pintf()
вызовет функцию String,

31
00:02:34,998 --> 00:02:38,960
она, эта структура, например,

32
00:02:38,960 --> 00:02:45,110
которая уже отформатирует вывод так,
как мы хотим.

33
00:02:45,110 --> 00:02:51,090
То есть у моего кошелька есть
метод String(), который возвращает

34
00:02:51,090 --> 00:02:55,680
строку и который как раз форматирует
кошелёк, в котором сколько-то денег.

35
00:02:55,680 --> 00:03:00,536
Пустые интерфейсы — очень полезная вещь,
когда нам

36
00:03:00,536 --> 00:03:05,020
нужно делать совсем генерические функции,
которые работают со всем, чем угодно.

37
00:03:05,020 --> 00:03:10,740
Как внутри происходит преобразование
интерфейсов, я покажу.

38
00:03:10,740 --> 00:03:15,700
Вот функция уже знакомая нам,

39
00:03:15,700 --> 00:03:19,930
функция для оплаты,
которую я немножко переделал.

40
00:03:19,930 --> 00:03:25,430
Теперь она принимает не
интерфейс-платильщик, а пустой интерфейс.

41
00:03:25,430 --> 00:03:29,550
То есть я могу передать туда вообще всё,
что угодно,

42
00:03:29,550 --> 00:03:34,241
и функция должна проверить не на этапе

43
00:03:34,241 --> 00:03:38,930
компиляции соответствие интерфейса,
а уже в runtime'е.

44
00:03:38,930 --> 00:03:43,640
Действительно ли я получу там то,
что надо?

45
00:03:43,640 --> 00:03:48,030
Итак, то есть я определил
пустой интерфейс,

46
00:03:48,030 --> 00:03:53,200
моего плательщика,
объявляю флаг, что всё хорошо.

47
00:03:53,200 --> 00:03:58,760
Теперь я пытаюсь этот интерфейс
преобразовать к плательщику.

48
00:03:58,760 --> 00:04:05,377
То есть я хочу проверить, является ли то,
что мне пришло, интерфейсом?

49
00:04:05,377 --> 00:04:08,680
Если не является, говорю, что нельзя.

50
00:04:08,680 --> 00:04:11,222
Ну а поскольку оно, если является,

51
00:04:11,222 --> 00:04:17,340
я уже присвоил переменную p плательщика,
то я произвожу оплату.

52
00:04:17,340 --> 00:04:22,180
Как это работает?

53
00:04:22,180 --> 00:04:23,460
Отлично.

54
00:04:23,460 --> 00:04:27,020
Мой кошелёк прошёл успешно,

55
00:04:27,020 --> 00:04:32,912
а вот slice int'ов либо
float — они не прошли,

56
00:04:32,912 --> 00:04:37,560
потому что они не реализуют
интерфейс «плательщик».

57
00:04:37,560 --> 00:04:43,610
Это очень мощный инструмент,

58
00:04:43,610 --> 00:04:49,180
и мы будем неоднократно сталкиваться
с применением пустого интерфейса.