1
00:00:00,000 --> 00:00:05,295
[БЕЗ_ЗВУКА] В

2
00:00:05,295 --> 00:00:12,600
этом видео мы рассмотрим такую важную
часть языка Go, как интерфейсы.

3
00:00:12,600 --> 00:00:16,110
Через интерфейсы в Go
реализован полиморфизм,

4
00:00:16,110 --> 00:00:20,210
то есть возможность функции принимать
в себя аргументы различных типов.

5
00:00:20,210 --> 00:00:25,310
В отличие от таких языков,

6
00:00:25,310 --> 00:00:31,530
как C++, Java и PHP, где типизация явная,

7
00:00:31,530 --> 00:00:35,054
в Go реализована утиная типизация.

8
00:00:35,054 --> 00:00:36,190
Что это значит?

9
00:00:36,190 --> 00:00:40,320
В C++, когда вы создаете класс,

10
00:00:40,320 --> 00:00:46,190
вы явно указываете,
что он реализует такой интерфейс.

11
00:00:46,190 --> 00:00:50,652
«Вот мои документы, вот я наследовался
от этого интерфейса, я его реализую,

12
00:00:50,652 --> 00:00:51,374
все хорошо.

13
00:00:51,374 --> 00:00:52,422
Я...
Я — утка.

14
00:00:52,422 --> 00:00:54,140
Я точно знаю, что я — утка».

15
00:00:54,140 --> 00:01:01,320
В Go, когда вы создаете структуру
с методами, она не знает,

16
00:01:01,320 --> 00:01:07,240
какому интерфейсу она соответствует,
то есть типизация неявная.

17
00:01:07,240 --> 00:01:12,853
Там применяется такой
подход: Если это утка,

18
00:01:12,853 --> 00:01:18,830
оно крякает как утка, плавает как
утка и летает как утка, то это утка.

19
00:01:18,830 --> 00:01:23,516
То есть за соблюдение

20
00:01:23,516 --> 00:01:28,532
контракта этого интерфейса
отвечает не сама

21
00:01:28,532 --> 00:01:33,252
структура, а метод,
в который вы ее передаете.

22
00:01:33,252 --> 00:01:38,802
То есть вы передаете в метод,
который принимает определенный интерфейс.

23
00:01:38,802 --> 00:01:42,870
А уже интерфейс описывает,
что если мы хотим сюда попасть,

24
00:01:42,870 --> 00:01:47,626
там должны быть определенные методы.

25
00:01:47,626 --> 00:01:54,566
То есть подход не снизу вверх вот так вот,
а, наоборот, вот так.

26
00:01:54,566 --> 00:02:00,307
То есть вы можете передать
в функцию ту структуру,

27
00:02:00,307 --> 00:02:03,930
даже если она не знает,
что она реализует этот интерфейс.

28
00:02:03,930 --> 00:02:07,500
Давайте посмотрим,
как это работает в коде.

29
00:02:07,500 --> 00:02:15,290
Итак, мы объявляем тип интерфейса,

30
00:02:15,290 --> 00:02:20,204
то есть указываем type,
указываем имя этого интерфейса и ключевое

31
00:02:20,204 --> 00:02:24,897
слово interface, чтобы указать,
что этот тип является интерфейсом.

32
00:02:24,897 --> 00:02:28,940
В данном случае я объявил интерфейс Payer,
то есть «плательщик»,

33
00:02:28,940 --> 00:02:33,870
то есть для того чтобы
соответствовать этому интерфейсу,

34
00:02:33,870 --> 00:02:38,460
мне нужно иметь метод pay,
«заплатить», который принимает в себя

35
00:02:38,460 --> 00:02:43,559
какой-то int и возвращает ошибку.

36
00:02:43,559 --> 00:02:50,260
Дальше я реализую структуру «кошелек»,
у которого есть какое-то поле cash,

37
00:02:50,260 --> 00:02:56,070
то есть количество денег в этом кошельке,
и есть метод «заплатить».

38
00:02:56,070 --> 00:03:02,650
Обратите внимание:

39
00:03:02,650 --> 00:03:07,821
в реализации кошелька нигде нет
упоминания того, что он каким-либо

40
00:03:07,821 --> 00:03:13,975
образом реализует интерфейс «плательщик».

41
00:03:13,975 --> 00:03:15,373
Теперь, как это вызывается.

42
00:03:15,373 --> 00:03:18,720
Есть функция Buy, которая принимает
в себя интерфейс «плательщик».

43
00:03:18,720 --> 00:03:22,346
Она не знает уже,
какая структура туда придет.

44
00:03:22,346 --> 00:03:28,090
Ей просто важно, чтобы то,
что придет в эту функцию,

45
00:03:28,090 --> 00:03:32,280
обладало методом Pay.

46
00:03:32,280 --> 00:03:34,170
Все.

47
00:03:34,170 --> 00:03:38,000
То есть реализовывало этот интерфейс.

48
00:03:38,000 --> 00:03:44,780
Внутри я уже вызываю у того аргумента,
который придал, я вызываю метод Pay,

49
00:03:44,780 --> 00:03:49,740
для того чтобы заплатить,
списать деньги, и все.

50
00:03:49,740 --> 00:03:53,168
Теперь функция main,
то есть я создаю кошелек,

51
00:03:53,168 --> 00:03:57,291
в котором есть какие-то деньги,
и передаю в функцию buy.

52
00:03:57,291 --> 00:04:02,290
Я нигде не делаю никаких преобразований,
ничего, просто передаю сразу как есть.

53
00:04:02,290 --> 00:04:06,360
Давайте посмотрим, как это работает.

54
00:04:06,360 --> 00:04:07,445
Отлично!

55
00:04:07,445 --> 00:04:13,840
«Спасибо за покупку через main.Wallet»,
через кошелек.

56
00:04:13,840 --> 00:04:19,200
T, «спасибо за покупку через кошелек T»,

57
00:04:19,200 --> 00:04:27,920
при указании, что мы хотим тут
получить тип переданного аргумента.

58
00:04:27,920 --> 00:04:30,183
Это был простой пример.

59
00:04:30,183 --> 00:04:36,830
У нас была всего одна структура,
которая реализовывала интерфейс.

60
00:04:36,830 --> 00:04:42,090
Давайте теперь рассмотрим
несколько более сложный пример,

61
00:04:42,090 --> 00:04:48,130
когда у нас есть несколько структур,
которые реализуют интерфейс.

62
00:04:48,130 --> 00:04:52,500
У нас есть кошелек,

63
00:04:52,500 --> 00:04:56,560
он реализует метод Pay, у него есть
какое-то количество денег в нем.

64
00:04:56,560 --> 00:05:03,880
У нас есть карточка, структура в которой:
баланс, дата, до которой она валидна,

65
00:05:03,880 --> 00:05:09,110
CVV, имя карточки, имя владельца,
и она тоже реализует метод Pay.

66
00:05:09,110 --> 00:05:16,312
И есть ApplePay, когда вы прикладываете
телефон для бесконтактной оплаты.

67
00:05:16,312 --> 00:05:20,010
У него есть количество денег на
аккаунте и какой-то AppleID.

68
00:05:20,010 --> 00:05:22,792
И он тоже реализует метод Pay.

69
00:05:22,792 --> 00:05:26,650
Ну и так же наш интерфейс «плательщик»,

70
00:05:26,650 --> 00:05:30,533
который требует,
только чтобы был метод Pay.

71
00:05:30,533 --> 00:05:32,480
И функция «купить».

72
00:05:32,480 --> 00:05:36,770
Теперь я создаю,

73
00:05:36,770 --> 00:05:41,520
смотрите, я создаю кошелек,
и могу через него что-то купить.

74
00:05:41,520 --> 00:05:46,627
Я создаю теперь уже не

75
00:05:46,627 --> 00:05:54,330
сразу, не сразу какой-то объект,
который я буду дальше передавать,

76
00:05:54,330 --> 00:06:00,432
а создаю переменную типа «кошелек»,
типа «плательщик».

77
00:06:00,432 --> 00:06:06,200
И теперь в эту переменную я могу
присваивать любые структуры,

78
00:06:06,200 --> 00:06:09,264
которые реализуют этот кошелек.

79
00:06:09,264 --> 00:06:15,849
То есть я могу не только
ее...Эта проверка на интерфейс

80
00:06:15,849 --> 00:06:19,930
может быть не только при передаче в
функцию, но и при присвоении в переменную.

81
00:06:19,930 --> 00:06:23,354
То есть эта переменная
может иметь тип interface.

82
00:06:23,354 --> 00:06:25,430
Соответственно, вы можете,

83
00:06:25,430 --> 00:06:30,352
при создании структуры вы можете
указывать, что какое-то поле

84
00:06:30,352 --> 00:06:33,790
должно иметь определенный интерфейс,
соответствовать определенному интерфейсу.

85
00:06:33,790 --> 00:06:36,965
И, наконец,

86
00:06:36,965 --> 00:06:41,934
я присваиваю в эту созданную переменную,

87
00:06:41,934 --> 00:06:45,310
которая реализует интерфейс «плательщик»,

88
00:06:45,310 --> 00:06:48,795
я присваиваю уже другую
реализацию этого плательщика.

89
00:06:48,795 --> 00:06:53,261
Если раньше это была карточка,
то теперь это ApplePay.

90
00:06:53,261 --> 00:06:55,410
Ну и надо запустить.

91
00:06:55,410 --> 00:07:02,794
[ЗВУК] Вот я успешно
оплатил через кошелек,

92
00:07:02,794 --> 00:07:07,685
через карточку, а на то, чтобы оплатить

93
00:07:07,685 --> 00:07:12,980
через ApplePay, денег на балансе,
на аккаунте не хватило.

94
00:07:12,980 --> 00:07:15,076
Вот так.

95
00:07:15,076 --> 00:07:20,840
Но иногда нам бывает нужно

96
00:07:20,840 --> 00:07:27,700
не просто вызывать какие-то
методы интерфейса,

97
00:07:27,700 --> 00:07:31,560
но и проверить,
что в действительности нам пришло.

98
00:07:31,560 --> 00:07:40,170
Для этих целей у нас есть
специальная конструкция.

99
00:07:40,170 --> 00:07:44,358
Называется она type switch.

100
00:07:44,358 --> 00:07:48,662
Мы можем, используя эту конструкцию,
мы можем определить,

101
00:07:48,662 --> 00:07:51,650
какой тип к нам пришел,
какой тип лежит по интерфейсу.

102
00:07:51,650 --> 00:07:58,685
Реализуется она через оператор switch,

103
00:07:58,685 --> 00:08:03,221
p и запрос типа в скобочках.

104
00:08:03,221 --> 00:08:10,370
И уже в case нам придут типы,
которые реализует этот...

105
00:08:10,370 --> 00:08:15,440
В case нам придут,

106
00:08:15,440 --> 00:08:21,573
нам будут передаваться типы,
которые может реализовать этот интерфейс.

107
00:08:21,573 --> 00:08:25,950
Смотрите, если у меня интерфейс,

108
00:08:25,950 --> 00:08:32,000
если мой плательщик представлен типом
«кошелек», я напишу «Оплата наличными».

109
00:08:32,000 --> 00:08:40,051
Если мой интерфейс представлен типом Card,

110
00:08:40,051 --> 00:08:47,158
я хочу получить доступ
к данным этой карточки.

111
00:08:47,158 --> 00:08:49,699
Например, проверить имя владельца.

112
00:08:49,699 --> 00:08:51,860
Зачем нужна такая конструкция?

113
00:08:51,860 --> 00:08:56,235
Когда я передаю интерфейс,
эта переменная имеет тип inetrface,

114
00:08:56,235 --> 00:09:01,870
и я не могу обратиться к полям структуры,
которая лежит под этим интерфейсом.

115
00:09:01,870 --> 00:09:04,764
Если я так попробую сделать, будет паника.

116
00:09:04,764 --> 00:09:06,370
Давайте я вам ее покажу.

117
00:09:06,370 --> 00:09:14,370
[ЗВУК]

118
00:09:14,370 --> 00:09:23,627
[ЗВУК] Я сейчас до

119
00:09:23,627 --> 00:09:31,039
преобразования интерфейса в оригинальную
структуру попробую вывести какое-то имя,

120
00:09:31,039 --> 00:09:37,760
вывести имя владельца карточки.

121
00:09:37,760 --> 00:09:43,920
Оп, ошибка!

122
00:09:43,920 --> 00:09:49,600
Cardholder undefined (type Payer
has no field or method Cardholder).

123
00:09:49,600 --> 00:09:51,220
Что это значит?

124
00:09:51,220 --> 00:09:56,305
Что у моего интерфейса,
у него нет такого поля нигде.

125
00:09:56,305 --> 00:10:00,510
Потому что это сейчас не структура,
это интерфейс.

126
00:10:00,510 --> 00:10:04,000
Я могу вызывать только
методы этого интерфейса.

127
00:10:04,000 --> 00:10:08,770
Теперь мне нужно преобразовать.

128
00:10:08,770 --> 00:10:14,820
Итак, я пишу p., входящая моя переменная,

129
00:10:14,820 --> 00:10:22,087
и в скобках я указываю тип,
к которому я хочу его привести.

130
00:10:22,087 --> 00:10:27,248
И мне возвращается уже значение
этого типа и признак того,

131
00:10:27,248 --> 00:10:33,465
получилось ли его преобразовать,
действительно ли он там имеется или нет.

132
00:10:33,465 --> 00:10:37,322
В данном случае я мог бы
опустить обработку ошибки,

133
00:10:37,322 --> 00:10:41,029
потому что я нахожусь под switch case.

134
00:10:41,029 --> 00:10:46,024
Но если вы это преобразовываете
без switch case,

135
00:10:46,024 --> 00:10:50,495
и там действительно может попасться
какая-то другая реализация, не та,

136
00:10:50,495 --> 00:10:53,650
которую вы хотите,
то проверять ошибку, конечно, надо.

137
00:10:53,650 --> 00:10:57,920
Теперь в plasticCard у меня
действительно лежит мой тип Card,

138
00:10:57,920 --> 00:11:03,510
и я могу обратиться к его полям,
это уже не интерфейс.

139
00:11:03,510 --> 00:11:05,300
Ладно.

140
00:11:05,300 --> 00:11:11,700
А теперь, если это не карта,
то я вывожу «Что-то новое!».

141
00:11:11,700 --> 00:11:17,250
Давайте это запустим.

142
00:11:17,250 --> 00:11:18,600
Отлично.

143
00:11:18,600 --> 00:11:22,800
Оплата наличными через Wallet.

144
00:11:22,800 --> 00:11:27,910
«Вставляйте карту, rvasily»,
то есть я обратился к методу

145
00:11:27,910 --> 00:11:32,293
структуры, к структуре Card.

146
00:11:32,293 --> 00:11:36,863
Ну и «Что-то новое!» при ApplePay.

147
00:11:36,863 --> 00:11:38,990
Это интерфейсы.

148
00:11:38,990 --> 00:11:42,493
Далее мы рассмотрим пустой интерфейс,

149
00:11:42,493 --> 00:11:47,210
который позволяет передать в
себя вообще все что угодно.