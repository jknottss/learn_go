[БЕЗ СЛОВ] В этом видео мы проговорим про
систему пакетов в go, а также про область видимости
ваших переменных в этих пакетах. Итак, давайте сначала
рассмотрим базовую структуру. Go работает с так называемой
системной переменной go pass. Это адрес директории, внутри которой должны находиться некоторые
специализированные директории. Первая из них — это папка bin, в нее кладутся собранные бинарники,
то есть либо .exe, либо l-файлы. pkg, в pkg кладутся
временные объектные файлы, а src непосредственно содержит
исходники вашей программы. Например, весь курс у меня лежит в папке coursera. Также если вы вдруг клонируете
какой-то пакет, какую-то библиотеку, например, с github,
то она также будет копироваться в src. Например, github, rvasily и examplerepo положатся вот по этому пути
в соответствующую папку. Но вот давайте теперь рассмотрим
непосредственно область видимости. У меня есть папка coursera,
visibility и в ней пакет person, там лежит два файла: person.go,
func.go и main, который непосредственно
собирает программу. Файл main имеет package main,
потому что тот пакет, который собирается,
у него жестко зафиксировано имя. person уже находится в
папке в пакете person. Обратите внимание,
вот так называется пакет — person. То есть вы не должны прописывать
весь путь, нет, только person, вот он выделен,
поэтому мой пакет называется person, и в нем есть какие-то переменные,
какая-то структура. Итак, в go очень простое правило. Если переменная,
структура, поле структуры, константа, функция начинается
с заглавной буквы, это значит,
что эта сущность экспортируемая, то есть она доступна для
обращения из других пакетов. Если же она начинается со строчной,
это значит, что эта сущность принадлежит
только этому пакету. Обратите внимание. Пакет состоит не из файла,
а из директорий. То есть одна директория, одна директория,
person, это и есть пакет. Следовательно, все,
что я объявлю в файле person.go, будет доступно и из файла func.go,
потому что они составляют один пакет. Давайте посмотрим. Вот у меня экспортируемая переменная,
вот неэкспортируемая. Она доступна только внутри этой программы. Вот структура person, ID и name
эти поля структуры экспортируемы. То есть вы можете обратиться
к ним из другой программы, из другого пакета,
а secret — это приватное поле, вы не можете обращаться к
нему из других пакетов, только из функций этого пакета. Даже не методов этой структуры,
а вообще любых функций этого пакета. Вот, например,
UpdateSecret может обновить секрет. В функциях у меня лежит функция
для создания новой персоны, и получение secret. Обратите внимание: get secret не является
методом персоны, это просто функция, но тем не менее я могу
обратиться к приватному полю. Так же импорты. Импорт распространяется на файл. То есть, если я напишу импорт
в person.go вот здесь, моя программа не соберется, потому что у меня есть
неиспользуемый импорт fmt. Я не могу оставлять
неиспользуемые импорты. Импорт определяется на файл. То есть, если я хочу пользоваться fmt, то
я должен определить его строго в func.go При попытке обращения к приватным полям,
ваша программа просто не скомпилируется. Например, смотрите, visibility\main.go secret
unidentified (cannot refer to unexported field or method). То есть я даже никак не
могу туда достучаться. Поэтому придется
воспользоваться вспомогательной функцией GetSecret,
которая мне его получит. Еще хочется отметить, что в go не принято дробить вашу программу
на миллион маленьких пакетов внутри, чтобы внутри пакета лежал
всего лишь один файл. Правильным подходом считается,
что у вас большие пакеты. Не то чтобы вы вообще сваливаете
всю-всю-всю вашу программу в пакет main, хотя такое тоже бывает, но тем не
менее бесконечно дробить не надо, это будет не так удобно,
и в целом не приветствуется. [БЕЗ СЛОВ] Также в go в последнее время набирает оборот,
что когда вы работаете с проектом, у вас скорее всего не один проект,
и там будет не один go pass. Поэтому там используется Vendor, папка, в которой лежат ваши зависимости,
и используется специальный инструмент, например, gb, либо dep,
которые занимаются управлением этих зависимостей и подтягивают
их в соответствующую папку. Но это мы будет рассматривать позже.