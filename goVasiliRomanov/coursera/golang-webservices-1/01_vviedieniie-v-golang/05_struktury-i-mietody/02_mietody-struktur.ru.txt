[БЕЗ_ЗВУКА] В этом видео мы рассмотрим методы. Метод — это какая-то функция, которая может быть привязана
к определенному типу данных. Для начала рассмотрим методы,
которые привязываются к структурам. Смотрите. У нас есть тип Person. И у нее есть несколько методов. Метод отличается от обычной
функции только тем, что перед определением имени этой
функции добавляется имя типа, для которого определен этот метод,
с указанием роли получателя. Роль получателя — это то, в каком виде этот метод получит тип,
в котором привязан. Это может быть либо по значению передача, то есть вам в метод
передается копия этого типа, либо по адресу, то есть вам в метод
передается адрес на этот тип. В первом случае, например,
в функции UpdateName, любые изменения, вызванные в этом методе,
оригинальную структуру не затронут. На самом деле функция
UpdateName смысла не имеет. В то же время, если мы в качестве
роли указываем адрес на тип, то тогда все изменения,
которые были внесены в структуру, в оригинальные данные, этим методом,
они, конечно же, сохранятся. Давайте посмотрим,
как это работает на практике. Вот мы объявили структуру на строчке 27. И теперь вызываем у нее метод,
SetName "Vasily Romanov". И все работает. Смотрите, теперь имя у нашей структуры то,
которое мы указали в SetName. Но, обратите внимание,
у нас не ссылка на структуру, а прямо сама структура. В то время как «получатель»
указан адрес структуры. Дело в том, что Go определяет, в каком виде мы хотим получить получателя,
либо по значению, либо по адресу, и автоматически
выполняет необходимые преобразования. Например, строчка,
указанная на строчке 28, она для компилятора выглядит вот так,
то что указано на строчке 29, то есть я вызываю адрес от Person нашего и уже у
него указываю SetName. Смотрите. При этом если же у меня это сразу указатель на структуру, вот так или, например, с помощью new(Person), то функция new возвращает мне
сразу указатель на структуру, и это действительно вызов этого метода
происходит, это действительно так и есть. Он сразу происходит по указателю. То есть все как работало, так и работает. Теперь закономерный вопрос:
а что происходит с методами, если я встраиваю одну структуру в другую? Ну, и конечно же, метод наследуется. То есть ваша структура
account в моем примере может иметь доступ ко всем методам структур,
которые в нее встроены. В данном случае она может
иметь доступ к методу SetName. Давайте посмотрим, как это работает. Вот я создал account, создал там Person и вызываю функцию SetName. Теперь давайте выведем ее. Смотрите. Я вызвал метод SetName
у структуры account, которая изменяет поле Name. И смотрите, что получилось. Изначально account создал с указанием
Name "rvasily" и полным именем. Теперь же после изменения
изменилось значение в Person. Как вы помните, сохраняются оба поля name, который был и во встроенной структуре,
и в структуре верхнего уровня. А что будет если я объявлю
структуру у поля account? Будет то же самое, что и при обращении к методам. При вызове account теперь
изменится поле уже аккаунта, поле Name аккаунта, потому что его
метод имеет больший приоритет, чем метод встроенной структуры. Если же я хочу вызвать метод уже
непосредственно у встроенной структуры, то я должен обратиться к нему,
используя полный селектор. Вот так. Вот, смотрите. Теперь первый метод изменил Name,
который был в аккаунте, а второй метод изменил уже те данные,
которые были во встроенной структуре. На самом деле, используя такой подход, используя такую композицию, можно
создавать очень мощные структуры данных. При этом методы могут быть
не только у структур. Давайте я поясню, что я имею в виду. Вы можете объявить какой-то тип, MySlice, int. И уже у этого метода объявлять, уже у этого типа объявлять
какие-то методы. Например, это Slice, туда можно
добавлять значения и получать длину. Давайте реализуем это в методах. [ЗВУК] [ЗВУК] Вот мы реализовали метод для
добавления в данный slice, теперь реализуем метод для получения
количества значений в нем. [ЗВУК] [ЗВУК] Давайте попробуем теперь это все завести. [ЗВУК] Давайте преобразуем просто обычный slice к
нашему новообъявленному типу MySlice. MySlice. Теперь я просто преобразую
обычный Slice в него. Хорошо, теперь давайте
добавим туда что-нибудь. [ЗВУК] И выведем уже количество значений,
которое в нем лежит. Это метод. Ну, и давайте теперь
попробуем все это запустить. Смотрите. Изначально мы инициализировали наш собственный тип всего
двумя значениями — 1, 2, потом мы добавили туда третье значение,
которое является числом 3. 3 неинтересно, давайте сделаем 5. Потом вывели количество элементов в
слайсе и все значение этого слайса. Вот, пожалуйста. Три значения с 1, 2 и 3. Вот. Методы являются очень мощным инструментом, и фактически в Go это тот инструмент, который Go предоставляет вам
для моделирования каких-то действий над сущностями,
которые вы определяете в структуры.