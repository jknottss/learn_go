1
00:00:00,000 --> 00:00:04,929
[БЕЗ_ЗВУКА] В

2
00:00:04,929 --> 00:00:09,540
этом видео мы рассмотрим методы.

3
00:00:09,540 --> 00:00:11,556
Метод — это какая-то функция,

4
00:00:11,556 --> 00:00:15,230
которая может быть привязана
к определенному типу данных.

5
00:00:15,230 --> 00:00:19,460
Для начала рассмотрим методы,
которые привязываются к структурам.

6
00:00:19,460 --> 00:00:21,060
Смотрите.

7
00:00:21,060 --> 00:00:24,100
У нас есть тип Person.

8
00:00:24,100 --> 00:00:26,710
И у нее есть несколько методов.

9
00:00:26,710 --> 00:00:30,772
Метод отличается от обычной
функции только тем,

10
00:00:30,772 --> 00:00:37,952
что перед определением имени этой
функции добавляется имя типа,

11
00:00:37,952 --> 00:00:44,393
для которого определен этот метод,
с указанием роли получателя.

12
00:00:44,393 --> 00:00:46,456
Роль получателя — это то,

13
00:00:46,456 --> 00:00:51,737
в каком виде этот метод получит тип,
в котором привязан.

14
00:00:51,737 --> 00:00:56,040
Это может быть либо по значению передача,

15
00:00:56,040 --> 00:01:01,170
то есть вам в метод
передается копия этого типа,

16
00:01:01,170 --> 00:01:06,410
либо по адресу, то есть вам в метод
передается адрес на этот тип.

17
00:01:06,410 --> 00:01:12,895
В первом случае, например,
в функции UpdateName, любые изменения,

18
00:01:12,895 --> 00:01:18,250
вызванные в этом методе,
оригинальную структуру не затронут.

19
00:01:18,250 --> 00:01:22,605
На самом деле функция
UpdateName смысла не имеет.

20
00:01:22,605 --> 00:01:26,960
В то же время, если мы в качестве
роли указываем адрес на тип,

21
00:01:26,960 --> 00:01:30,870
то тогда все изменения,
которые были внесены в структуру,

22
00:01:30,870 --> 00:01:34,770
в оригинальные данные, этим методом,
они, конечно же, сохранятся.

23
00:01:34,770 --> 00:01:39,830
Давайте посмотрим,
как это работает на практике.

24
00:01:39,830 --> 00:01:43,130
Вот мы объявили структуру на строчке 27.

25
00:01:43,130 --> 00:01:47,780
И теперь вызываем у нее метод,
SetName "Vasily Romanov".

26
00:01:47,780 --> 00:01:53,775
И все работает.

27
00:01:53,775 --> 00:02:02,522
Смотрите, теперь имя у нашей структуры то,
которое мы указали в SetName.

28
00:02:02,522 --> 00:02:07,677
Но, обратите внимание,
у нас не ссылка на структуру,

29
00:02:07,677 --> 00:02:10,310
а прямо сама структура.

30
00:02:10,310 --> 00:02:16,680
В то время как «получатель»
указан адрес структуры.

31
00:02:16,680 --> 00:02:20,072
Дело в том, что Go определяет,

32
00:02:20,072 --> 00:02:25,308
в каком виде мы хотим получить получателя,
либо по значению,

33
00:02:25,308 --> 00:02:30,090
либо по адресу, и автоматически
выполняет необходимые преобразования.

34
00:02:30,090 --> 00:02:35,189
Например, строчка,
указанная на строчке 28,

35
00:02:35,189 --> 00:02:40,231
она для компилятора выглядит вот так,
то что указано на строчке 29,

36
00:02:40,231 --> 00:02:44,924
то есть я вызываю адрес от

37
00:02:44,924 --> 00:02:49,940
Person нашего и уже у
него указываю SetName.

38
00:02:49,940 --> 00:02:52,071
Смотрите.

39
00:02:52,071 --> 00:02:56,960
При этом если же у меня это сразу

40
00:02:56,960 --> 00:03:02,105
указатель на структуру, вот так или,

41
00:03:02,105 --> 00:03:08,460
например, с помощью new(Person),

42
00:03:08,460 --> 00:03:14,887
то функция new возвращает мне
сразу указатель на структуру,

43
00:03:14,887 --> 00:03:19,536
и это действительно вызов этого метода
происходит, это действительно так и есть.

44
00:03:19,536 --> 00:03:21,966
Он сразу происходит по указателю.

45
00:03:21,966 --> 00:03:25,640
То есть все как работало, так и работает.

46
00:03:25,640 --> 00:03:31,420
Теперь закономерный вопрос:
а что происходит с методами,

47
00:03:31,420 --> 00:03:34,090
если я встраиваю одну структуру в другую?

48
00:03:34,090 --> 00:03:38,918
Ну, и конечно же, метод наследуется.

49
00:03:38,918 --> 00:03:44,303
То есть ваша структура
account в моем примере может

50
00:03:44,303 --> 00:03:49,546
иметь доступ ко всем методам структур,
которые в нее встроены.

51
00:03:49,546 --> 00:03:53,504
В данном случае она может
иметь доступ к методу SetName.

52
00:03:53,504 --> 00:03:56,820
Давайте посмотрим, как это работает.

53
00:03:56,820 --> 00:04:01,800
Вот я создал account, создал там Person

54
00:04:01,800 --> 00:04:06,080
и вызываю функцию SetName.

55
00:04:06,080 --> 00:04:10,360
Теперь давайте выведем ее.

56
00:04:10,360 --> 00:04:18,090
Смотрите.

57
00:04:18,090 --> 00:04:26,081
Я вызвал метод SetName
у структуры account,

58
00:04:26,081 --> 00:04:29,960
которая изменяет поле Name.

59
00:04:29,960 --> 00:04:32,022
И смотрите, что получилось.

60
00:04:32,022 --> 00:04:37,531
Изначально account создал с указанием
Name "rvasily" и полным именем.

61
00:04:37,531 --> 00:04:43,003
Теперь же после изменения
изменилось значение в Person.

62
00:04:43,003 --> 00:04:46,584
Как вы помните, сохраняются оба поля name,

63
00:04:46,584 --> 00:04:50,610
который был и во встроенной структуре,
и в структуре верхнего уровня.

64
00:04:50,610 --> 00:04:56,070
А что будет если я объявлю
структуру у поля account?

65
00:04:56,070 --> 00:05:00,790
Будет то же самое,

66
00:05:00,790 --> 00:05:05,875
что и при обращении к методам.

67
00:05:05,875 --> 00:05:11,679
При вызове account теперь
изменится поле уже аккаунта,

68
00:05:11,679 --> 00:05:17,001
поле Name аккаунта, потому что его
метод имеет больший приоритет,

69
00:05:17,001 --> 00:05:19,640
чем метод встроенной структуры.

70
00:05:19,640 --> 00:05:25,600
Если же я хочу вызвать метод уже
непосредственно у встроенной структуры,

71
00:05:25,600 --> 00:05:32,697
то я должен обратиться к нему,
используя полный селектор.

72
00:05:32,697 --> 00:05:34,020
Вот так.

73
00:05:34,020 --> 00:05:36,775
Вот, смотрите.

74
00:05:36,775 --> 00:05:43,155
Теперь первый метод изменил Name,
который был в аккаунте,

75
00:05:43,155 --> 00:05:48,560
а второй метод изменил уже те данные,
которые были во встроенной структуре.

76
00:05:48,560 --> 00:05:53,590
На самом деле, используя такой подход,

77
00:05:53,590 --> 00:05:57,230
используя такую композицию, можно
создавать очень мощные структуры данных.

78
00:05:57,230 --> 00:06:05,470
При этом методы могут быть
не только у структур.

79
00:06:05,470 --> 00:06:08,524
Давайте я поясню, что я имею в виду.

80
00:06:08,524 --> 00:06:11,490
Вы можете объявить какой-то тип,

81
00:06:11,490 --> 00:06:17,157
MySlice, int.

82
00:06:17,157 --> 00:06:21,900
И уже у этого метода объявлять,

83
00:06:21,900 --> 00:06:25,109
уже у этого типа объявлять
какие-то методы.

84
00:06:25,109 --> 00:06:30,372
Например, это Slice, туда можно
добавлять значения и получать длину.

85
00:06:30,372 --> 00:06:33,410
Давайте реализуем это в методах.

86
00:06:33,410 --> 00:06:41,410
[ЗВУК]

87
00:06:41,410 --> 00:06:49,824
[ЗВУК] Вот

88
00:06:49,824 --> 00:06:57,989
мы реализовали метод для
добавления в данный slice,

89
00:06:57,989 --> 00:07:02,640
теперь реализуем метод для получения
количества значений в нем.

90
00:07:02,640 --> 00:07:10,640
[ЗВУК]

91
00:07:10,640 --> 00:07:18,661
[ЗВУК] Давайте

92
00:07:18,661 --> 00:07:24,130
попробуем теперь это все завести.

93
00:07:24,130 --> 00:07:30,812
[ЗВУК] Давайте

94
00:07:30,812 --> 00:07:36,310
преобразуем просто обычный slice к
нашему новообъявленному типу MySlice.

95
00:07:36,310 --> 00:07:37,671
MySlice.

96
00:07:37,671 --> 00:07:43,793
Теперь я просто преобразую
обычный Slice в него.

97
00:07:43,793 --> 00:07:49,100
Хорошо, теперь давайте
добавим туда что-нибудь.

98
00:07:49,100 --> 00:07:54,732
[ЗВУК] И

99
00:07:54,732 --> 00:08:00,140
выведем уже количество значений,
которое в нем лежит.

100
00:08:00,140 --> 00:08:05,350
Это метод.

101
00:08:05,350 --> 00:08:08,430
Ну, и давайте теперь
попробуем все это запустить.

102
00:08:08,430 --> 00:08:13,700
Смотрите.

103
00:08:13,700 --> 00:08:18,220
Изначально мы инициализировали наш

104
00:08:18,220 --> 00:08:22,257
собственный тип всего
двумя значениями — 1, 2,

105
00:08:22,257 --> 00:08:27,680
потом мы добавили туда третье значение,
которое является числом 3.

106
00:08:27,680 --> 00:08:30,192
3 неинтересно, давайте сделаем 5.

107
00:08:30,192 --> 00:08:35,910
Потом вывели количество элементов в
слайсе и все значение этого слайса.

108
00:08:35,910 --> 00:08:38,768
Вот, пожалуйста.

109
00:08:38,768 --> 00:08:43,408
Три значения с 1, 2 и 3.

110
00:08:43,408 --> 00:08:44,600
Вот.

111
00:08:44,600 --> 00:08:48,644
Методы являются очень мощным инструментом,

112
00:08:48,644 --> 00:08:54,513
и фактически в Go это тот инструмент,

113
00:08:54,513 --> 00:09:00,162
который Go предоставляет вам
для моделирования каких-то

114
00:09:00,162 --> 00:09:05,740
действий над сущностями,
которые вы определяете в структуры.