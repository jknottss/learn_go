1
00:00:00,000 --> 00:00:09,411
[БЕЗ_ЗВУКА] В этом видео мы
поговорим про логирование.

2
00:00:09,411 --> 00:00:14,758
Логирование — это очень важная часть любой
программы, которая делает что-либо важное.

3
00:00:14,758 --> 00:00:17,900
Потому что логирование — это
признаки жизни программы.

4
00:00:17,900 --> 00:00:24,036
Конечно, можно сказать, что вот если
программа ест prods, то она работает.

5
00:00:24,036 --> 00:00:25,828
Однако это не всегда так.

6
00:00:25,828 --> 00:00:29,852
Она может уйти в какой-нибудь
вечный цикл или еще что-то,

7
00:00:29,852 --> 00:00:33,830
и не понятно будет,
действительно она работает или не зависла.

8
00:00:33,830 --> 00:00:38,870
Также без логов вы не сможете понимать,

9
00:00:38,870 --> 00:00:43,548
правильно работает ваша программа,
либо же там постоянно какие-то ошибки,

10
00:00:43,548 --> 00:00:47,957
а все запросы, которые туда приходят,
оканчиваются неудачей.

11
00:00:47,957 --> 00:00:53,354
В этом видео мы поговорим про
несколько подходов к логированию.

12
00:00:53,354 --> 00:00:59,229
Мы рассмотрим стандартную библиотеку,
что является для логирования.

13
00:00:59,229 --> 00:01:06,440
Мы рассмотрим логгер под названием
ZAP и логгер под названием Logrus.

14
00:01:06,440 --> 00:01:11,080
Для начала есть fmt,

15
00:01:11,080 --> 00:01:16,757
пакет Printf,
при помощи которого можно что-то вывести.

16
00:01:16,757 --> 00:01:20,461
Однако для логирования он
не то чтобы очень подходит,

17
00:01:20,461 --> 00:01:23,430
потому что по умолчанию
все выводит в std out.

18
00:01:23,430 --> 00:01:28,151
То есть логировать через fmt
допустимо на этапе отладки

19
00:01:28,151 --> 00:01:31,370
либо в учебных примерах, как у меня.

20
00:01:31,370 --> 00:01:36,910
Для более-менее уже

21
00:01:36,910 --> 00:01:42,540
продакшн-логирования стандартная
библиотека предоставляет пакет log.

22
00:01:42,540 --> 00:01:48,260
Он в стандартной библиотеке.

23
00:01:48,260 --> 00:01:51,277
Это, в общем-то, обертка от Printf,

24
00:01:51,277 --> 00:01:55,104
однако вы можете направить
его вывод в другое место.

25
00:01:55,104 --> 00:01:56,770
По умолчанию это stdr.

26
00:01:56,770 --> 00:02:00,260
И писать ему туда какую-нибудь
дополнительную информацию.

27
00:02:00,260 --> 00:02:02,968
Например, время, строчку и что-то еще.

28
00:02:02,968 --> 00:02:06,930
Также его можно завернуть в
syslog — тоже из коробки.

29
00:02:06,930 --> 00:02:07,433
ZAP.

30
00:02:07,433 --> 00:02:11,970
ZAP — это логгер,
который был разработан в Google.

31
00:02:11,970 --> 00:02:17,906
У него нет логгера по умолчанию,
его нужно создавать.

32
00:02:17,906 --> 00:02:22,443
Он отличается структурным логированием.

33
00:02:22,443 --> 00:02:24,129
Что это значит?

34
00:02:24,129 --> 00:02:27,304
Это значит, что там нельзя написать %s,

35
00:02:27,304 --> 00:02:30,675
вот как в Printf'е,
и он там быстро что-то преобразует.

36
00:02:30,675 --> 00:02:37,328
Нет, вы должны четко указывать, какого
типа параметры вы хотите туда передавать.

37
00:02:37,328 --> 00:02:41,961
За счет этого в ZAP'е нет аллокации
памяти во время выполнения,

38
00:02:41,961 --> 00:02:45,370
нет пустых интерфейсов,
которые есть в Printf'е.

39
00:02:45,370 --> 00:02:48,412
Потому что вы туда
передаете любые значения,

40
00:02:48,412 --> 00:02:50,830
и он должен это уметь обрабатывать.

41
00:02:50,830 --> 00:02:51,914
И Logrus.

42
00:02:51,914 --> 00:02:57,580
Logrus вроде как тоже имеет
структурное логирование,

43
00:02:57,580 --> 00:03:02,161
но на самом деле это структурное
логирование — это map[string]interface,

44
00:03:02,161 --> 00:03:05,460
то есть как говорится,
те же яйца, только в профиль.

45
00:03:05,460 --> 00:03:07,980
Но у Logrus'а есть другие достоинства.

46
00:03:07,980 --> 00:03:11,334
Для начала посмотрим, как вообще выводить.

47
00:03:11,334 --> 00:03:13,400
Ну, fmt Printf — понятно.

48
00:03:13,400 --> 00:03:15,752
ZAP.
В ZAP можно добавить соответственно

49
00:03:15,752 --> 00:03:18,960
дополнительные параметры и
вывести какую-то строчку.

50
00:03:18,960 --> 00:03:25,129
В Logrus можно тоже дополнительно добавить
дополнительные структурные поля и

51
00:03:25,129 --> 00:03:30,780
вывести info,
либо любой другой уровень логирования.

52
00:03:30,780 --> 00:03:34,860
Рассмотрим, как этим пользоваться
на примере access лога.

53
00:03:34,860 --> 00:03:38,852
Вот я сделал у себя
структуру AccessLogger,

54
00:03:38,852 --> 00:03:45,112
там целых три логгера в ней: стандартный,
ZAP и Logger.

55
00:03:45,112 --> 00:03:47,585
Так, я начинаю создавать свои логгеры.

56
00:03:47,585 --> 00:03:48,857
Так, логирование.

57
00:03:48,857 --> 00:03:53,200
Я создаю новое логирование, мне он
пишет в stdout с каким-то префиксом.

58
00:03:53,200 --> 00:04:01,310
Время оно будет писать в utc и будет
добавлять строчку, на которой была ошибка.

59
00:04:01,310 --> 00:04:05,510
Это очень удобно во время отладки,
например,

60
00:04:05,510 --> 00:04:10,623
однако довольно дорого, потому что нам
придется пройтись в рантайме по стэку.

61
00:04:10,623 --> 00:04:17,306
Если логов у вас будет очень много,
это грузит программу.

62
00:04:17,306 --> 00:04:18,469
Так.

63
00:04:18,469 --> 00:04:23,240
Логгер ZAP, я создаю,

64
00:04:23,240 --> 00:04:27,628
собственно, отдельный логгер Sugar.

65
00:04:27,628 --> 00:04:32,398
Sugar — ну это отдельная
такая надстройка над ZAP'ом,

66
00:04:32,398 --> 00:04:38,266
которая позволяет выводить
какие-то данные вроде

67
00:04:38,266 --> 00:04:42,070
Printf.

68
00:04:42,070 --> 00:04:42,715
И Logrus.

69
00:04:42,715 --> 00:04:45,225
Logrus я тоже создаю, я сразу указываю,

70
00:04:45,225 --> 00:04:48,250
что Logrus у меня будет
форматировать все в JSON.

71
00:04:48,250 --> 00:04:53,868
Ну и оборачиваю все свои
запросы в метод accessLog.

72
00:04:53,868 --> 00:04:56,116
Метод — это структура.

73
00:04:56,116 --> 00:04:59,764
Обратите внимание, раньше у меня в виде

74
00:04:59,764 --> 00:05:04,392
Middleware выступали
просто отдельные функции,

75
00:05:04,392 --> 00:05:09,290
которые были полностью
автономной вещью в себе.

76
00:05:09,290 --> 00:05:16,119
Однако в данном случае я оборачиваю
уже в метод структуры, соответственно,

77
00:05:16,119 --> 00:05:20,246
из этого метода я могу обращаться к
каким-то отдельным полям структуры, чем я

78
00:05:20,246 --> 00:05:26,357
и воспользуюсь, потому что в AccessLogOut
у меня аж три логгера, я напомню.

79
00:05:26,357 --> 00:05:28,285
Итак, для вывода.

80
00:05:28,285 --> 00:05:32,081
Я могу вывести все просто через
Printf все, что мне надо.

81
00:05:32,081 --> 00:05:35,650
Это очень просто делается,
в одну строчку и красиво.

82
00:05:35,650 --> 00:05:39,793
Однако все эти значения будут
приведены к пустому интерфейсу,

83
00:05:39,793 --> 00:05:43,160
что будет создавать понемножку локаций.

84
00:05:43,160 --> 00:05:47,139
Через лог,
в общем-то то же самое через Printf,

85
00:05:47,139 --> 00:05:51,162
но тут добавится уже то, что я хочу сам.

86
00:05:51,162 --> 00:05:55,307
Через std logger — это тот логгер,

87
00:05:55,307 --> 00:06:01,071
который я указал в моей структуре,
то есть там добавится мой префикс,

88
00:06:01,071 --> 00:06:05,608
там добавится время
запросов в utc и строчка.

89
00:06:05,608 --> 00:06:06,280
ZAP.

90
00:06:06,280 --> 00:06:14,677
Я логгирую Path, и все мои параметры
я привожу к конкретному типу данных.

91
00:06:14,677 --> 00:06:16,530
За счет этого нет локаций.

92
00:06:16,530 --> 00:06:23,930
Мой Logrus, в котором я тоже передаю вроде
бы то же самое, однако аллокации там есть.

93
00:06:23,930 --> 00:06:26,523
Ну теперь это стоит запустить.

94
00:06:26,523 --> 00:06:32,336
Вот строчка, которая была выведена
стандартным абсолютно логгером,

95
00:06:32,336 --> 00:06:35,780
который идет прямо стандартный для пакета.

96
00:06:35,780 --> 00:06:37,185
Далее, ZAP.

97
00:06:37,185 --> 00:06:43,274
Обратите внимание, у нас уже все
выведено в виде красивого JSON'а,

98
00:06:43,274 --> 00:06:50,480
который очень удобно парсить какими-либо
средствами, внешними программами.

99
00:06:50,480 --> 00:06:51,368
И Logrus.

100
00:06:51,368 --> 00:06:54,528
По умолчанию он выводит не в JSON'е.

101
00:06:54,528 --> 00:07:00,554
Теперь я хочу получить какой-то запрос,
отправить какой-то запрос на сервер.

102
00:07:00,554 --> 00:07:01,860
Например, вот так.

103
00:07:01,860 --> 00:07:05,223
И мне выдалось много всякого.

104
00:07:05,223 --> 00:07:06,390
Смотрим.

105
00:07:06,390 --> 00:07:09,319
Вот стандартный логгер.

106
00:07:09,319 --> 00:07:13,771
То есть префикс мой std,
мы на 36-й строчке,

107
00:07:13,771 --> 00:07:20,173
то есть указалась строчка, где все
это происходит, этот тип get запрос,

108
00:07:20,173 --> 00:07:24,551
порт, метод, и одна миллисекунда заняла.

109
00:07:24,551 --> 00:07:28,598
Далее выводит ZAP,
лог ZAP тоже уже побольше,

110
00:07:28,598 --> 00:07:31,840
но в целом ровно та же самая информация.

111
00:07:31,840 --> 00:07:35,046
И в конце выводит Logrus.

112
00:07:35,046 --> 00:07:41,827
Вроде бы ZAP и Logrus они похожи,
они выводят тоже оба много информации.

113
00:07:41,827 --> 00:07:43,569
В чем между ними разница?

114
00:07:43,569 --> 00:07:46,430
Когда использовать один, когда другой?

115
00:07:46,430 --> 00:07:48,861
Начнем с Logrus'а.

116
00:07:48,861 --> 00:07:53,506
Logrus медленный, однако у него

117
00:07:53,506 --> 00:07:58,191
очень много приемников, точнее модулей,

118
00:07:58,191 --> 00:08:02,730
которые отправляют в нужный
приемник в нужном формате.

119
00:08:02,730 --> 00:08:07,490
Соответственно, если вы хотите
слать логи в разные места,

120
00:08:07,490 --> 00:08:12,160
например, тут есть Fluentd,
есть Slack даже,

121
00:08:12,160 --> 00:08:18,089
если вы хотите слать в разные места,
то, возможно, логгер вам подойдет.

122
00:08:18,089 --> 00:08:22,135
Однако Logrus не очень производительный.

123
00:08:22,135 --> 00:08:28,110
Вот бич марки ZAP'а,
Logrus медленнее ZAP'а

124
00:08:28,110 --> 00:08:33,030
в восемь раз,
а локаций там почти в 30 раз больше.

125
00:08:33,030 --> 00:08:37,903
Поэтому если у вас логов
очень-очень много и вы хотите

126
00:08:37,903 --> 00:08:42,200
их просто в какое-то одно место писать,

127
00:08:42,200 --> 00:08:46,624
и вам важна производительность, то,

128
00:08:46,624 --> 00:08:52,318
возможно, логгер ZAP будет
хорошим выбором для этих целей.

129
00:08:52,318 --> 00:08:57,490
Ну, а если вам все равно, то, конечно же,
вы можете использовать стандартный

130
00:08:57,490 --> 00:09:02,740
лог из стандартной библиотеки
и не заморачиваться.