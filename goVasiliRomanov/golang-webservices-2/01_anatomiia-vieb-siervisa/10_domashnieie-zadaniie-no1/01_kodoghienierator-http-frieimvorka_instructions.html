<meta charset="utf-8"/>
<co-content>
 <p>
  <strong>
   Во всех заданиях курса тесты являются частью задания, не пытайтесь понять задачу только по описанию, смотрите тесты
  </strong>
 </p>
 <p>
  Кодогенерация очень широко используется в го и надо уметь пользоваться этим инструментом.
 </p>
 <asset assettype="generic" extension="zip" id="gIcHsyLDEeiJBQqNZNfxKg" name="hw5_codegen">
 </asset>
 <p>
  В этом задании вам необходимо будет написать кодогенератор, который ищет методы структуры, помеченные спец меткой и генерирует для них следующий код:
 </p>
 <ul bullettype="bullets">
  <li>
   <p>
    http-обёртки для этих методов
   </p>
  </li>
  <li>
   <p>
    проверку авторизации
   </p>
  </li>
  <li>
   <p>
    проверки метода (GET/POST)
   </p>
  </li>
  <li>
   <p>
    валидацию параметров
   </p>
  </li>
  <li>
   <p>
    заполнение структуры с параметрами метода
   </p>
  </li>
  <li>
   <p>
    обработку неизвестных ошибок
   </p>
  </li>
 </ul>
 <p>
  Т.е. вы пишите программу (в файле`handlers_gen/codegen.go`) потом запускаете её, передавая в качестве параметров путь до файла для которого надо сгенерировать код, и путь до файла, в который записать результат. Запуск будет выглядеть примерно так: `go build handlers_gen/* &amp;&amp; ./codegen api.go api_handlers.go`. Т.е. запускаться он будет как `бинарник_кодогенератора что_парсим.го куда_парсим.го`
 </p>
 <p>
  Хардкодить не надо. Все данные - имена полей, доступные значения, граничные значения - всё брать из самой структуры, struct tags `apivalidator` и кода который мы парсим.
 </p>
 <p>
  Если вы руками вписываете имя структуры, которое должно попасть в результирующий код после генерации - значит вы делаете не правильно, даже если у вас проходят тесты. Ваш кодогенератор должен работать универсально для любых полей и значений из тех что ему известны. Писать код надо так, чтобы он отработал на неизвестном вам коде, аналогичном api.go.
 </p>
 <p>
  Единственное чем можно пользоваться - `type ApiError struct` при проверке ошибки. Считаем что это какая-то общеизвестная структура.
 </p>
 <p>
  Кодогенератор умеет обрабатывать следующие типы полей структуры:
 </p>
 <ul bullettype="bullets">
  <li>
   <p>
    int
   </p>
  </li>
  <li>
   <p>
    string
   </p>
  </li>
 </ul>
 <p>
  Нам доступны следующие метки валидатора-заполнятора `apivalidator`:
 </p>
 <ul bullettype="bullets">
  <li>
   <p>
    required - поле не должно быть пустым (не должно иметь значение по-умолчанию)
   </p>
  </li>
  <li>
   <p>
    paramname - если указано - то брать из параметра с этим именем, иначе lowercase от имени
   </p>
  </li>
  <li>
   <p>
    enum - "одно из"
   </p>
  </li>
  <li>
   <p>
    default - если указано и приходит пустое значение (значение по-умолчанию) - устанавливать то что написано указано в default
   </p>
  </li>
  <li>
   <p>
    min - &gt;= X для типа int, для строк len(str) &gt;=
   </p>
  </li>
  <li>
   <p>
    max - &lt;= X для типа int
   </p>
  </li>
 </ul>
 <p>
  Формат ошибок смотрите в тестах. Порядок следования ошибок:
 </p>
 <ul bullettype="bullets">
  <li>
   <p>
    наличие метода (в ServeHTTP)
   </p>
  </li>
  <li>
   <p>
    метод (POST)
   </p>
  </li>
  <li>
   <p>
    авторизация
   </p>
  </li>
  <li>
   <p>
    параметры в порядке следования в структуре
   </p>
  </li>
 </ul>
 <p>
  Авторизация проверяется просто на то что в хедере пришло значение `100500`
 </p>
 <p>
  Сгенерированный код будет иметь примерно такую цепочку
 </p>
 <ul bullettype="bullets">
  <li>
   <p>
    `ServeHTTP` - принимает все методы из мультиплексора, если нашлось - вызывает `handler$methodName`, если нет - говорит 404
   </p>
  </li>
  <li>
   <p>
    `handler$methodName` - обёртка над методом структуры `$methodName` - осуществляет все проверки, выводит ошибки или результат в формате JSON
   </p>
  </li>
  <li>
   <p>
    `$methodName` - непосредственно метод структуры для которого мы генерируем код и который парсим. имеет префикс `apigen:api` за который следует json с именем метода, типом и требованием авторизации. Его генерировать не нужно, он уже есть.
   </p>
  </li>
 </ul>
 <p>
 </p>
 <pre language="plain_text">type SomeStructName struct{}

func (h *SomeStructName ) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	switch r.URL.Path {
	case "...":
		h.wrapperDoSomeJob(w, r)
	default:
		// 404
	}
}

func (h *SomeStructName ) wrapperDoSomeJob() {
	// заполнение структуры params
	// валидирование параметров
	res, err := h.DoSomeJob(ctx, params)
	// прочие обработки
}</pre>
 <p>
  По структуре кодогенератора - надо найти все методы, для каждого метода сгенерировать валидацию входящих параметров и прочие проверки в handler$methodName, для пачки методов структуры сгенерировать обвязку в ServeHTTP
 </p>
 <p>
  Над ошибками кодогенератора можно сильно не заморачиваться - параметры который в него передаются будем считать гарантированно корректными.
 </p>
 <p>
  Пример для кодогенерации смотрите в папке с заданием.
 </p>
 <p>
  Что надо парсить в ast:
 </p>
 <ul bullettype="bullets">
  <li>
   <p>
    node.Decls -&gt; ast.FuncDecl - это метод. у него надо проверить что есть метка и начать генерировать для него обёртку
   </p>
  </li>
  <li>
   <p>
    node.Decls -&gt; ast.GenDecl -&gt; spec.(*ast.TypeSpec) + currType.Type.(*ast.StructType) - это структура. она нужна чтобы по ней генерить валидацию для метода, который мы нашли в предыдущем пункте
   </p>
  </li>
  <li>
   <p>
    <a href="https://golang.org/pkg/go/ast/#FuncDecl" title="">
     https://golang.org/pkg/go/ast/#FuncDecl
    </a>
    - тут смотрите к какой структуре относится метод
   </p>
  </li>
 </ul>
 <p>
  Вы можете использовать как шаблоны чтобы сгенерировать сразу весь метод, так и собирать код из маленьких кусков.
 </p>
 <p>
  Структура директории с заданием:
 </p>
 <ul bullettype="bullets">
  <li>
   <p>
    example/ - пример с кодогенерацией из 3-й лекции 1-й части курса. Можно этот код взять за основу.
   </p>
  </li>
  <li>
   <p>
    handlers_gen/codegen.go - сюда вам писать код
   </p>
  </li>
  <li>
   <p>
    api.go - этот файл вам надо скармливать в кодогенератор. редактировать его не надо
   </p>
  </li>
  <li>
   <p>
    main.go - тут всё ясно. редактировать не надо
   </p>
  </li>
  <li>
   <p>
    main_test.go - этот файл надо запускать для тестирования после кодогенерации. редактировать не надо
   </p>
  </li>
 </ul>
 <p>
  Запуск тестов будет происходить так:
 </p>
 <pre language="sh"># находясь в этой папке

# расширение .exe только для счастливых обладателей windows

# собирает кодогенератор и сразу же запускает генерацию http-хендлеров для файла api.go, записывая результат в api_handlers.go

go build handlers_gen/* &amp;&amp; ./codegen.exe api.go api_handlers.go

# запуск тестов

go test -v</pre>
 <p>
  Примечание
 </p>
 <ul bullettype="bullets">
  <li>
   <p>
    В тесты закралась ошибка "login must
    <strong>
     me
    </strong>
    not empty". Но поскольку оно было обнаружено после старта - считает что это фича, чтобы не сломать код других людей и обрабатываем "empty"-поля c "me
   </p>
  </li>
  <li>
   <p>
    Если при загрузке задания выдаёт ошибку `Test failed - preparation step - codegen compilation failed` - убедитесь что у вас не используются внешние библиотеки, уже было несколько случаев что подставлялся какой-то другой пакет с шаблонизатором, не из стандартной библиотеки
   </p>
  </li>
  <li>
   <p>
    Никакие внешние библиотеки в сгенерированном коде так же использовать нельзя - на сервере их нету
   </p>
  </li>
 </ul>
</co-content>
<style>
 body {
    padding: 50px 85px 50px 85px;
}

table th, table td {
    border: 1px solid #e0e0e0;
    padding: 5px 20px;
    text-align: left;
}
input {
    margin: 10px;
}
}
th {
    font-weight: bold;
}
td, th {
    display: table-cell;
    vertical-align: inherit;
}
img {
    height: auto;
    max-width: 100%;
}
pre {
    display: block;
    margin: 20px;
    background: #424242;
    color: #fff;
    font-size: 13px;
    white-space: pre-wrap;
    padding: 9.5px;
    margin: 0 0 10px;
    border: 1px solid #ccc;
}
</style>
<script async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$$','$$'], ['$','$'] ],
      displayMath: [ ["\\[","\\]"] ],
      processEscapes: true
    }
  });
</script>
