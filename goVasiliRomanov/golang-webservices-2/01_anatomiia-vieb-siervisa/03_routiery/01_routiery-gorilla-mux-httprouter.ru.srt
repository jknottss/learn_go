1
00:00:00,000 --> 00:00:07,190
[БЕЗ_ЗВУКА] В этом видео

2
00:00:07,190 --> 00:00:12,870
мы поговорим про альтернативные роутеры,
альтернативные мультиплексоры запросов.

3
00:00:12,870 --> 00:00:19,016
Дело в том, что стандартный мультиплексор,
он несмотря на то,

4
00:00:19,016 --> 00:00:23,900
что весьма производителен,
он довольно ограничен в своих функциях.

5
00:00:23,900 --> 00:00:31,165
Например, в нем нельзя указать, для какого
метода должен работать заданный url,

6
00:00:31,165 --> 00:00:35,694
и также там нельзя парсить
параметры напрямую из url'а.

7
00:00:35,694 --> 00:00:37,170
Только queryParams.

8
00:00:37,170 --> 00:00:42,941
Однако иногда это бывает очень нужно,

9
00:00:42,941 --> 00:00:47,320
если мы хотим сделать ЧПУ
— человекопонятный url,

10
00:00:47,320 --> 00:00:53,340
либо же у нас web-приложение
построено по архитектуре REST.

11
00:00:53,340 --> 00:00:58,600
В этом случае, стоит обратиться
к альтернативным реализациям.

12
00:00:58,600 --> 00:01:04,115
Первая ось из рассматриваемых
— это gorilla/mux.

13
00:01:04,115 --> 00:01:07,180
Gorilla — это набор web-компонентов,

14
00:01:07,180 --> 00:01:11,170
там есть помимо роутера еще
довольно много всего интересного.

15
00:01:11,170 --> 00:01:16,880
Вот, это довольно функциональный роутер,

16
00:01:16,880 --> 00:01:21,173
у него есть возможность
ограничивать по методам,

17
00:01:21,173 --> 00:01:25,704
по хостам, по даже query-параметрам,

18
00:01:25,704 --> 00:01:29,825
либо можно написать какую-нибудь
свою функцию для того,

19
00:01:29,825 --> 00:01:32,919
чтобы определять,
куда пускать этот роутер или нет.

20
00:01:32,919 --> 00:01:35,080
Посмотрим, как это выглядит в коде.

21
00:01:35,080 --> 00:01:39,832
Для начала можно подрубить,
собственно, gorilla/mux.

22
00:01:39,832 --> 00:01:44,142
Это внешний пакет,
это у же не стандартная библиотека.

23
00:01:44,142 --> 00:01:46,460
А дальше все почти то же самое.

24
00:01:46,460 --> 00:01:51,616
То есть есть Handle.func,
им можем обработать нашу функцию.

25
00:01:51,616 --> 00:01:55,630
Есть возможность указать для
какого хоста она будет работать,

26
00:01:55,630 --> 00:01:58,761
для каких методов,
либо даже для каких header'ов.

27
00:01:58,761 --> 00:02:01,340
То есть на самом деле
это выглядит вот так.

28
00:02:01,340 --> 00:02:05,920
То есть я делаю цепочку
вызовов для ограничений.

29
00:02:05,920 --> 00:02:11,740
И вот например, можно указывать

30
00:02:11,740 --> 00:02:16,499
параметры, которые мы
хотим распарсить из url'а.

31
00:02:16,499 --> 00:02:21,672
Например, вот я тут буду вытаскивать
только целочисленные id,

32
00:02:21,672 --> 00:02:25,640
тут я буду вытаскивать логи, которые,
может быть, имеют любое значение.

33
00:02:25,640 --> 00:02:29,648
Ну соответственно я могу
сделать даже вот так.

34
00:02:29,648 --> 00:02:35,870
То есть я могу вытаскивать параметры
не из конца, а из середины.

35
00:02:35,870 --> 00:02:40,950
Могу вытаскивать несколько
значений вот таким вот образом.

36
00:02:40,950 --> 00:02:42,896
То есть это мощный роутер.

37
00:02:42,896 --> 00:02:45,434
Для того чтобы получить значение,

38
00:02:45,434 --> 00:02:50,574
я должен обратиться к функции
получения значений из request'а.

39
00:02:50,574 --> 00:02:52,900
Оно сохраняется там внутри.

40
00:02:52,900 --> 00:02:59,577
Это роутер, он полностью взаимозаменяемый
со стандартным в том плане, что его

41
00:02:59,577 --> 00:03:05,470
запросы (то есть те параметры, которым он
передает запросы), полностью совместимы.

42
00:03:05,470 --> 00:03:06,077
Вот.

43
00:03:06,077 --> 00:03:11,430
Однако если посмотреть
на benchmark'и роутеров,

44
00:03:11,430 --> 00:03:18,930
то Gorilla Mux один из самых медленных.

45
00:03:18,930 --> 00:03:22,413
Да, у него очень много возможностей,

46
00:03:22,413 --> 00:03:28,450
однако наличие этих возможностей имеет
свою цену, то есть работает он медленнее.

47
00:03:28,450 --> 00:03:31,747
Но иногда нам нужны его возможности,

48
00:03:31,747 --> 00:03:36,590
а иногда нам нужны немножко
возможности и хорошая скорость.

49
00:03:36,590 --> 00:03:40,117
Давайте рассмотрим еще один роутер,
HttpRouter.

50
00:03:40,117 --> 00:03:42,930
Как видите, он весьма производителен.

51
00:03:42,930 --> 00:03:50,065
Он построен на технологии Prefix Tree,
или Radix Tree.

52
00:03:50,065 --> 00:03:52,960
Как он работает?

53
00:03:52,960 --> 00:03:55,228
Итак, смотрим код.

54
00:03:55,228 --> 00:04:00,020
То есть у него можно
прямо указать параметр,

55
00:04:00,020 --> 00:04:03,130
на котором будет работать этот метод.

56
00:04:03,130 --> 00:04:05,529
У него можно указать,

57
00:04:05,529 --> 00:04:11,435
что мы хотим распарсить какую-то
часть url'а в переменную.

58
00:04:11,435 --> 00:04:17,770
Однако здесь нет матчинга по регулярке,
то есть нельзя указать, что только цифры.

59
00:04:17,770 --> 00:04:24,230
И еще у этого роутера, у него другая
сигнатура самих функций, самих handler'ов.

60
00:04:24,230 --> 00:04:28,618
У него добавляется еще его
четвертое значение Params.

61
00:04:28,618 --> 00:04:33,523
Да, конечно вы можете это обойти тем,
что делать обертку

62
00:04:33,523 --> 00:04:38,750
нестандартными методами,
или там какую-то прослойку

63
00:04:38,750 --> 00:04:44,157
делать с промежуточным кодом,
но вот вызывает он так.

64
00:04:44,157 --> 00:04:50,500
Однако работает он очень быстро, поэтому,
возможно, вам будет это интересно.

65
00:04:50,500 --> 00:04:56,673
Но иногда тоже бывает, не хочется
выбирать: я хочу либо возможности,

66
00:04:56,673 --> 00:05:02,363
и я хочу скорость, я хочу в одном месте
возможности, а в другом месте — скорость.

67
00:05:02,363 --> 00:05:03,050
Как быть?

68
00:05:03,050 --> 00:05:08,050
Дело в том,
что опять-таки вы не ограничены

69
00:05:08,050 --> 00:05:11,905
только в выборе одного роутера,
вы можете взять их столько,

70
00:05:11,905 --> 00:05:17,630
сколько вам надо для тех мест,
которые вам нужны.

71
00:05:17,630 --> 00:05:23,230
Вот пример,
который совмещает сразу все три роутера.

72
00:05:23,230 --> 00:05:29,380
Быстрый роутер, который будет
обрабатывать только url /fast/,

73
00:05:29,380 --> 00:05:34,920
допустим, если у вас там много каких-то,

74
00:05:34,920 --> 00:05:41,361
большая нагрузка туда идет, и вам нужен
параметр id, например, вот так вот.

75
00:05:41,361 --> 00:05:48,546
То есть вам действительно нужно парсить
параметры из url'а и вы хотите скорости.

76
00:05:48,546 --> 00:05:53,354
В следующий вариант,
следующий роутер у нас не очень

77
00:05:53,354 --> 00:05:58,356
много запросов, но у нас тем не менее
мы хотим какую-то сложную логику,

78
00:05:58,356 --> 00:06:03,163
мы хотим там фильтровать по хосту,
мы хотим фильтровать по заголовкам.

79
00:06:03,163 --> 00:06:08,308
Вот в этом примере я эту функцию,
мой ComplexRequest,

80
00:06:08,308 --> 00:06:11,800
я разрешаю только для ajax-запросов.

81
00:06:11,800 --> 00:06:16,440
Ну наконец, стандартный роутер,
когда нам не нужно парсить запросы,

82
00:06:16,440 --> 00:06:19,040
и который работает очень быстро.

83
00:06:19,040 --> 00:06:24,029
И соответственно, я могу теперь,
используя стандартный даже мультиплексор,

84
00:06:24,029 --> 00:06:28,660
совместить все три этих подхода в один.

85
00:06:28,660 --> 00:06:34,364
То есть я могу на некоторых частях
url'ов обрабатывать одним роутером,

86
00:06:34,364 --> 00:06:36,910
на некоторых частях — другим роутером.

87
00:06:36,910 --> 00:06:39,800
За счет этого я получаю в
нужном мне месте скорость,

88
00:06:39,800 --> 00:06:41,780
в нужном мне месте — возможности.

89
00:06:41,780 --> 00:06:48,765
Конечно, у вас иногда
может кипеть мозг от того,

90
00:06:48,765 --> 00:06:52,560
что здесь у вас сигнатура функции такая,
потому что используется такой роутер,

91
00:06:52,560 --> 00:06:56,110
здесь параметры нужно получать таким
образом, а если вы замените роутер,

92
00:06:56,110 --> 00:07:00,747
нужно будет получать другим образом,
но в одном месте мы сложность убираем,

93
00:07:00,747 --> 00:07:03,640
в другом месте мы сложность добавляем.

94
00:07:03,640 --> 00:07:06,700
Честное равновесие.

95
00:07:06,700 --> 00:07:07,990
Вот так.