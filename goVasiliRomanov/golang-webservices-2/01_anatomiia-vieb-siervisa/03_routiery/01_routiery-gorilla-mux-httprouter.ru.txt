[БЕЗ_ЗВУКА] В этом видео мы поговорим про альтернативные роутеры,
альтернативные мультиплексоры запросов. Дело в том, что стандартный мультиплексор,
он несмотря на то, что весьма производителен,
он довольно ограничен в своих функциях. Например, в нем нельзя указать, для какого
метода должен работать заданный url, и также там нельзя парсить
параметры напрямую из url'а. Только queryParams. Однако иногда это бывает очень нужно, если мы хотим сделать ЧПУ
— человекопонятный url, либо же у нас web-приложение
построено по архитектуре REST. В этом случае, стоит обратиться
к альтернативным реализациям. Первая ось из рассматриваемых
— это gorilla/mux. Gorilla — это набор web-компонентов, там есть помимо роутера еще
довольно много всего интересного. Вот, это довольно функциональный роутер, у него есть возможность
ограничивать по методам, по хостам, по даже query-параметрам, либо можно написать какую-нибудь
свою функцию для того, чтобы определять,
куда пускать этот роутер или нет. Посмотрим, как это выглядит в коде. Для начала можно подрубить,
собственно, gorilla/mux. Это внешний пакет,
это у же не стандартная библиотека. А дальше все почти то же самое. То есть есть Handle.func,
им можем обработать нашу функцию. Есть возможность указать для
какого хоста она будет работать, для каких методов,
либо даже для каких header'ов. То есть на самом деле
это выглядит вот так. То есть я делаю цепочку
вызовов для ограничений. И вот например, можно указывать параметры, которые мы
хотим распарсить из url'а. Например, вот я тут буду вытаскивать
только целочисленные id, тут я буду вытаскивать логи, которые,
может быть, имеют любое значение. Ну соответственно я могу
сделать даже вот так. То есть я могу вытаскивать параметры
не из конца, а из середины. Могу вытаскивать несколько
значений вот таким вот образом. То есть это мощный роутер. Для того чтобы получить значение, я должен обратиться к функции
получения значений из request'а. Оно сохраняется там внутри. Это роутер, он полностью взаимозаменяемый
со стандартным в том плане, что его запросы (то есть те параметры, которым он
передает запросы), полностью совместимы. Вот. Однако если посмотреть
на benchmark'и роутеров, то Gorilla Mux один из самых медленных. Да, у него очень много возможностей, однако наличие этих возможностей имеет
свою цену, то есть работает он медленнее. Но иногда нам нужны его возможности, а иногда нам нужны немножко
возможности и хорошая скорость. Давайте рассмотрим еще один роутер,
HttpRouter. Как видите, он весьма производителен. Он построен на технологии Prefix Tree,
или Radix Tree. Как он работает? Итак, смотрим код. То есть у него можно
прямо указать параметр, на котором будет работать этот метод. У него можно указать, что мы хотим распарсить какую-то
часть url'а в переменную. Однако здесь нет матчинга по регулярке,
то есть нельзя указать, что только цифры. И еще у этого роутера, у него другая
сигнатура самих функций, самих handler'ов. У него добавляется еще его
четвертое значение Params. Да, конечно вы можете это обойти тем,
что делать обертку нестандартными методами,
или там какую-то прослойку делать с промежуточным кодом,
но вот вызывает он так. Однако работает он очень быстро, поэтому,
возможно, вам будет это интересно. Но иногда тоже бывает, не хочется
выбирать: я хочу либо возможности, и я хочу скорость, я хочу в одном месте
возможности, а в другом месте — скорость. Как быть? Дело в том,
что опять-таки вы не ограничены только в выборе одного роутера,
вы можете взять их столько, сколько вам надо для тех мест,
которые вам нужны. Вот пример,
который совмещает сразу все три роутера. Быстрый роутер, который будет
обрабатывать только url /fast/, допустим, если у вас там много каких-то, большая нагрузка туда идет, и вам нужен
параметр id, например, вот так вот. То есть вам действительно нужно парсить
параметры из url'а и вы хотите скорости. В следующий вариант,
следующий роутер у нас не очень много запросов, но у нас тем не менее
мы хотим какую-то сложную логику, мы хотим там фильтровать по хосту,
мы хотим фильтровать по заголовкам. Вот в этом примере я эту функцию,
мой ComplexRequest, я разрешаю только для ajax-запросов. Ну наконец, стандартный роутер,
когда нам не нужно парсить запросы, и который работает очень быстро. И соответственно, я могу теперь,
используя стандартный даже мультиплексор, совместить все три этих подхода в один. То есть я могу на некоторых частях
url'ов обрабатывать одним роутером, на некоторых частях — другим роутером. За счет этого я получаю в
нужном мне месте скорость, в нужном мне месте — возможности. Конечно, у вас иногда
может кипеть мозг от того, что здесь у вас сигнатура функции такая,
потому что используется такой роутер, здесь параметры нужно получать таким
образом, а если вы замените роутер, нужно будет получать другим образом,
но в одном месте мы сложность убираем, в другом месте мы сложность добавляем. Честное равновесие. Вот так.