[БЕЗ_ЗВУКА] В этом видео мы обзорно
поговорим про фреймворк Beego. Beego — один из самых крупных фреймворков
в Go, у него огромная community. У него очень много плотно
интегрированных между собой компонентов, у него есть свое кеширование,
логирование, авторизация, УРМ-система, работа с сессиями, то есть это один из самых крупных
фреймворков, что вы можете найти в Go. Его очень активно разрабатывают наши
коллеги из Китая, поэтому в коде вы можете найти как на английском,
на русском, так и на китайском, как запросы в гитхабе,
так и комментарии в самом коде. Давайте попробуем сделать
маленький проект на Beego. В комплекте с Beego есть
удобная утилита bee, которая позволяет создать скелет
проекта всего одной командой. В данном случае я ввожу bee new, указываю команду bee,
команду new и создаю и указываю папку, в которую мне нужно запустить,
сохранить сгенерированный код. Я переключаюсь и сразу
же запускаю свой проект. Давайте попробуем, запускаем, bee new, bp. Ладно, запустили руками, перейдем в эту папку и
запустим команду bee run. bee run запустит наш
сервер и начнет мониторить файлы на предмет того, изменили ли мы их,
чтобы сразу же этот сервер перезагрузить. Для разработки это довольно удобно,
теперь посмотрим, из чего состоит скелет
нашего нового приложения. Итак. Оптимально у нас все очень аскетично, только подключение роутеров
и запуск фреймворка. Порт, на котором слушать сервер,
он сразу же определяет из конфига. Конфиг тоже генерируется
рамках этого скелета. Вот определение роутеров,
то есть я указываю, что для всего корня я хочу
слушать MainController. Для MainController определена
функция serve http, которая уже будет переключать наш запрос,
куда нужно. Давайте теперь рассмотрим MainController. MainController включает в себя структуру Beego контроллера,
в которой как раз и определен serve http. Там определены функции для
основных rest-запросов, get, post, put, delete и так далее. Вы можете определить их, вам остается
только определить функцию для них, например, вот так. Post. И сразу же post-запрос будет вызван
и попадет уже именно в эту функцию. Ну система шаблонов тоже там из коробки,
там используются стандартные шаблоны, также он генерирует вам и сам шаблон
и сразу папку со статичными файлами. Вам не нужно уже ни о чем думать. Так.
Давайте попробуем создать теперь свой собственный handler. Назовем его custom. Custom. Назовем вебсайт local host, и e-mail, допустим, пускай будет
rvasiliy@example.com. Сейчас bee определил, что у меня изменился файл, я сделал
сохранение, и он перезапустил мой сервер. Но этот запрос не будет
доступен сам по себе сразу же. Я должен определить его в роутер. Роутер по умолчанию будет проксировать
в мой контроллер только rest-запросы. Итак, я пишу «звездочка»,
это значит, что все запросы будут, все методы будут идти, и custom. И тут напишу, что URL-custom. Конечно, на роутер поддерживают сложные,
там есть в том числе даже автоматический роутер, когда вы можете
указать только имя вашего контроллера, который вы хотите использовать. Дальше через рефлексию
все подтянется само. Так. Сохраняем, смотрим bee, bee перезапустил мой сервер, теперь у меня есть
мой local host, вот страница, которую предоставляет Beego по умолчанию
в качестве примера, а вот мой запрос. Вот поменялся official website и
контакт на те данные, которые указал я. Смотрим, и тут есть даже логи и время,
когда, сколько какой запрос занимал. Сам запрос java script file какой-то, и вот мой custom роутер. Вот, что можно получить
буквально за пять минут, используя bee и фреймворк Beego. Давайте теперь рассмотрим еще один пример,
еще один скелет, который может генерировать
команда bee для сервера. Попробуем сгенерировать уже не html-сайт, а api. Вот я сгенерировал папку user. Туда мне сгенерировался сайт, который будет давать не html,
а будет представлять из себя api-сервер, то есть в основном я буду
с ним общаться по json. Переключимся туда, запустим команду bee с некоторыми другими
параметрами, я чуть позже расскажу, зачем. Итак, вот наш user,
вот контроллеры, вот роутер. Посмотрим роутер. Базово тут ничего нет, я только регистрирую свои
контроллеры в name spaces. По ним потом будут сгенерированы
автоматически все методы. То есть используется
кодогенерация в том числе. Вот мои контроллеры. Обратите внимание,
тут есть мета-информация возле методов. Она будет потом
кодогенератором распаршена, и для нее будет сгенерировано
swagger-описание по нужным нам методам. Давайте попробуем вызвать что-нибудь. api/v1/user. api/user просто. Нет, v1/user. Отлично. Вот отдался запрос на моего пользователя. Давайте посмотрим,
какое описание нам сгенерировалось, какая документация сгенерировалась
по всем нашим методам. Открываем swagger. Beego генерирует документацию
в формате swagger. Swagger — это открытый формат
для документирования api и также набор компонентов для того,
чтобы генерировать по этому описанию клиента для этого
api и заготовку сервера. Причем это доступно для огромного
количества языков, в том числе go. Вот что нам сгенерировалось
для нашего скелета. Вот, например, get. Вот, что можно получить. Вот delete, или давайте попробуем post. Что, какие значения я должен там указать,
какие ответы я могу получить? Да, конечно, писать там руками определения этих сервисов иногда бывает заморочено,
но, с другой стороны, вы сразу же получаете хорошую, красивую
документацию с хорошим интерфейсом. Поэтому, возможно, если вы ищете
для себя хороший старт для Beego, будь то html-сайт, который дает вам html, так и api сервис, возможно,
Beego будет неплохим выбором, учитывая то количество компонентов,
которые в нем есть. Но всегда нужно смотреть по ситуации.