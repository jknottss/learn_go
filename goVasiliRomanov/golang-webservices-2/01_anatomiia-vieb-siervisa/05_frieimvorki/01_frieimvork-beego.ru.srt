1
00:00:00,000 --> 00:00:05,550
[БЕЗ_ЗВУКА] В

2
00:00:05,550 --> 00:00:10,870
этом видео мы обзорно
поговорим про фреймворк Beego.

3
00:00:10,870 --> 00:00:17,210
Beego — один из самых крупных фреймворков
в Go, у него огромная community.

4
00:00:17,210 --> 00:00:21,978
У него очень много плотно
интегрированных между собой компонентов,

5
00:00:21,978 --> 00:00:26,560
у него есть свое кеширование,
логирование, авторизация,

6
00:00:26,560 --> 00:00:29,950
УРМ-система, работа с сессиями,

7
00:00:29,950 --> 00:00:34,830
то есть это один из самых крупных
фреймворков, что вы можете найти в Go.

8
00:00:34,830 --> 00:00:40,245
Его очень активно разрабатывают наши
коллеги из Китая, поэтому в коде вы можете

9
00:00:40,245 --> 00:00:45,720
найти как на английском,
на русском, так и на китайском,

10
00:00:45,720 --> 00:00:51,170
как запросы в гитхабе,
так и комментарии в самом коде.

11
00:00:51,170 --> 00:00:55,250
Давайте попробуем сделать
маленький проект на Beego.

12
00:00:55,250 --> 00:00:59,660
В комплекте с Beego есть
удобная утилита bee,

13
00:00:59,660 --> 00:01:07,200
которая позволяет создать скелет
проекта всего одной командой.

14
00:01:07,200 --> 00:01:10,740
В данном случае я ввожу bee new,

15
00:01:10,740 --> 00:01:15,353
указываю команду bee,
команду new и создаю и указываю папку,

16
00:01:15,353 --> 00:01:19,798
в которую мне нужно запустить,
сохранить сгенерированный код.

17
00:01:19,798 --> 00:01:22,750
Я переключаюсь и сразу
же запускаю свой проект.

18
00:01:22,750 --> 00:01:25,892
Давайте попробуем,

19
00:01:25,892 --> 00:01:30,680
запускаем, bee new, bp.

20
00:01:30,680 --> 00:01:35,275
Ладно, запустили руками,

21
00:01:35,275 --> 00:01:42,330
перейдем в эту папку и
запустим команду bee run.

22
00:01:42,330 --> 00:01:47,955
bee run запустит наш
сервер и начнет мониторить

23
00:01:47,955 --> 00:01:53,415
файлы на предмет того, изменили ли мы их,
чтобы сразу же этот сервер перезагрузить.

24
00:01:53,415 --> 00:01:56,889
Для разработки это довольно удобно,
теперь посмотрим,

25
00:01:56,889 --> 00:02:00,050
из чего состоит скелет
нашего нового приложения.

26
00:02:00,050 --> 00:02:00,743
Итак.

27
00:02:00,743 --> 00:02:04,555
Оптимально у нас все очень аскетично,

28
00:02:04,555 --> 00:02:09,963
только подключение роутеров
и запуск фреймворка.

29
00:02:09,963 --> 00:02:16,450
Порт, на котором слушать сервер,
он сразу же определяет из конфига.

30
00:02:16,450 --> 00:02:19,672
Конфиг тоже генерируется
рамках этого скелета.

31
00:02:19,672 --> 00:02:22,986
Вот определение роутеров,
то есть я указываю,

32
00:02:22,986 --> 00:02:26,790
что для всего корня я хочу
слушать MainController.

33
00:02:26,790 --> 00:02:30,158
Для MainController определена
функция serve http,

34
00:02:30,158 --> 00:02:33,782
которая уже будет переключать наш запрос,
куда нужно.

35
00:02:33,782 --> 00:02:36,750
Давайте теперь рассмотрим MainController.

36
00:02:36,750 --> 00:02:41,724
MainController включает в

37
00:02:41,724 --> 00:02:47,050
себя структуру Beego контроллера,
в которой как раз и определен serve http.

38
00:02:47,050 --> 00:02:51,617
Там определены функции для
основных rest-запросов,

39
00:02:51,617 --> 00:02:54,830
get, post, put, delete и так далее.

40
00:02:54,830 --> 00:02:58,969
Вы можете определить их, вам остается
только определить функцию для них,

41
00:02:58,969 --> 00:03:00,140
например, вот так.

42
00:03:00,140 --> 00:03:00,702
Post.

43
00:03:00,702 --> 00:03:06,430
И сразу же post-запрос будет вызван
и попадет уже именно в эту функцию.

44
00:03:06,430 --> 00:03:12,440
Ну система шаблонов тоже там из коробки,
там используются стандартные шаблоны,

45
00:03:12,440 --> 00:03:19,758
также он генерирует вам и сам шаблон
и сразу папку со статичными файлами.

46
00:03:19,758 --> 00:03:22,530
Вам не нужно уже ни о чем думать.

47
00:03:22,530 --> 00:03:25,631
Так.
Давайте попробуем создать теперь свой

48
00:03:25,631 --> 00:03:27,263
собственный handler.

49
00:03:27,263 --> 00:03:28,740
Назовем его custom.

50
00:03:28,740 --> 00:03:30,240
Custom.

51
00:03:30,240 --> 00:03:36,160
Назовем вебсайт local host, и e-mail,

52
00:03:36,160 --> 00:03:41,700
допустим, пускай будет
rvasiliy@example.com.

53
00:03:41,700 --> 00:03:47,230
Сейчас bee определил,

54
00:03:47,230 --> 00:03:51,150
что у меня изменился файл, я сделал
сохранение, и он перезапустил мой сервер.

55
00:03:51,150 --> 00:03:54,700
Но этот запрос не будет
доступен сам по себе сразу же.

56
00:03:54,700 --> 00:03:58,338
Я должен определить его в роутер.

57
00:03:58,338 --> 00:04:03,490
Роутер по умолчанию будет проксировать
в мой контроллер только rest-запросы.

58
00:04:03,490 --> 00:04:07,400
Итак, я пишу «звездочка»,
это значит, что все запросы будут,

59
00:04:07,400 --> 00:04:11,160
все методы будут идти, и custom.

60
00:04:11,160 --> 00:04:13,961
И тут напишу, что URL-custom.

61
00:04:13,961 --> 00:04:17,886
Конечно, на роутер поддерживают сложные,
там есть в том числе даже

62
00:04:17,886 --> 00:04:22,131
автоматический роутер, когда вы можете
указать только имя вашего контроллера,

63
00:04:22,131 --> 00:04:24,162
который вы хотите использовать.

64
00:04:24,162 --> 00:04:26,900
Дальше через рефлексию
все подтянется само.

65
00:04:26,900 --> 00:04:27,620
Так.

66
00:04:27,620 --> 00:04:33,133
Сохраняем, смотрим bee, bee перезапустил

67
00:04:33,133 --> 00:04:37,960
мой сервер, теперь у меня есть
мой local host, вот страница,

68
00:04:37,960 --> 00:04:44,210
которую предоставляет Beego по умолчанию
в качестве примера, а вот мой запрос.

69
00:04:44,210 --> 00:04:49,690
Вот поменялся official website и
контакт на те данные, которые указал я.

70
00:04:49,690 --> 00:04:56,780
Смотрим, и тут есть даже логи и время,
когда, сколько какой запрос занимал.

71
00:04:56,780 --> 00:05:01,930
Сам запрос java script file какой-то,

72
00:05:01,930 --> 00:05:05,060
и вот мой custom роутер.

73
00:05:05,060 --> 00:05:10,604
Вот, что можно получить
буквально за пять минут,

74
00:05:10,604 --> 00:05:13,530
используя bee и фреймворк Beego.

75
00:05:13,530 --> 00:05:17,416
Давайте теперь рассмотрим еще один пример,
еще один скелет,

76
00:05:17,416 --> 00:05:23,049
который может генерировать
команда bee для сервера.

77
00:05:23,049 --> 00:05:28,577
Попробуем сгенерировать

78
00:05:28,577 --> 00:05:34,490
уже не html-сайт, а api.

79
00:05:34,490 --> 00:05:39,820
Вот я сгенерировал папку user.

80
00:05:39,820 --> 00:05:44,832
Туда мне сгенерировался сайт,

81
00:05:44,832 --> 00:05:49,812
который будет давать не html,
а будет представлять из себя api-сервер,

82
00:05:49,812 --> 00:05:52,450
то есть в основном я буду
с ним общаться по json.

83
00:05:52,450 --> 00:05:57,855
Переключимся туда,

84
00:05:57,855 --> 00:06:03,260
запустим команду bee с некоторыми другими
параметрами, я чуть позже расскажу, зачем.

85
00:06:03,260 --> 00:06:09,914
Итак, вот наш user,
вот контроллеры, вот роутер.

86
00:06:09,914 --> 00:06:11,381
Посмотрим роутер.

87
00:06:11,381 --> 00:06:13,107
Базово тут ничего нет,

88
00:06:13,107 --> 00:06:18,120
я только регистрирую свои
контроллеры в name spaces.

89
00:06:18,120 --> 00:06:24,240
По ним потом будут сгенерированы
автоматически все методы.

90
00:06:24,240 --> 00:06:28,050
То есть используется
кодогенерация в том числе.

91
00:06:28,050 --> 00:06:29,760
Вот мои контроллеры.

92
00:06:29,760 --> 00:06:34,710
Обратите внимание,
тут есть мета-информация возле методов.

93
00:06:34,710 --> 00:06:39,430
Она будет потом
кодогенератором распаршена,

94
00:06:39,430 --> 00:06:44,150
и для нее будет сгенерировано
swagger-описание по нужным нам методам.

95
00:06:44,150 --> 00:06:48,274
Давайте попробуем вызвать что-нибудь.

96
00:06:48,274 --> 00:06:50,110
api/v1/user.

97
00:06:50,110 --> 00:06:52,865
api/user просто.

98
00:06:52,865 --> 00:06:55,460
Нет, v1/user.

99
00:06:55,460 --> 00:06:56,987
Отлично.

100
00:06:56,987 --> 00:07:03,270
Вот отдался запрос на моего пользователя.

101
00:07:03,270 --> 00:07:07,178
Давайте посмотрим,
какое описание нам сгенерировалось,

102
00:07:07,178 --> 00:07:11,170
какая документация сгенерировалась
по всем нашим методам.

103
00:07:11,170 --> 00:07:14,410
Открываем swagger.

104
00:07:14,410 --> 00:07:18,175
Beego генерирует документацию
в формате swagger.

105
00:07:18,175 --> 00:07:22,912
Swagger — это открытый формат
для документирования api и также

106
00:07:22,912 --> 00:07:27,860
набор компонентов для того,
чтобы генерировать по этому

107
00:07:27,860 --> 00:07:33,200
описанию клиента для этого
api и заготовку сервера.

108
00:07:33,200 --> 00:07:38,510
Причем это доступно для огромного
количества языков, в том числе go.

109
00:07:38,510 --> 00:07:44,838
Вот что нам сгенерировалось
для нашего скелета.

110
00:07:44,838 --> 00:07:47,030
Вот, например, get.

111
00:07:47,030 --> 00:07:49,800
Вот, что можно получить.

112
00:07:49,800 --> 00:07:54,140
Вот delete, или давайте попробуем post.

113
00:07:54,140 --> 00:08:01,520
Что, какие значения я должен там указать,
какие ответы я могу получить?

114
00:08:01,520 --> 00:08:06,444
Да, конечно, писать там руками определения

115
00:08:06,444 --> 00:08:09,980
этих сервисов иногда бывает заморочено,
но, с другой стороны,

116
00:08:09,980 --> 00:08:14,430
вы сразу же получаете хорошую, красивую
документацию с хорошим интерфейсом.

117
00:08:14,430 --> 00:08:19,979
Поэтому, возможно, если вы ищете
для себя хороший старт для Beego,

118
00:08:19,979 --> 00:08:23,591
будь то html-сайт, который дает вам html,

119
00:08:23,591 --> 00:08:28,116
так и api сервис, возможно,
Beego будет неплохим выбором,

120
00:08:28,116 --> 00:08:32,310
учитывая то количество компонентов,
которые в нем есть.

121
00:08:32,310 --> 00:08:35,900
Но всегда нужно смотреть по ситуации.