1
00:00:00,000 --> 00:00:07,903
[БЕЗ_ЗВУКА] В этом видео мы рассмотрим,

2
00:00:07,903 --> 00:00:11,860
каким образом можно сделать
валидацию параметров в Go.

3
00:00:11,860 --> 00:00:16,760
Начнём с того, что в Go нет
встроенного валидатора никакого.

4
00:00:16,760 --> 00:00:17,401
Почему?

5
00:00:17,401 --> 00:00:21,784
Потому что валидация параметров
— это очень специфичная вещь и

6
00:00:21,784 --> 00:00:25,140
разнится от проекта к проекту.

7
00:00:25,140 --> 00:00:30,980
Кто-то вырезает просто всё лишнее
и подставляет дефолтные значения.

8
00:00:30,980 --> 00:00:32,773
Кто-то ругается ошибкой.

9
00:00:32,773 --> 00:00:36,890
Опять-таки ошибки тоже очень
специфичны от проекта к проекту.

10
00:00:36,890 --> 00:00:40,950
И нет какой-то
общепризнанной спецификации,

11
00:00:40,950 --> 00:00:44,420
что ошибки должны возвращаться вот так.

12
00:00:44,420 --> 00:00:49,310
Поэтому в Go не включили
никакой стандартный пакет.

13
00:00:49,310 --> 00:00:54,114
Однако на просторах Интернета
очень много разных пакетов для

14
00:00:54,114 --> 00:00:58,180
организации подобного рода действа.

15
00:00:58,180 --> 00:00:58,816
Итак.

16
00:00:58,816 --> 00:01:02,740
В данном примере мы рассмотрим два пакета.

17
00:01:02,740 --> 00:01:08,100
Валидатор, который умеет
только валидировать значения,

18
00:01:08,100 --> 00:01:13,045
он не может ниоткуда их ни спарсить,
ничего.

19
00:01:13,045 --> 00:01:17,335
Ему просто мы передаём на вход структуру,
и он говорит да или нет, и если нет,

20
00:01:17,335 --> 00:01:17,990
то почему.

21
00:01:17,990 --> 00:01:20,154
И парсинг параметров.

22
00:01:20,154 --> 00:01:26,200
Мы воспользуемся пакетом компонентов
gorilla, там очень много всякого.

23
00:01:26,200 --> 00:01:30,306
В данном случает пакет
schema занимается тем,

24
00:01:30,306 --> 00:01:35,530
что парсит параметры из url,
из urlvalues в структуру.

25
00:01:35,530 --> 00:01:40,790
Итак, для начала посмотрим, что мы,
собственно, будем валидировать.

26
00:01:40,790 --> 00:01:42,622
У нас есть структура SendMessage.

27
00:01:42,622 --> 00:01:46,720
Представим, что мы какой-то почтовый
сервис, и мы хотим отправить письмо.

28
00:01:46,720 --> 00:01:51,220
Есть Id,

29
00:01:51,220 --> 00:01:58,020
и поля валидатора указаны в
struct tags по метке valid.

30
00:01:58,020 --> 00:02:03,770
По метке schema указаны поля для
парсинга параметров в эту структуру.

31
00:02:03,770 --> 00:02:05,505
Итак, Id.

32
00:02:05,505 --> 00:02:09,500
Id у нас поле опционально,

33
00:02:09,500 --> 00:02:13,250
то есть оно может быть,
либо его может не быть.

34
00:02:13,250 --> 00:02:15,446
Если его не будет, ругаться не будет.

35
00:02:15,446 --> 00:02:16,112
Priority.

36
00:02:16,112 --> 00:02:19,980
Priority — это строковое поле,
которое может иметь три значения.

37
00:02:19,980 --> 00:02:23,000
Это валидатор in и low,
high, normal, собственно,

38
00:02:23,000 --> 00:02:25,440
сами значения полей, которые могут быть.

39
00:02:25,440 --> 00:02:26,485
Recipient.

40
00:02:26,485 --> 00:02:33,001
Recipient извне, из параметров, которые я
передам в url, должен прийти в поле to.

41
00:02:33,001 --> 00:02:36,742
За это будет нам отвечать schema,
я в schema указываю,

42
00:02:36,742 --> 00:02:39,060
что это поле называется так-то.

43
00:02:39,060 --> 00:02:41,141
И валидатор там будет email.

44
00:02:41,141 --> 00:02:46,060
То есть если мне придёт невалидный e-mail,
то валидатор ругнётся.

45
00:02:46,060 --> 00:02:46,654
Subject.

46
00:02:46,654 --> 00:02:49,430
Subject использует мой
собственный валидатор,

47
00:02:49,430 --> 00:02:53,053
который я зарегистрировал
специально для этих целей.

48
00:02:53,053 --> 00:02:53,900
Поле Inner.

49
00:02:53,900 --> 00:02:58,447
Оно, обратите внимание, оно публичное,
начинается с большой буквы,

50
00:02:58,447 --> 00:03:02,447
но я не хочу туда ничего парсить
и никак его валидировать,

51
00:03:02,447 --> 00:03:06,643
поэтому я и в schema и в
поле valid указываю минус.

52
00:03:06,643 --> 00:03:08,840
Ещё есть поле flag.

53
00:03:08,840 --> 00:03:12,545
Для поля flag я ничего не указываю,
потому что это приватное поле,

54
00:03:12,545 --> 00:03:16,536
оно называется с маленькой буквы,
а поскольку оба эти механизма,

55
00:03:16,536 --> 00:03:20,090
и валидация, и парсинг,
они работают через Reflect,

56
00:03:20,090 --> 00:03:23,663
то они не могут достучаться до этого поля,
оно им не видно.

57
00:03:23,663 --> 00:03:28,000
Поэтому если я даже передам этот параметр,
он не запишется.

58
00:03:28,000 --> 00:03:30,939
Итак, как теперь выглядит это в коде?

59
00:03:30,939 --> 00:03:32,815
Начнём с демонстрации.

60
00:03:32,815 --> 00:03:37,630
Вот то, что я ввёл.

61
00:03:37,630 --> 00:03:43,699
to, которое у меня превратилось дальше в
Recipient; priority subject поля inner,

62
00:03:43,699 --> 00:03:48,180
которое я сказал игнорировать,
обратите внимание, оно у нас никакое,

63
00:03:48,180 --> 00:03:52,044
и поле flag тоже,
оно у нас имеет дефолтное значение.

64
00:03:52,044 --> 00:03:52,716
Ну и всё.

65
00:03:52,716 --> 00:03:54,400
Сообщение корректно.

66
00:03:54,400 --> 00:03:55,805
То есть всё хорошо.

67
00:03:55,805 --> 00:04:03,667
Теперь же, если я, например, попробую в
Priority поменять его на что-то другое,

68
00:04:03,667 --> 00:04:08,974
например, qqq,
то оно распарсилось в параметры,

69
00:04:08,974 --> 00:04:16,031
то есть Priority само значение есть,
однако валидацию оно уже не прошло.

70
00:04:16,031 --> 00:04:22,335
Поле валидатора вернуло мне ошибку,
что для такого-то поля,

71
00:04:22,335 --> 00:04:27,008
в данном случае Priority,
оно не прошло валидацию.

72
00:04:27,008 --> 00:04:29,575
И если текстом это выводить,

73
00:04:29,575 --> 00:04:34,717
то: «Priority: qqq не валидируется
как in(low | normal | high)».

74
00:04:34,717 --> 00:04:38,340
Рассмотрим в коде,
каким образом можно это организовать.

75
00:04:38,340 --> 00:04:43,300
Итак, для начала я вывожу,
собственно, саму строчку запроса,

76
00:04:43,300 --> 00:04:48,362
чтобы её было видно на экране, потом я
создаю сообщение, дальше я создаю декодер

77
00:04:48,362 --> 00:04:53,500
для того, чтобы распарсить значение из
входящих параметров в мою структуру.

78
00:04:53,500 --> 00:04:58,061
Обратите внимание,
я говорю этому декодеру, что, пожалуйста,

79
00:04:58,061 --> 00:05:03,036
на неизвестные поля, на них не надо
ругаться и их можно просто игнорировать.

80
00:05:03,036 --> 00:05:05,305
Так.
Дальше я вывожу само сообщение,

81
00:05:05,305 --> 00:05:07,300
которое у меня уже распарсилось.

82
00:05:07,300 --> 00:05:09,040
И я вызываю ValidateStruct.

83
00:05:09,040 --> 00:05:12,323
Первым параметром оно возвращает
булевую переменную «да» или «нет»,

84
00:05:12,323 --> 00:05:15,050
но в данном случае оно мне не нужно,
я смотрю только на ошибку.

85
00:05:15,050 --> 00:05:20,710
Если случилась ошибка, я могу вывести её
просто на экран, там будет весь текст.

86
00:05:20,710 --> 00:05:23,954
Это не очень информативно.

87
00:05:23,954 --> 00:05:30,040
Вот это, потому что парсить руками,
чтобы понять, какое поле было не так...

88
00:05:30,040 --> 00:05:34,070
Разве что вы захотите пользователю
показывать именно такую строчку.

89
00:05:34,070 --> 00:05:39,967
Поэтому мы пытаемся достучаться
при помощи преобразования

90
00:05:39,967 --> 00:05:44,851
интерфейса (err — это
интерфейс) до реальных ошибок,

91
00:05:44,851 --> 00:05:50,015
которые там есть,
преобразованием интерфейса.

92
00:05:50,015 --> 00:05:54,946
Если преобразование получилось,
всё хорошо, то я итерируюсь по

93
00:05:54,946 --> 00:05:59,936
этим ошибкам и вывожу
полностью эту ошибку на экран.

94
00:05:59,936 --> 00:06:04,146
Я могу там указать имя,
достучаться до имени, достучаться до

95
00:06:04,146 --> 00:06:08,690
произвольного текста ошибки и посмотреть
вообще, что там была за ошибка.

96
00:06:08,690 --> 00:06:15,190
Поэтому если вы хотите организовывать
какого-то рода возврат о том,

97
00:06:15,190 --> 00:06:19,240
что было неправильно,
то вот это вам хорошо поможет.

98
00:06:19,240 --> 00:06:23,221
Ну и дальше в функции init я покажу,

99
00:06:23,221 --> 00:06:29,515
что я зарегистрировал свой
собственный валидатор "msgSubject".

100
00:06:29,515 --> 00:06:33,540
Дело в том,
что у вас не всегда ваши типы данных,

101
00:06:33,540 --> 00:06:38,592
хоть они и имеют стандартный тип,
но они не всегда будут

102
00:06:38,592 --> 00:06:43,120
влезать в те методы, которые
предоставляет стандартный валидатор.

103
00:06:43,120 --> 00:06:46,695
Например, через него нельзя
проверить динамический enum,

104
00:06:46,695 --> 00:06:48,200
то есть список значений.

105
00:06:48,200 --> 00:06:53,666
Я выше его писал, но это статичный список,
а если я хочу динамику, уже не получится.

106
00:06:53,666 --> 00:06:59,149
Поэтому я зарегистрировал свой собственный
обработчик, и я в нём получаю Subject,

107
00:06:59,149 --> 00:07:03,633
пытаюсь его преобразовать к строке,
ну и смотрю,

108
00:07:03,633 --> 00:07:09,347
что если длина 0 или если длина больше 10,
то я буду ругаться.

109
00:07:09,347 --> 00:07:10,930
Давайте проверим.

110
00:07:10,930 --> 00:07:15,060
Попробуем дописать что-нибудь в Subject.

111
00:07:15,060 --> 00:07:20,800
Поле Subject, оно невалидно.

112
00:07:20,800 --> 00:07:24,280
Соотвественно, я уже могу
что-то с этим делать.

113
00:07:24,280 --> 00:07:25,702
Как это работает внутри?

114
00:07:25,702 --> 00:07:30,100
Работает внутри это через рефлексию,
как и вся динамика, практически, в Go.

115
00:07:30,100 --> 00:07:35,980
Поэтому там есть хоть маленький,
но и, тем не менее, overhead.

116
00:07:35,980 --> 00:07:40,020
Если же вы хотите там делать
совсем-совсем быстро,

117
00:07:40,020 --> 00:07:43,570
то добро пожаловать в мир кодогенерации,
как всегда.

118
00:07:43,570 --> 00:07:49,545
За счёт кодогенерации вы можете
пройтись по даже нераспаршенным

119
00:07:49,545 --> 00:07:54,592
в структуре параметрам,
вот по этой строчке,

120
00:07:54,592 --> 00:07:59,842
и в один проход и сразу спарсить её
структуру, и сразу провести валидацию.

121
00:07:59,842 --> 00:08:03,824
Это будет очень быстро, однако вам
придётся заморочиться с написанием кода,

122
00:08:03,824 --> 00:08:05,090
который это организует.

123
00:08:05,090 --> 00:08:06,333
Что делать?

124
00:08:06,333 --> 00:08:13,717
Использовать ли стандартный валидатор
либо заморачиваться и писать свой?

125
00:08:13,717 --> 00:08:14,972
Решать вам.

126
00:08:14,972 --> 00:08:18,983
Однако лучше всё-таки
начать с тула стандартного,

127
00:08:18,983 --> 00:08:23,242
и если вдруг он вылезет при
профилировании, или вы заметите,

128
00:08:23,242 --> 00:08:27,357
что всё-таки ваша программа тормозит
именно из-за него, что будет,

129
00:08:27,357 --> 00:08:32,171
скорее всего, очень-очень редко, то
только тогда стоит что-то оптимизировать,

130
00:08:32,171 --> 00:08:36,110
потому что, как вы знаете,
предварительная оптимизация — это зло.