[БЕЗ_ЗВУКА] В предыдущей серии видеоуроков
мы рассматривали шаблонизатор, который поставляется вместе со
стандартной библиотекой в Go. Этот шаблонизатор обладает
довольно большими возможностями, там есть фактически все,
что вам нужно для полноценной работы. Однако у него есть один недостаток. Для некоторых он может
быть весьма серьезным. Весь этот шаблонизатор
построен на рефлекте, то есть на работе в runtime'е. Что это значит? Ну то есть все его вычисления
происходят не во время компиляции, а во время исполнения вашей программы. Если ваше приложение интенсивно отдает шаблоны, то, возможно, вы захотите это
место у себя оптимизировать. У меня есть benchmark'и. Точнее даже не у меня,
а на Github'е, которые, собственно, сравнивают между собой несколько
разных систем benchmark'ов, есть много других benchmark'ов, не только
в стандартной библиотеке он единственный. Но мы не будем рассматривать
другие шаблонизаторы, которые работают в runtime'е. Вместо этого, мы рассмотрим шаблонизаторы,
которые из шаблонов компилируют Go-код. То есть на выходе у вас не что-то,
что парсится в runtime'е, а уже прямо готовый исходник. Рассматривать мы будем шаблонизатор Hero,
он один из самых быстрых. И давайте посмотрим теперь этот уже код,
и чем он отличается от шаблонизатора из стандартной
библиотеки, чем отличается сам подход. Итак. У меня есть вот мой пакет main, у меня есть item'ы, я не будут их
просматривать, там всего одна структура. Есть шаблоны, к этому мы дальше доберемся. У меня есть некоторый набор данных, и я вызываю из шаблонов,
я вызываю функцию Index. Обратите внимание, я не указываю,
какие файлы я должен парсить, я не вызываю другие шаблонизаторы, я подключил какой-то пакет
свой и вызываю оттуда функцию, куда я и передаю байтовый буфер,
для того, чтобы писать туда данные. Собственно, как получается уже сам шаблон? Вот базовая обертка над шаблоном, и вот здесь я определяю блок с body, который я дальше захочу
переопределить в другом шаблоне. То есть наследование шаблонов
— это все-таки удобно. Теперь обратимся, собственно,
к шаблону с логикой. Окей. Что мы тут видим? Для начала мы тут видим import. import? Зачем, почему? Мы же просто хотим шаблон распаковать. А вот так. Дело в том, что этот шаблонизатор, он компилирует вот html с
псевдоразметкой в код на Go. Далее мы объявляем функцию (опять-таки,
что странно), мы указываем, что мы будем наследоваться от base.html,
определяем блок кода, который мы хотим заменить,
и тут мы уже пишем html-цикл. Обратите внимание,
это не какой-то там цикл, который похож на в стандартной библиотеке,
который цикл встроен в шаблонизатор. Нет, это очень похоже на цикл на Go. Это действительно есть цикл в коде на Go. Потому что мы встраиваем,
по сути, сюда код на Go. Мы выводим переменные, да они у нас тоже там экранируются для
целочисленных типов, таких, как id. Мы должны указать, что мы хотим преобразовать эту переменную,
как ее привести. То есть что в этом месте у нас
будет целочисленная переменная. То есть там никаких нет
вычислений в runtime'е. То есть мы должны указать, что да,
тут будет целочисленная переменная, чтобы шаблонизатор подставил
нужную функцию преобразования. Ну и закрываем скобки. Выглядит, конечно, похоже на ранний php, когда отдельные шаблонизаторы еще не были
в моде, но на самом деле так и есть, потому что потом это
компилируется в код на Go. Смотрите, сейчас у меня файл,
в который будет скомпилирован код. Он пустой, там нет вообще ничего. Для того чтобы преобразовать
мой html с разметкой этого шаблонизатора в код на Go,
мне нужно запустить команду компиляции. Это не команда компиляции
самого исходника, это команда компиляции шаблонизатора,
шаблона. Вот команда. Я могу запустить ее вот таким образом,
находясь в папке с main'ом. Однако руками запускать такое бывает не очень удобно, потому что у вас
может быть много разных блоков, много разных файлов,
которые распаковывают свои шаблоны, ну и запускать любую другую кодогенерацию,
например easyjson. Поэтому очень редко руками
что-то такое компилируется. В Go есть специальный служебный
комментарий go:generate. Если мы запустим специальную программу,
которая называется, как ни странно, go generate,
то она пройдет, мы можем указать ей исходники,
по которым проходить, ну у меня я в данном случае ничего
указывать не буду, у меня вся папка. Она найдет все такие комментарии и
выполнит ту программу, которая в них есть. То есть я указал, что я хочу каждый
раз компилировать свои шаблоны. Так, запускаем. Ага, что-то произошло. Парсинг, генерация шаблона,
форматирование, окей. Все, то есть мой шаблон готов. Мне не придется теперь каждый
раз помнить эту команду. Я записал ее в исходном файле один раз,
и по команде она будет запускаться сама. Так, ну и наконец, мы дошли до того,
чтобы посмотреть код. Ага. package template, import'ы, то есть вот import,
который я сам руками прописывал вот здесь. Вот моя функция,
куда я передаю все параметры. Вот полностью скомпилированный шаблон. Он не только какой-то
базовый кусок компилирует, который потом будет еще что-то вызывать,
нет. Он компилирует полностью всю функцию,
вместе со всей разметкой. То есть если у вас десять функций,
которые наследуются от базового шаблона, у вас будет этот базовый шаблон
в них десять раз повторен. Ну и дальше начинает писаться в буфер, который мы туда передали,
вот здесь, начинает писаться код. Ага, вот мой цикл. Вот то, что я вывожу. Вот все. То есть вот скомпилированный шаблон. Он уже скомпилирован сразу в Go-код. Это будет выполняться очень быстро. Как вы видели, без локаций,
без дополнительного overhead'а по памяти. Ну и пора это запустить. go run main. Так, отлично. Я запустил свой код, вот он даже открыт. Мой шаблон выглядит вот так. То есть это будет работать очень быстро. Очень быстро. Однако, конечно, у этого есть недостатки. Какой недостаток? Если вы используете шаблонизатор стандартной библиотеки, либо любой другой,
который работает в runtime'е, то вы можете шаблоны перезагрузить
во время работы вашей программы. Если в вашем сервисе frontend разработка
отделена от backend разработки, то вам иногда бывает удобно
сделать релиз верстки, релиз frontend'а,
релиз html-части отдельно от backend'а. И ваша программа, она может в
runtime'е перезагрузить этот код, перезагрузить эти шаблоны,
и они обновятся. В случае со скомпилированными
шаблонами такое не пройдет. Потому что ваш шаблон — это функция на Go. Для того чтобы переразложить
такие шаблоны, вам придется перекомпилировать
всю вашу программу. То есть у компиляции шаблонов в этом плане
есть, конечно, такого рода недостаток. Но это компенсируется скоростью. Еще момент, который стоит упомянуть. Тут мы используем простой буфер данных,
мы каждый раз его создаем, потом пишем что-то в ответ,
и все, он уничтожается. Уходит на heat, там освобождается,
собирается сборщиком мусора. Однако мы можем использовать sync.Pool
и переиспользовать эти данные. Таким образом,
вы не будете грузить garbage collector, у вас будут паузы на сборку мусора
гораздо меньше, за счет того, что вы этот объем данных, эту память
вы будете переиспользовать каждый раз. Конечно, если у вас шаблоны с
html весят по несколько мегабайт, то такого рода переиспользование памяти
становится практически необходимым, если вы хотите много работать с такими
шаблонами на Go под большой нагрузкой.