1
00:00:00,000 --> 00:00:07,275
[БЕЗ_ЗВУКА] В

2
00:00:07,275 --> 00:00:10,878
предыдущей серии видеоуроков
мы рассматривали шаблонизатор,

3
00:00:10,878 --> 00:00:14,420
который поставляется вместе со
стандартной библиотекой в Go.

4
00:00:14,420 --> 00:00:18,235
Этот шаблонизатор обладает
довольно большими возможностями,

5
00:00:18,235 --> 00:00:23,030
там есть фактически все,
что вам нужно для полноценной работы.

6
00:00:23,030 --> 00:00:25,516
Однако у него есть один недостаток.

7
00:00:25,516 --> 00:00:28,730
Для некоторых он может
быть весьма серьезным.

8
00:00:28,730 --> 00:00:34,078
Весь этот шаблонизатор
построен на рефлекте,

9
00:00:34,078 --> 00:00:37,403
то есть на работе в runtime'е.

10
00:00:37,403 --> 00:00:38,359
Что это значит?

11
00:00:38,359 --> 00:00:42,361
Ну то есть все его вычисления
происходят не во время компиляции,

12
00:00:42,361 --> 00:00:45,070
а во время исполнения вашей программы.

13
00:00:45,070 --> 00:00:49,680
Если ваше приложение интенсивно

14
00:00:49,680 --> 00:00:53,820
отдает шаблоны,

15
00:00:53,820 --> 00:00:58,470
то, возможно, вы захотите это
место у себя оптимизировать.

16
00:00:58,470 --> 00:01:00,476
У меня есть benchmark'и.

17
00:01:00,476 --> 00:01:07,260
Точнее даже не у меня,
а на Github'е, которые, собственно,

18
00:01:07,260 --> 00:01:12,392
сравнивают между собой несколько
разных систем benchmark'ов,

19
00:01:12,392 --> 00:01:16,740
есть много других benchmark'ов, не только
в стандартной библиотеке он единственный.

20
00:01:16,740 --> 00:01:22,153
Но мы не будем рассматривать
другие шаблонизаторы,

21
00:01:22,153 --> 00:01:23,594
которые работают в runtime'е.

22
00:01:23,594 --> 00:01:32,000
Вместо этого, мы рассмотрим шаблонизаторы,
которые из шаблонов компилируют Go-код.

23
00:01:32,000 --> 00:01:36,199
То есть на выходе у вас не что-то,
что парсится в runtime'е,

24
00:01:36,199 --> 00:01:38,270
а уже прямо готовый исходник.

25
00:01:38,270 --> 00:01:44,470
Рассматривать мы будем шаблонизатор Hero,
он один из самых быстрых.

26
00:01:44,470 --> 00:01:48,187
И давайте посмотрим теперь этот уже код,
и чем он

27
00:01:48,187 --> 00:01:53,120
отличается от шаблонизатора из стандартной
библиотеки, чем отличается сам подход.

28
00:01:53,120 --> 00:01:56,160
Итак.

29
00:01:56,160 --> 00:01:59,176
У меня есть вот мой пакет main,

30
00:01:59,176 --> 00:02:04,116
у меня есть item'ы, я не будут их
просматривать, там всего одна структура.

31
00:02:04,116 --> 00:02:06,380
Есть шаблоны, к этому мы дальше доберемся.

32
00:02:06,380 --> 00:02:10,503
У меня есть некоторый набор данных,

33
00:02:10,503 --> 00:02:14,801
и я вызываю из шаблонов,
я вызываю функцию Index.

34
00:02:14,801 --> 00:02:20,855
Обратите внимание, я не указываю,
какие файлы я должен парсить,

35
00:02:20,855 --> 00:02:24,113
я не вызываю другие шаблонизаторы,

36
00:02:24,113 --> 00:02:30,000
я подключил какой-то пакет
свой и вызываю оттуда функцию,

37
00:02:30,000 --> 00:02:35,274
куда я и передаю байтовый буфер,
для того, чтобы писать туда данные.

38
00:02:35,274 --> 00:02:38,260
Собственно, как получается уже сам шаблон?

39
00:02:38,260 --> 00:02:44,860
Вот базовая обертка над шаблоном,

40
00:02:44,860 --> 00:02:50,512
и вот здесь я определяю блок с body,

41
00:02:50,512 --> 00:02:53,869
который я дальше захочу
переопределить в другом шаблоне.

42
00:02:53,869 --> 00:02:57,100
То есть наследование шаблонов
— это все-таки удобно.

43
00:02:57,100 --> 00:03:02,411
Теперь обратимся, собственно,
к шаблону с логикой.

44
00:03:02,411 --> 00:03:03,090
Окей.

45
00:03:03,090 --> 00:03:04,380
Что мы тут видим?

46
00:03:04,380 --> 00:03:06,710
Для начала мы тут видим import.

47
00:03:06,710 --> 00:03:07,726
import?

48
00:03:07,726 --> 00:03:09,631
Зачем, почему?

49
00:03:09,631 --> 00:03:13,805
Мы же просто хотим шаблон распаковать.

50
00:03:13,805 --> 00:03:14,880
А вот так.

51
00:03:14,880 --> 00:03:18,088
Дело в том, что этот шаблонизатор,

52
00:03:18,088 --> 00:03:23,410
он компилирует вот html с
псевдоразметкой в код на Go.

53
00:03:23,410 --> 00:03:28,682
Далее мы объявляем функцию (опять-таки,
что странно), мы указываем,

54
00:03:28,682 --> 00:03:34,162
что мы будем наследоваться от base.html,
определяем блок кода,

55
00:03:34,162 --> 00:03:39,635
который мы хотим заменить,
и тут мы уже пишем html-цикл.

56
00:03:39,635 --> 00:03:43,518
Обратите внимание,
это не какой-то там цикл,

57
00:03:43,518 --> 00:03:48,931
который похож на в стандартной библиотеке,
который цикл встроен в шаблонизатор.

58
00:03:48,931 --> 00:03:51,160
Нет, это очень похоже на цикл на Go.

59
00:03:51,160 --> 00:03:54,118
Это действительно есть цикл в коде на Go.

60
00:03:54,118 --> 00:03:58,528
Потому что мы встраиваем,
по сути, сюда код на Go.

61
00:03:58,528 --> 00:04:02,690
Мы выводим переменные,

62
00:04:02,690 --> 00:04:08,950
да они у нас тоже там экранируются для
целочисленных типов, таких, как id.

63
00:04:08,950 --> 00:04:10,507
Мы должны указать,

64
00:04:10,507 --> 00:04:15,120
что мы хотим преобразовать эту переменную,
как ее привести.

65
00:04:15,120 --> 00:04:18,671
То есть что в этом месте у нас
будет целочисленная переменная.

66
00:04:18,671 --> 00:04:21,506
То есть там никаких нет
вычислений в runtime'е.

67
00:04:21,506 --> 00:04:25,780
То есть мы должны указать, что да,
тут будет целочисленная переменная,

68
00:04:25,780 --> 00:04:30,590
чтобы шаблонизатор подставил
нужную функцию преобразования.

69
00:04:30,590 --> 00:04:33,233
Ну и закрываем скобки.

70
00:04:33,233 --> 00:04:37,598
Выглядит, конечно, похоже на ранний php,

71
00:04:37,598 --> 00:04:42,361
когда отдельные шаблонизаторы еще не были
в моде, но на самом деле так и есть,

72
00:04:42,361 --> 00:04:46,280
потому что потом это
компилируется в код на Go.

73
00:04:46,280 --> 00:04:50,853
Смотрите, сейчас у меня файл,
в который будет скомпилирован код.

74
00:04:50,853 --> 00:04:52,920
Он пустой, там нет вообще ничего.

75
00:04:52,920 --> 00:04:57,600
Для того чтобы преобразовать
мой html с разметкой

76
00:04:57,600 --> 00:05:02,280
этого шаблонизатора в код на Go,
мне нужно запустить команду компиляции.

77
00:05:02,280 --> 00:05:04,992
Это не команда компиляции
самого исходника,

78
00:05:04,992 --> 00:05:08,729
это команда компиляции шаблонизатора,
шаблона.

79
00:05:08,729 --> 00:05:09,898
Вот команда.

80
00:05:09,898 --> 00:05:16,130
Я могу запустить ее вот таким образом,
находясь в папке с main'ом.

81
00:05:16,130 --> 00:05:20,770
Однако руками запускать такое бывает

82
00:05:20,770 --> 00:05:25,741
не очень удобно, потому что у вас
может быть много разных блоков,

83
00:05:25,741 --> 00:05:29,449
много разных файлов,
которые распаковывают свои шаблоны,

84
00:05:29,449 --> 00:05:34,846
ну и запускать любую другую кодогенерацию,
например easyjson.

85
00:05:34,846 --> 00:05:39,637
Поэтому очень редко руками
что-то такое компилируется.

86
00:05:39,637 --> 00:05:45,900
В Go есть специальный служебный
комментарий go:generate.

87
00:05:45,900 --> 00:05:50,113
Если мы запустим специальную программу,
которая называется,

88
00:05:50,113 --> 00:05:53,784
как ни странно, go generate,
то она пройдет,

89
00:05:53,784 --> 00:05:59,410
мы можем указать ей исходники,
по которым проходить,

90
00:05:59,410 --> 00:06:03,557
ну у меня я в данном случае ничего
указывать не буду, у меня вся папка.

91
00:06:03,557 --> 00:06:10,190
Она найдет все такие комментарии и
выполнит ту программу, которая в них есть.

92
00:06:10,190 --> 00:06:15,570
То есть я указал, что я хочу каждый
раз компилировать свои шаблоны.

93
00:06:15,570 --> 00:06:17,070
Так, запускаем.

94
00:06:17,070 --> 00:06:18,774
Ага, что-то произошло.

95
00:06:18,774 --> 00:06:22,410
Парсинг, генерация шаблона,
форматирование, окей.

96
00:06:22,410 --> 00:06:24,100
Все, то есть мой шаблон готов.

97
00:06:24,100 --> 00:06:27,043
Мне не придется теперь каждый
раз помнить эту команду.

98
00:06:27,043 --> 00:06:32,630
Я записал ее в исходном файле один раз,
и по команде она будет запускаться сама.

99
00:06:32,630 --> 00:06:36,640
Так, ну и наконец, мы дошли до того,
чтобы посмотреть код.

100
00:06:36,640 --> 00:06:37,528
Ага.

101
00:06:37,528 --> 00:06:42,510
package template, import'ы,

102
00:06:42,510 --> 00:06:47,364
то есть вот import,
который я сам руками прописывал вот здесь.

103
00:06:47,364 --> 00:06:52,800
Вот моя функция,
куда я передаю все параметры.

104
00:06:52,800 --> 00:06:56,840
Вот полностью скомпилированный шаблон.

105
00:06:56,840 --> 00:07:01,626
Он не только какой-то
базовый кусок компилирует,

106
00:07:01,626 --> 00:07:04,067
который потом будет еще что-то вызывать,
нет.

107
00:07:04,067 --> 00:07:07,390
Он компилирует полностью всю функцию,
вместе со всей разметкой.

108
00:07:07,390 --> 00:07:12,160
То есть если у вас десять функций,
которые наследуются от базового шаблона,

109
00:07:12,160 --> 00:07:18,007
у вас будет этот базовый шаблон
в них десять раз повторен.

110
00:07:18,007 --> 00:07:21,663
Ну и дальше начинает писаться в буфер,

111
00:07:21,663 --> 00:07:26,854
который мы туда передали,
вот здесь, начинает писаться код.

112
00:07:26,854 --> 00:07:28,289
Ага, вот мой цикл.

113
00:07:28,289 --> 00:07:29,900
Вот то, что я вывожу.

114
00:07:29,900 --> 00:07:30,534
Вот все.

115
00:07:30,534 --> 00:07:33,150
То есть вот скомпилированный шаблон.

116
00:07:33,150 --> 00:07:35,765
Он уже скомпилирован сразу в Go-код.

117
00:07:35,765 --> 00:07:38,525
Это будет выполняться очень быстро.

118
00:07:38,525 --> 00:07:44,660
Как вы видели, без локаций,
без дополнительного overhead'а по памяти.

119
00:07:44,660 --> 00:07:48,030
Ну и пора это запустить.

120
00:07:48,030 --> 00:07:53,910
go run main.

121
00:07:53,910 --> 00:07:55,270
Так, отлично.

122
00:07:55,270 --> 00:07:58,670
Я запустил свой код, вот он даже открыт.

123
00:07:58,670 --> 00:08:01,110
Мой шаблон выглядит вот так.

124
00:08:01,110 --> 00:08:04,766
То есть это будет работать очень быстро.

125
00:08:04,766 --> 00:08:06,130
Очень быстро.

126
00:08:06,130 --> 00:08:11,070
Однако, конечно, у этого есть недостатки.

127
00:08:11,070 --> 00:08:15,600
Какой недостаток?

128
00:08:15,600 --> 00:08:22,122
Если вы используете шаблонизатор

129
00:08:22,122 --> 00:08:25,760
стандартной библиотеки, либо любой другой,
который работает в runtime'е,

130
00:08:25,760 --> 00:08:31,321
то вы можете шаблоны перезагрузить
во время работы вашей программы.

131
00:08:31,321 --> 00:08:37,520
Если в вашем сервисе frontend разработка
отделена от backend разработки,

132
00:08:37,520 --> 00:08:41,690
то вам иногда бывает удобно
сделать релиз верстки,

133
00:08:41,690 --> 00:08:46,820
релиз frontend'а,
релиз html-части отдельно от backend'а.

134
00:08:46,820 --> 00:08:51,909
И ваша программа, она может в
runtime'е перезагрузить этот код,

135
00:08:51,909 --> 00:08:55,419
перезагрузить эти шаблоны,
и они обновятся.

136
00:08:55,419 --> 00:09:00,406
В случае со скомпилированными
шаблонами такое не пройдет.

137
00:09:00,406 --> 00:09:04,976
Потому что ваш шаблон — это функция на Go.

138
00:09:04,976 --> 00:09:08,680
Для того чтобы переразложить
такие шаблоны,

139
00:09:08,680 --> 00:09:13,540
вам придется перекомпилировать
всю вашу программу.

140
00:09:13,540 --> 00:09:19,605
То есть у компиляции шаблонов в этом плане
есть, конечно, такого рода недостаток.

141
00:09:19,605 --> 00:09:22,034
Но это компенсируется скоростью.

142
00:09:22,034 --> 00:09:24,565
Еще момент, который стоит упомянуть.

143
00:09:24,565 --> 00:09:28,890
Тут мы используем простой буфер данных,
мы каждый раз его создаем,

144
00:09:28,890 --> 00:09:32,660
потом пишем что-то в ответ,
и все, он уничтожается.

145
00:09:32,660 --> 00:09:39,490
Уходит на heat, там освобождается,
собирается сборщиком мусора.

146
00:09:39,490 --> 00:09:45,180
Однако мы можем использовать sync.Pool
и переиспользовать эти данные.

147
00:09:45,180 --> 00:09:50,151
Таким образом,
вы не будете грузить garbage collector,

148
00:09:50,151 --> 00:09:54,826
у вас будут паузы на сборку мусора
гораздо меньше, за счет того,

149
00:09:54,826 --> 00:09:59,410
что вы этот объем данных, эту память
вы будете переиспользовать каждый раз.

150
00:09:59,410 --> 00:10:04,670
Конечно, если у вас шаблоны с
html весят по несколько мегабайт,

151
00:10:04,670 --> 00:10:10,866
то такого рода переиспользование памяти
становится практически необходимым,

152
00:10:10,866 --> 00:10:16,860
если вы хотите много работать с такими
шаблонами на Go под большой нагрузкой.