[БЕЗ_ЗВУКА] В этом видео мы
поговорим про Middleware. Middleware это промежуточный код,
который располагается между реальным оригинальным запросом и
вашей бизнес-логикой. То есть в общем случае Middleware
является любой фреймворк, потому что он осуществляет какой-то
набор общих операций, общих проверок. Но мы поговорим о том, каким образом можно
реализовать базовый функционал Middleware, используя стандартную библиотеку и
без каких-либо внешних зависимостей. Для начала рассмотрим этот код. У нас есть функция pageWithAllChecks,
в начале функции мы обрабатываем панику. Если вдруг у нас что-то где-то
спаниковало в глубине, такого, конечно, у вас быть не должно, то нам нужно это
перехватить, чтобы процесс не упал. Панику надо обрабатывать всегда. Дальше у нас идет печать accessLog,
мы печатаем, какой тип запроса, url, с какого адреса
он пришел, сколько времени занял. AccessLog тоже нужен всегда, мы же
хотим понимать, что у нас происходит. Дальше у нас идет такая проверка
авторизации, в кавычках, потому что мы просто
проверяем наличие cookie. Вот. Вроде бы весь этот код нужен. Однако, если вы будете копипастить
его из функции в функцию, и вам потребуется что-то изменить, то
скорее всего где-то вы изменить забудете, пропустите, и будет ошибка. Теперь рассмотрим,
каким образом можно избавиться от этого дублирования и сделать
эти проверки общими. Рассмотрим Handler. Итак, сначала у нас есть админский мультиплексор какой-либо. Вот. Он обрабатывает страницу админа и
обрабатывает демо-страницу с паникой. В нем, в этом, в этих страницах по этому префиксу
admin нам нужна авторизация. Поэтому мы завернем его
в adminAuthMiddleware. Что мы сделаем? Мы передадим в него наш мультиплексор,
а вернет нам это функция Handler. Теперь пойдем дальше. Сделаем еще один мультиплексор. Теперь это будет уже корневой
мультплексор запросов. Теперь смотрите,
мы в него админом передадим уже handler, который будет идти с авторизацией. Дальше у нас будут
страницы login и logout, и в конце мы установим еще какой-то middleware для печати
accessLog и печати panic. Это siteHandler и в конце уже в
непосредственно вебсервер мы передадим sitehandler, который будет
обрабатывать запросы. То есть что происходит? Смотрите, сначала у нас
отрабатывает panicMiddleware, после этого отрабатывает
accessLogMiddleware, а после у нас есть эта админская страница,
обрабатывает еще третий запрос, adminAuthMiddleware, то есть мы
построили такую цепочку функций, которая вызывается одна за другой. Обратите внимание, panic вызывается
последней, потому что выполняться они будут в обратном порядке по добавлению, то
есть сначала будет panic, потом accessLog. Теперь давайте смотреть,
каким образом это устроено. Начнем мы с panicMiddleware. Мы туда передаем http.Handler
во входящей функции, то есть это может быть Handler func любая, либо это может быть
мультиплексор запросов. Итак. И что происходит дальше? Мы возвращаем тоже http.Handler. И тут уже происходит вся магия. Вот здесь мы возвращаем функцию, которая как раз принимает
входящий запрос в себя, то есть сначала будет
отрабатывать эта функция. В ней мы сделаем в defer обработку паники, а потом сделаем следующую функцию, то есть
наша функция будет вызываться цепочкой, да, у нас их будет много, но тем не менее
они будут вызываться одна за другой. То есть смотрите, я сделал общую
функцию и обернул мой обработчик в нее, теперь по сути все мои обработчики
будут проходить через panicMiddleware. И в каждой из них будет свой
defer с обработкой panic. Рассмотрим дальше. accessLogMiddleware. Та же самая история. Мы оборачиваем функцию,
мы возвращаем функцию... мы принимаем http.Handler
и возвращаем http.Handler. http.Handler мы получаем тем,
что оборачиваем все это дело в функцию, мы печатаем какую-то информацию, какую Middleware отработал,
засекаем время начала запроса, потом идем дальше, вызываем следующую
функцию, которая идет там глубже. Когда эта функция отработала,
мы уже печатаем что-то на экран. Ну и теперь adminAuthMiddleware. Опять та же самая история. То есть мы принимаем функцию и
возвращаем функцию ровно того же типа. При этом мы делаем там свою обертку над
ней, для того чтобы проверить наличие куки, если куки нет, мы средиректим
и сделаем return из этой функции, то есть мы не пойдем дальше
в уже нашу бизнес-логику, в которой будет вызываться по
[НЕРАЗБОРЧИВО] сервер http. То есть таким образом мы
сделали цепочку функций, то есть по сути мы обернули
в некий декоратор, который будет вызываться
одна за другой и дальше уже внутри не будет каждый раз
копипаст этого функционала. Теперь давайте посмотрим на
сами функции с бизнес-логикой. Например, страница паники. Я здесь просто вызываю сразу панику. Список админский. Вот этот вот adminindex он должен
идти сразу за авторизацией. Обратите внимание,
здесь я ничего для авторизации не делаю, я просто печатаю что-то на экран. logout, login и список. То есть все довольно просто и довольно компактно выходит,
мне не нужно уже копипастить. Конечно, вы можете пробросить из этой функции дальше вглубь
что-то через контекст. Давайте посмотрим, как это работает. Так. Итак, запускаем наш сервер. Вот наша страница логина. Посмотрим код. Итак, у нас вызвался panicMiddleware, accessLogMiddleware и accessLogMiddleware
нам напечатал строчку, что у нас GET-запрос, дальше адрес,
которым он был вызван, хост, с которого он был вызван, ну это
корень, и ноль секунд времени он занял, то есть у меня не было никаких внешних
походов, поэтому все очень быстро. Теперь нажимаем кнопку login, теперь
login мне выставил из кука, смотрим код. Ага. Login. Отлично отработал panic, accessLog
и accessLog нам что-то напечатал. Ну и средиректил нас в корень. Теперь зайдем на админскую страницу,
допустим, паника. Мне сразу же напечатал internal server
error, потому что там сразу паника, итак, отработал panicMiddleware,
accessLogMiddleware и admin. На предыдущих страницах
админ не отрабатывал, потому что он установлен только
для Handler с префиксом admin. Ну и паника, которая у меня завершилась. Теперь просто список с админских страниц. Ну вот общая страница. Теперь если я, например, сделаю выход,
да, то есть у меня куки нету, зайду на adminpanic даже,
меня сразу опять средиректнуло на login, потому что у меня нет авторизации,
нет куки, ну и в логе у меня тоже есть, я зашел на панику, мне сказано, опять
вызвалась паника и access, и adminAuth, и adminAuth сказал: друг, у тебя авторизации
нет, я тебя средирекчу обратно. Также запрос занял одну милисекунду. Вот таким образом вы можете
строить цепочки с Middleware, с каким-то промежуточным кодом,
в идеале вы можете сделать вообще свой роутер,
который или там даже свой фреймворк, который будет проводить всю цепочку
вплоть до валидации парсинга параметров. Но скорее всего вы будете
пользоваться каким-либо фреймворком. Но тем не менее это знание
вам может быть полезным в каких-либо других местах, в каком-то
другом коде, который вы будете писать.