1
00:00:00,000 --> 00:00:07,166
[БЕЗ_ЗВУКА] В

2
00:00:07,166 --> 00:00:11,032
этом видео мы продолжим говорить
про middleware и рассмотрим,

3
00:00:11,032 --> 00:00:16,917
каким образом через middleware можно
организовать тайминги каких-либо операций,

4
00:00:16,917 --> 00:00:19,460
происходящих внутри запроса.

5
00:00:19,460 --> 00:00:24,240
Для этого мы обратимся к уже
известному вам пакету «контекст»,

6
00:00:24,240 --> 00:00:28,400
ранее мы его рассматривали только
в аспекте отмены запросов,

7
00:00:28,400 --> 00:00:31,638
однако это не единственная
его возможность.

8
00:00:31,638 --> 00:00:38,410
Второй его возможностью
является возможность

9
00:00:38,410 --> 00:00:41,500
нести в себе некие значения,
то есть context value.

10
00:00:41,500 --> 00:00:45,866
Причем эти значения
будут копироваться при,

11
00:00:45,866 --> 00:00:49,864
точнее, контекст будет
копироваться при перезаписи.

12
00:00:49,864 --> 00:00:55,786
Ну, то есть это такой
tread safe local storage,

13
00:00:55,786 --> 00:01:00,970
но для конкретной области видимости,
то есть для вашего запроса.

14
00:01:00,970 --> 00:01:05,490
Рассмотрим в коде,
что это такое, что это значит.

15
00:01:05,490 --> 00:01:11,397
Рассмотрим функцию main,
тут ничего сложного нет,

16
00:01:11,397 --> 00:01:14,920
мы делаем multiplex запросов,
регистрируем через обработчик,

17
00:01:14,920 --> 00:01:19,430
регистрируем там один
middleware и начинаем запрос.

18
00:01:19,430 --> 00:01:21,220
Вроде ничего сложного.

19
00:01:21,220 --> 00:01:27,110
Но прежде чем рассматривать тайминг
middleware, посмотрим, что в load posts.

20
00:01:27,110 --> 00:01:31,580
Итак, сначала мы получаем контекст,

21
00:01:31,580 --> 00:01:37,342
мы получили контекст из нашего запроса,
request,

22
00:01:37,342 --> 00:01:41,870
теперь я написал небольшую функцию,
которая будет нам эмулировать работу.

23
00:01:41,870 --> 00:01:47,917
В нее мы передаем контекст первым
параметром, контекст всегда

24
00:01:47,917 --> 00:01:52,970
должен передаваться первым параметром, это
такое соглашение, и какое-то имя работы.

25
00:01:52,970 --> 00:01:58,450
Я вызываю несколько функций,
чтобы сделать в виде нескольких работ,

26
00:01:58,450 --> 00:02:05,459
тут я делаю небольшой тайм без emulate,
я расскажу про это дальше,

27
00:02:05,459 --> 00:02:10,270
зачем, и еще что-то, и вывожу,
что request done, все.

28
00:02:10,270 --> 00:02:15,793
То есть единственное отличие от
разработчиков, которых вы видели до этого,

29
00:02:15,793 --> 00:02:19,625
является то, что я тут получаю в начале
контекст и дальше с этим контекстом

30
00:02:19,625 --> 00:02:23,340
работаю, передавая его просто в функцию,
даже не делая какие-то операции.

31
00:02:23,340 --> 00:02:28,570
Теперь что внутри emulateWork.

32
00:02:28,570 --> 00:02:31,518
Ну тоже все очень просто.

33
00:02:31,518 --> 00:02:37,966
Внутри есть функция trackContextTimings,
куда я передаю, собственно,

34
00:02:37,966 --> 00:02:44,087
мой контекст, имя работы, которую я
туда передаю, и время начала запроса.

35
00:02:44,087 --> 00:02:48,566
Я напоминаю, что в defer аргумент
вычисляется в момент удаления defer,

36
00:02:48,566 --> 00:02:52,830
то есть это время выполнится вот здесь,

37
00:02:52,830 --> 00:02:56,970
посчитается, а выполнится
запрос после sleep.

38
00:02:56,970 --> 00:02:57,640
Окей.

39
00:02:57,640 --> 00:03:02,450
Вроде бы мы что-то сделали,
что-то посчитали,

40
00:03:02,450 --> 00:03:08,640
далее я вам продемонстрирую результат,
а потом мы углубимся в детали middleware.

41
00:03:08,640 --> 00:03:14,760
Итак, результат, вот мой запрос, posts 42.

42
00:03:14,760 --> 00:03:20,089
Посмотрите, я вывожу на экран всю работу,

43
00:03:20,089 --> 00:03:25,015
которая там была,
то есть вот мой checkCashe, loadPosts,

44
00:03:25,015 --> 00:03:29,928
причем их было вызвано аж три раза,
Sidebar, Comments, и всего времени,

45
00:03:29,928 --> 00:03:34,491
когда выполнялся запрос общий,
всего времени, которое я посчитал,

46
00:03:34,491 --> 00:03:37,901
используя эту функцию,
trackContextTimings,

47
00:03:37,901 --> 00:03:43,720
и еще какое-то unknown время,
которое занимает почти десять миллисекунд.

48
00:03:43,720 --> 00:03:48,110
Это как раз у нас вот это время.

49
00:03:48,110 --> 00:03:52,860
То есть то время, которое не покрыто
вот этим вот общим таймингом.

50
00:03:52,860 --> 00:03:58,790
То есть штука полезная, мы можем смотреть,

51
00:03:58,790 --> 00:04:05,600
либо какая из функций начала работать
дольше либо в какой функции затык,

52
00:04:05,600 --> 00:04:10,303
либо собирать по этому общую статистику,
строить графики и

53
00:04:10,303 --> 00:04:14,007
смотреть в реальном времени,
что происходит с нашей программой.

54
00:04:14,007 --> 00:04:18,077
Вдруг там какой-то внешний сервис начал
тупить либо после нашего обновления

55
00:04:18,077 --> 00:04:21,700
мы стали делать больше запросов куда-то,
либо они стали дольше.

56
00:04:21,700 --> 00:04:22,729
Окей.

57
00:04:22,729 --> 00:04:25,650
С пользой понятно.

58
00:04:25,650 --> 00:04:26,861
Это важная вещь.

59
00:04:26,861 --> 00:04:30,260
Теперь посмотрим,
как оно реализовано внутри.

60
00:04:30,260 --> 00:04:35,680
Начнем мы с timingMiddleware.

61
00:04:35,680 --> 00:04:36,860
Так.

62
00:04:36,860 --> 00:04:42,760
Сначала я получаю контекст.

63
00:04:42,760 --> 00:04:46,410
Что я делаю?

64
00:04:46,410 --> 00:04:48,302
У меня в запросе есть контекст.

65
00:04:48,302 --> 00:04:50,200
Давайте я лучше напишу вот так.

66
00:04:50,200 --> 00:04:54,308
В моем запросе есть контекст,

67
00:04:54,308 --> 00:04:58,083
в том, что приходит, и request.

68
00:04:58,083 --> 00:05:00,810
Его вы можете получить
через функцию context.

69
00:05:00,810 --> 00:05:05,333
Теперь далее я добавляю еще
какое-либо значение в него,

70
00:05:05,333 --> 00:05:09,488
то есть я говорю context withValue,
указываю ключ,

71
00:05:09,488 --> 00:05:14,280
по которому я хочу к этому
значению в дальнейшем обращаться,

72
00:05:14,280 --> 00:05:18,295
и указываю свою структуру,

73
00:05:18,295 --> 00:05:24,790
ее детали сейчас не очень важны,
указываю в общем какую-то структуру.

74
00:05:24,790 --> 00:05:25,410
Вот.

75
00:05:25,410 --> 00:05:26,621
Что происходит?

76
00:05:26,621 --> 00:05:29,370
У нас создался новый индекс контекста,

77
00:05:29,370 --> 00:05:34,340
в котором появилось новое значение,
которое лежит по timing scale.

78
00:05:34,340 --> 00:05:39,290
При этом старый контекст не изменился,
это copy on right, Окей,

79
00:05:39,290 --> 00:05:45,780
теперь в defer я делаю logContextTimings,
куда опять передаю этот самый контекст,

80
00:05:45,780 --> 00:05:51,118
url и текущее время, точнее,
время начала запроса.

81
00:05:51,118 --> 00:05:54,240
Ну дальше я продолжаю
обслуживать наш запрос.

82
00:05:54,240 --> 00:05:57,990
То есть это middleware и я
оберну свою функцию в контекст.

83
00:05:57,990 --> 00:06:01,792
Таким образом, когда ко мне контекст
приходит, уже моя функция начинает

84
00:06:01,792 --> 00:06:07,430
выполняться, там уже есть
контекст с value timings.

85
00:06:07,430 --> 00:06:11,777
Вроде бы понятно,
мы что-то куда-то присвоили,

86
00:06:11,777 --> 00:06:16,330
что-то есть, как это читается?

87
00:06:16,330 --> 00:06:20,350
Посмотрим trackContextTimings.

88
00:06:20,350 --> 00:06:21,544
Хорошо.

89
00:06:21,544 --> 00:06:27,203
Я получаю уже свое значение,
которое я туда получил.

90
00:06:27,203 --> 00:06:29,779
Поскольку это хранилище
такое универсальное,

91
00:06:29,779 --> 00:06:32,300
то хранится там все в
виде пустого интерфейса.

92
00:06:32,300 --> 00:06:37,497
Поэтому я, используя мой ключ, я получаю

93
00:06:37,497 --> 00:06:44,783
value и сразу же пытаюсь его преобразовать
к своему типу данных ContextTimings.

94
00:06:44,783 --> 00:06:45,810
И проверяю.

95
00:06:45,810 --> 00:06:50,516
Если вдруг там нет этого
ContextTiming или я

96
00:06:50,516 --> 00:06:55,318
его не смог преобразовать либо там лежит
что-то другое с другим типом данных,

97
00:06:55,318 --> 00:07:01,214
кто-то задумал положить,
ну я короче просто выхожу из функции.

98
00:07:01,214 --> 00:07:06,790
В противном случае я смотрю,
сколько прошло

99
00:07:06,790 --> 00:07:11,866
времени от того, что меня передали,
лочусь, внутри у меня там мапка,

100
00:07:11,866 --> 00:07:15,545
мапка не гарутинобезопасный тип данных,
поэтому мне нужно залочиться,

101
00:07:15,545 --> 00:07:20,272
чтобы что-то изменить, в defer сразу
unlock делаю, ну и там смотрю дальше.

102
00:07:20,272 --> 00:07:25,460
Если у меня уже такая метрика есть,
я там плюсую время и количество,

103
00:07:25,460 --> 00:07:27,860
если нет, я создаю ее в map.

104
00:07:27,860 --> 00:07:28,453
Вот.

105
00:07:28,453 --> 00:07:32,140
То есть что, я просто плюсую время.

106
00:07:32,140 --> 00:07:35,790
Это в trackContextTimings.

107
00:07:35,790 --> 00:07:40,550
То есть что я тут делаю, еще раз.

108
00:07:40,550 --> 00:07:45,543
У меня есть абсолютно любая функция,
в которой есть контекст, значит,

109
00:07:45,543 --> 00:07:51,098
внутри этой функции я могу вызвать
track ContextTimings, передать туда

110
00:07:51,098 --> 00:07:56,720
этот контекст, имя метрики, которую я хочу
считать, и время начала, и она засчитает.

111
00:07:56,720 --> 00:08:00,154
Если у меня там этого значения нет,

112
00:08:00,154 --> 00:08:05,099
если нет ContextTiming,
где-то не инициализирован, или еще что-то,

113
00:08:05,099 --> 00:08:08,110
ничего страшного не случится,
потому что я сразу же выйду.

114
00:08:08,110 --> 00:08:15,412
На самом деле это один из
таких недостатков контекста.

115
00:08:15,412 --> 00:08:16,700
Почему?

116
00:08:16,700 --> 00:08:23,321
Потому что все хранится
внутри как пустой интерфейс,

117
00:08:23,321 --> 00:08:27,360
то есть нету у компа time-проверок.

118
00:08:27,360 --> 00:08:32,134
Вы всегда должны будете проверять
кассу пустого интерфейса к нужному вам

119
00:08:32,134 --> 00:08:36,944
типу данных,
и нет какой-то общей документации,

120
00:08:36,944 --> 00:08:43,119
то есть если у нас есть какая-то структура
жесткая, там понятно, что мы туда кладем,

121
00:08:43,119 --> 00:08:46,800
что там делается, поэтому там можно
даже сгенерировать документацию,

122
00:08:46,800 --> 00:08:50,640
а с ContextValue нет ничего.

123
00:08:50,640 --> 00:08:58,000
Да, он резиновый, это хорошо,
но вот он создает такое параллельное api.

124
00:08:58,000 --> 00:09:02,910
Это большой минус.

125
00:09:02,910 --> 00:09:08,180
То есть с контекстом нужно
быть очень осторожным

126
00:09:08,180 --> 00:09:16,560
и передавать туда только те переменные,
хранить там только те значения,

127
00:09:16,560 --> 00:09:21,550
которые нужны вам в течение всего
срока жизни вашего запроса.

128
00:09:21,550 --> 00:09:25,740
То есть instance-логгера
туда передавать не надо,

129
00:09:25,740 --> 00:09:29,930
коннект к базе данных туда
тоже передавать не надо.

130
00:09:29,930 --> 00:09:32,912
Вот тайминги — понятно.

131
00:09:32,912 --> 00:09:40,370
Например, сессию или requestID или
userID там тоже можно хранить.

132
00:09:40,370 --> 00:09:44,888
Однако ни в коем случае нельзя
через контекст передавать сами

133
00:09:44,888 --> 00:09:47,490
параметры функции.

134
00:09:47,490 --> 00:09:52,957
То есть нельзя делать вот так: ctx

135
00:09:52,957 --> 00:09:58,484
: = ctx WithValue,

136
00:09:58,484 --> 00:10:03,418
например, post_id, допустим, 42.

137
00:10:03,418 --> 00:10:05,811
Вот так делать нельзя.

138
00:10:05,811 --> 00:10:09,248
И потом вызывать типа getPosts.

139
00:10:09,248 --> 00:10:13,463
Вот так делать ни в коем случае нельзя.

140
00:10:13,463 --> 00:10:15,900
Это очень плохой тон.

141
00:10:15,900 --> 00:10:19,340
Это создает вам абсолютное
недокументированное параллельное API,

142
00:10:19,340 --> 00:10:23,243
которое не проверяется в compile time
и чревато огромным количеством ошибок.

143
00:10:23,243 --> 00:10:26,884
Поэтому забудьте, что вы можете
передавать так параметры функции.

144
00:10:26,884 --> 00:10:29,612
Туда передаются только
какие-то общие значения.

145
00:10:29,612 --> 00:10:34,865
Если вдруг вы думаете,
что нужно залогировать

146
00:10:34,865 --> 00:10:39,550
что-то, вы можете сделать там ctxlog,

147
00:10:39,550 --> 00:10:43,760
чтобы request id доставать ctx,

148
00:10:43,760 --> 00:10:50,390
some thing happened.

149
00:10:50,390 --> 00:10:53,945
Вот, то есть не передавайте никогда

150
00:10:53,945 --> 00:10:58,703
через контекст параметры функции,
не делайте параллельным API.

151
00:10:58,703 --> 00:11:05,620
Еще раз: контекст нужен для хранения общих
переменных на протяжении вашего запроса.

152
00:11:05,620 --> 00:11:10,630
В моем случае это некое хранилище
таймингов, которые я в конце вывожу.

153
00:11:10,630 --> 00:11:13,830
Ладно.

154
00:11:13,830 --> 00:11:18,690
Мы посмотрели,
каким образом мы добавляем в тайминг.

155
00:11:18,690 --> 00:11:25,597
То есть мы получили нашу
структуру заплюсовали туда и все.

156
00:11:25,597 --> 00:11:33,296
Теперь вернемся к функции Middleware.

157
00:11:33,296 --> 00:11:37,753
Изначально мы тут создали запрос,

158
00:11:37,753 --> 00:11:43,963
создали контекст с таймингами, а дальше
мы в defer его попытаемся слогировать.

159
00:11:43,963 --> 00:11:45,570
Рассмотрим это логирование.

160
00:11:45,570 --> 00:11:49,960
Опять-таки мы проверяем эти тайминги.

161
00:11:49,960 --> 00:11:54,279
Опять проверяем, что они там есть и они
действительно скастовались к тому типу

162
00:11:54,279 --> 00:11:55,900
данных, которые нам нужны.

163
00:11:55,900 --> 00:12:01,380
Теперь смотрим время начала запроса,

164
00:12:01,380 --> 00:12:09,109
и тут я уже начинаю
итерироваться по всем таймингам.

165
00:12:09,109 --> 00:12:14,510
Тут я плюсую к duration и пишу строку,

166
00:12:14,510 --> 00:12:18,480
собственно, что это был за тайминг,

167
00:12:18,480 --> 00:12:22,765
сколько его количество было и
сколько времени он занимал.

168
00:12:22,765 --> 00:12:25,500
Теперь пишу,
сколько всего времени это заняло,

169
00:12:25,500 --> 00:12:28,090
сколько было учтено времени
и сколько не учтено.

170
00:12:28,090 --> 00:12:30,274
И потом вывожу это на экран.

171
00:12:30,274 --> 00:12:34,553
Я не делаю это через плюсование,
конкатенацию строк,

172
00:12:34,553 --> 00:12:40,195
типа так: log + =,

173
00:12:40,195 --> 00:12:45,010
потому что это не очень эффективно,
я и так Sprintfm пользуюсь,

174
00:12:45,010 --> 00:12:48,873
а я сразу пишу просто в буфер.

175
00:12:48,873 --> 00:12:54,600
Итак, еще раз: вот код,
который мне выводится после запроса.

176
00:12:54,600 --> 00:12:56,604
То, что мне выводит после запроса.

177
00:12:56,604 --> 00:12:58,414
Вот, собственно, результат.

178
00:12:58,414 --> 00:13:03,759
То есть я проитерировался main timing,
вывел все, что у меня там было.

179
00:13:03,759 --> 00:13:08,660
Теперь я вывел total,
то есть сколько запрос работал всего.

180
00:13:08,660 --> 00:13:11,937
Я вывел учтенное время, то есть то время,

181
00:13:11,937 --> 00:13:17,644
которое было покрыто этими таймингами,
контекстными, и вывел unknown.

182
00:13:17,644 --> 00:13:23,030
unknown — это неучтенное время,
и я не знаю, на что оно было потрачено.

183
00:13:23,030 --> 00:13:27,446
Помните, вот здесь вот я делал time.Sleep?

184
00:13:27,446 --> 00:13:32,360
Вот это как раз оно,
вот это как раз неучтенное время.

185
00:13:32,360 --> 00:13:39,618
Вот так работает Context Value.

186
00:13:39,618 --> 00:13:45,391
Еще раз я вам напомню: Context Value
предназначен для того,

187
00:13:45,391 --> 00:13:48,200
чтобы хранить в request scope что-то.

188
00:13:48,200 --> 00:13:55,640
То есть хранить какое-то значение
на протяжении жизни вашего запроса.

189
00:13:55,640 --> 00:13:57,975
В нем не надо хранить то,

190
00:13:57,975 --> 00:14:02,368
что не уничтожается после того,
как запрос отработает.

191
00:14:02,368 --> 00:14:05,685
То есть хранить подключение
к базе данных там не надо.

192
00:14:05,685 --> 00:14:10,940
Также через Context Value нельзя
ни в коем случае передавать

193
00:14:10,940 --> 00:14:15,340
параметры в функцию, то есть почему?

194
00:14:15,340 --> 00:14:20,621
Потому что Context Value
работает через пустой интерфейс,

195
00:14:20,621 --> 00:14:27,715
значит, он создает
недокументированное runtime api,

196
00:14:27,715 --> 00:14:31,863
которое нельзя проверить в compile time.

197
00:14:31,863 --> 00:14:36,027
То есть если у вас есть четкая структура,
вы знаете,

198
00:14:36,027 --> 00:14:40,960
что сюда можно присвоить то,
туда се, и есть четкие проверки.

199
00:14:40,960 --> 00:14:46,920
А с Context Value нельзя,
вам нужно все это проверять руками.

200
00:14:46,920 --> 00:14:51,223
В этом плане это неудобно,
однако контекст все-таки вещь нужная,

201
00:14:51,223 --> 00:14:54,650
и если использовать его с умом,
он будет вам в помощь.

202
00:14:54,650 --> 00:14:59,975
Если нет, у вас будет все плохо.

203
00:14:59,975 --> 00:15:05,067
Context Value используется много где,
несмотря на то, что некоторые говорят,

204
00:15:05,067 --> 00:15:11,857
что использовать его вообще не надо,
он есть, его можно применять с пользой.

205
00:15:11,857 --> 00:15:17,084
Если вдруг вам совсем не хватает
базовых функциональностей контекста,

206
00:15:17,084 --> 00:15:23,200
вы все-таки хотите хранить там что-то
общее, лучше сделайте свой контекст.

207
00:15:23,200 --> 00:15:27,910
И храните там не через Value,

208
00:15:27,910 --> 00:15:30,910
который runtime,

209
00:15:30,910 --> 00:15:35,220
который динамический через пустой
интерфейс, а как поле в структуре.

210
00:15:35,220 --> 00:15:39,680
Также контекст никогда не надо присваивать
уже в какую-то готовую структуру, разве

211
00:15:39,680 --> 00:15:45,010
что это ваш отдельный контекст, в который
вы его присваиваете через композицию.

212
00:15:45,010 --> 00:15:50,028
То есть контекст всегда просто контекст,
он не часть структуры,

213
00:15:50,028 --> 00:15:53,400
он всегда передается как
первый аргумент в функцию,

214
00:15:53,400 --> 00:15:57,780
контекст не должен быть параллельным API.

215
00:15:57,780 --> 00:16:03,210
Я надеюсь,
что вы будете использовать его с пользой.