[БЕЗ_ЗВУКА] Во многих предыдущих видео мы часто
возвращали ошибки из наших функций, иногда выводили их на экран, иногда
обрабатывали, иногда просто игнорировали. Настало время поговорить немного
подробнее о том, что такое ошибка, как лучше ее писать,
как лучше ее обрабатывать. Рассмотрим следующую функцию. Представим, что у нас есть какой-то
веб-сервис, которых ходит на какой-то удаленный ресурс по http
и что-то там парсит. В данном случае неважно что,
результат мы тут использовать не будем, нам главное ошибка. У меня есть клиент, http.Client, в который я устанавливаю очень
маленький тайм-аут — одну миллисекунду. Плюс я иду на сервис,
где никто не слушает порт. Почему я не использую дефолтный клиент? Я уже говорил, когда рассказывал про
http.Client, — там нет таймаутов. А я хочу получить ошибку очень быстро. Я вызываю у клиента метод get, передаю
туда url какой-то, который, допустим, меняется внутри нашего
приложения периодически. И мне вернулась ошибка. То есть часто можно встретить
такое: return err сразу. Почему это плохо? Точнее, почему это может быть плохо,
почему это может быть хорошо? Представьте тот сервис, та библиотека, которые вызывают,
просто вернут вам таймаут. Просто строчка timed out. И что? Окей, вы выведете ее в лог, и где искать этот таймаут, как вы
вообще поймете, что там есть таймаут? Допустим, у вас есть access log,
он выведет вам строчку, что была пятисотка и какую-то
информацию об ошибке. Окей, таймаут. Представьте, что у вас поход не на
один внешний ресурс, а на десять. И какой из этих сервисов
вообще «стаймаутит»? Поэтому так делать можно, если вы сможете потом из этой
ошибки как-то вытащить контекст. Но гораздо чаще делают вот так. То есть оборачивают эту ошибку еще в одну, то есть каким-то префиксом. В данном случае у меня
я написал res error, могу поставить тут название функции. И саму ошибку. Можно ее как строку интерпретировать,
можно вот так, как полностью тип данных, который в Go. Это уже лучше. Однако вам вернется таймаут,
а на каком ресурсе? Допустим, пользователь может сходить
в несколько разных ресурсов, передав какой-то параметр. Хорошо, если этот параметр у вас
залогируется и вы будете знать, куда вы идете. Однако бывает так, что непонятно вообще,
на чем мы стаймаутили. Но хотя бы у нас уже есть какая-то
наводка, что getRemoteResource. Поэтому этот вариант
тоже не всегда подходит. Точнее, он имеет место быть, часто делают именно так, если просто
хотят набрать какую-то пачку значений. И потом просто в одном месте вывести. Получается своего рода цепочка,
и в целом можно догадаться уже, что. Однако лучше, если ошибка содержит
не просто, где она произошла, res error или getRemoteResource,
не только что случилось, то есть сам текст ошибки, но еще и
с какими параметрами она произошла. Например, в данном случае
у меня параметр — это url. И я его тут ввожу. Когда вы выведете табло,
у вас сразу будет понятно, что случилось, что вывелась ошибка на конкретном месте,
для такого-то url. По крайней мере, по этому вы можете
какую-то статистику уже построить. И дальше мы в месте,
где мы получаем getRemoteResource, смотрим: если ошибка не нулевая, то мы ее просто выводим в
лог и выдаем пятисотку. То есть последний приведенный пример, когда я оборачиваю ошибку с указанием,
где она произошла, для чего она произошла и с самим текстом
ошибки, он уже имеет место для жизни, им уже можно пользоваться. Но иногда мы хотим конкретно проверять,
какая ошибка вернулась. Например, мы хотим точно знать,
что нам вернулся таймаут. Мы хотим иметь своего рода
типизированную ошибку. Каким образом это происходит? Рассмотрим следующий пример. Тут я использовал пакет errors,
просто errors. У него есть функция New,
он может создать новую ошибку. Туда я написал resource error и
присвоил эту ошибку уже в переменную. Теперь я могу просто вернуть
сразу эту переменную, а на другой стороне я через встречный
пример я могу эту переменную проверить. Таким образом я могу определить,
какого типа была ошибка. И уже в зависимости от этого я
могу либо написать internal error, как было, либо могу сказать, что это
не просто какая-то непонятная ошибка, а ошибка парсинга ресурса,
ошибка доступа к удаленному ресурсу. То есть ошибка у меня уже
принимает какой-то тип. Однако в этом случае теряется контекст. Я уже не могу понять,
на каком url оно произошло, и мне нужно еще это как-то
оборачивать во что-то. Пойдем дальше. И тут мы приходим к тому,
что такое вообще ошибка. Мы везде возвращаем error. Вот он, error — это интерфейс. [ЗВУК] У него единственное, что должно быть, функция error,
всё, которая возвращает строчку. Любая ваша структура,
которая подойдет под этот интерфейс, может возвращаться в качестве ошибки. Почему не сделали стринг? Потому что стринг часто используется
для приведения какой-то, например, структуры в строковую
форму для блогирования. Поэтому стринг не подошел, и у нас error. Для этого введем нашу отдельную
типизированную ошибку. Допустим, она будет
называться ResourceError. У нее будет уже URL как поле структуры и ошибка,
которая там в реальности произошла. Функция Error, которая и делает нашу
структуру ошибкой, выводит текст. Что она говорит: Resource error на
таком-то URL, и такая-то ошибка там произошла дальше, используя, собственно,
параметры этой самой структуры. И когда я смогу определить, что у меня произошла ошибка,
и я хочу вернуть типизированную ошибку. Это уже будет не просто
именованная какая-то переменная, а прямо уже целая структура,
которая содержит в себе информацию о том, на каком месте произошла эта ошибка,
и сам текст ошибки. Вот как это выглядит. То есть я делаю return и структуру. Поскольку это интерфейс,
то он возвращается корректно, и я всегда могу там дальше уже проверить. Как проверить? В этом нам поможет type casting,
то есть я пытаюсь привести к чему-то интерфейс и
пытаюсь определить, какого он типа. В данном случае я делаю
switch err.(type) в скобках. Это мне выдаст тип,
какого рода ошибка у меня есть. Значит, смотрим: первый кейс —
ошибка имеет тип ResourceError, как раз та структура. Теперь что я делаю? Я привожу ее уже к нужному типу. И я не могу обратиться по интерфейсу
к полям структуры, то есть если бы я захотел обратиться к URL или
к этому полю, я бы не смог это сделать, потому что у интерфейсов этих полей нет,
они есть только у структуры. То есть я привел к нужному типу,
и теперь я могу уже вывести на экран не просто, что у меня произошла
какая-то ошибка с удаленным ресурсом, но я могу вывести URL и собственно сам
текст ошибки, которая там произошла. И в случае, если там вернулась любая
другая ошибка, я вывожу об этом текст, о том, что там случилась internal error
— просто какая-то неизвестная ошибка. Конечно, я могу добавлять
еще и еще кейсов. Это хорошо. Но что можно сделать еще? Иногда хочется стек трейс, иногда хочется
корректно оборачивать ошибку в ошибку, в ошибку. Есть пакет pkg/errors на GitHub. Он не встроен в Go, это внешний пакет,
его нужно поставить через Go get. И там есть возможность обернуть ошибку, которая была, в какой-то текст. Таким образом,
можно не типизировать ошибки, не сохранять ошибки для
каждого конкретного случая и иметь какой-то контекст для того,
чтобы определить, что там внутри произошло,
какого типа там была вообще ошибка. То есть если я делаю fmt, [ЗВУК] error %v вот так. И если я напишу вот так, то есть Errorf классическим способом,
то у меня вернется строка. И потом я с этой строкой уже
сделать ничего не смогу, разве что руками ее разбирать. Поэтому errors.Wrap. errors.Wrap оборачивает ошибки, то есть он не теряет тот контекст,
который был внутри нее. Контекст не путайте с пакетом. Не теряет ту ошибку, которая была внутри. На самом деле http.Client возвращает
URL error в случае таймаута. И теперь я могу уже посмотреть,
уже могу привязаться к этой ошибке для того,
чтобы проверить, что там было внутри. Итак, раньше мы приводили
нашу саму ошибку к тексту, а теперь я попробую получить причину этой ошибки, Cause(err) — это
как раз оригинальный текст, оригинальная прямо ошибка,
который я туда передал, когда делал wrap. Я пытаюсь к ней достучаться по type. И я проверяю ее на url.Error. До этого я искусно оборачивал
эту ошибку во что-то свое, на самом деле там возвращается url.Error,
у которого есть поле и URL, и Error. Итак, теперь я могу вывести это на экран. И более того,
если я попробую вывести полную ошибку, то в этом пакете есть стек трейс. Давайте посмотрим, как это работает. Запустили сервер. [ЗВУК] Мне выдало remoteResourceError. Почему? Потому что я определил это как urlError. Итак, смотрим текст: full error. Значит, Get какой-то url не получился,
потому что случилось вот такое вот, и текст resource
error, который я сам туда задавал. И плюс выводится стейк трейс
со всей цепочкой вызова, каким образом мы дошли до этой ошибки. А вот это вот уже вывожу
я в отдельной строчке: resource url не смог выполниться,
потому что ошибка такая-то. pkg/errors — это довольно распространенный способ работы с ошибками, он используется
очень многими пакетами в Go, и он рекомендуется к использованию.