1
00:00:00,000 --> 00:00:07,840
[БЕЗ_ЗВУКА] Поговорим про веб-сокеты.

2
00:00:07,840 --> 00:00:12,890
Веб-сокеты позволяют
установить веб-странице

3
00:00:12,890 --> 00:00:18,140
полнодуплексное соединение с веб-сервером,
и, таким образом,

4
00:00:18,140 --> 00:00:24,617
уже не только страница может
выступать инициатором общения,

5
00:00:24,617 --> 00:00:30,560
но и веб-сервер может со своей
стороны послать сразу что-то в веб.

6
00:00:30,560 --> 00:00:35,774
Это позволяет создавать очень
интерактивные приложения,

7
00:00:35,774 --> 00:00:40,708
когда при появлении какого-то
рода обновлений на сервере,

8
00:00:40,708 --> 00:00:45,059
они сразу же отправляются в веб,
собственно,

9
00:00:45,059 --> 00:00:50,108
во фронтенд без ожидания,
пока фронтенд отправит

10
00:00:50,108 --> 00:00:55,529
какой-либо запрос с вопросом: «А были
ли какие-то обновления?» Рассмотрим,

11
00:00:55,529 --> 00:00:59,280
каким образом можно работать
с веб-сокетами из Go.

12
00:00:59,280 --> 00:01:06,580
Для начала стоит рассказать, что в Go
из коробки нет поддержки веб-сокетов.

13
00:01:06,580 --> 00:01:11,648
Но есть библиотеки, которые реализуют
полную поддержку протокола.

14
00:01:11,648 --> 00:01:15,353
В данном случае мы будем
рассматривать библиотеку

15
00:01:15,353 --> 00:01:18,550
websocket из набора компонент gorilla.

16
00:01:18,550 --> 00:01:24,489
Итак, собственно,
рассмотрим код нашего сервера.

17
00:01:24,489 --> 00:01:29,696
У нас есть страница в корне, которая
ничего не делает, кроме экспанда шаблонов.

18
00:01:29,696 --> 00:01:31,440
На нём мы останавливаться не будем.

19
00:01:31,440 --> 00:01:35,210
И страница с уведомлениями,

20
00:01:35,210 --> 00:01:39,789
которая занимается тем,

21
00:01:39,789 --> 00:01:46,072
что она апгрейдит
соединение до веб-сокета,

22
00:01:46,072 --> 00:01:50,842
то есть веб отправляет
на сервер запрос о том,

23
00:01:50,842 --> 00:01:55,486
можно ли сюда по веб-сокету стучаться,
и мы отвечаем, что да.

24
00:01:55,486 --> 00:01:59,080
Отвечаем как раз при
помощи команды upgrade.

25
00:01:59,080 --> 00:02:05,962
После этого дела то соединение,
куда оно пришло, тот открытый порт...

26
00:02:05,962 --> 00:02:10,470
По сути, веб-сокет — это
труба между сервером и вебом.

27
00:02:10,470 --> 00:02:11,637
И клиентом.

28
00:02:11,637 --> 00:02:16,520
После этого это соединение
мы уже в отдельной корутине

29
00:02:16,520 --> 00:02:18,440
мы начинаем обрабатывать.

30
00:02:18,440 --> 00:02:22,790
В случае, если у нас какой-либо
синхронный язык, например,

31
00:02:22,790 --> 00:02:26,748
PHP, то там с веб-сокетом
работать не то что бы удобно.

32
00:02:26,748 --> 00:02:27,410
Дорого.

33
00:02:27,410 --> 00:02:32,280
Веб-сокеты хорошо себя проявляют
при асинхронном подходе.

34
00:02:32,280 --> 00:02:37,100
В JavaScript'е, например,
ну и в Go, конечно же, тоже.

35
00:02:37,100 --> 00:02:40,979
Мы можем держать очень большое количество
веб-сокет соединений до тех пор,

36
00:02:40,979 --> 00:02:42,340
пока у нас хватает памяти.

37
00:02:42,340 --> 00:02:46,670
И при появлении какого рода
обновлений сразу слать туда данные.

38
00:02:46,670 --> 00:02:52,510
В данном случае я буду каждые 3
секунды слать новое сообщение туда.

39
00:02:52,510 --> 00:02:59,347
То есть я получаю новый пакет с данными,
NewWriter.

40
00:02:59,347 --> 00:03:06,270
Помимо Writer'а там может ещё быть ping,
pong, сообщение о закрытии соединения.

41
00:03:06,270 --> 00:03:07,432
Либо же чтение.

42
00:03:07,432 --> 00:03:11,250
В данном случае я хочу
что-то в веб-сокет записать.

43
00:03:11,250 --> 00:03:15,220
Если у меня не получилось,
я останавливаю ticker и выхожу из цикла.

44
00:03:15,220 --> 00:03:19,730
Ticker надо останавливать,
чтобы не было утечек памяти.

45
00:03:19,730 --> 00:03:23,127
После этого я получаю новое сообщение,

46
00:03:23,127 --> 00:03:28,168
там какие-то фейковые данные,
пишу его в w.Write(),

47
00:03:28,168 --> 00:03:33,570
который я получил от клиента,
ну и сразу это сообщение закрываю.

48
00:03:33,570 --> 00:03:37,872
Оно уходит на сервер,
и я жду следующего сообщения.

49
00:03:37,872 --> 00:03:39,901
Собственно, вот и всё,

50
00:03:39,901 --> 00:03:45,050
как можно организовать отправку
данных с сервера на клиент.

51
00:03:45,050 --> 00:03:48,537
Ну и, конечно,
нужно это продемонстрировать.

52
00:03:48,537 --> 00:03:49,870
Запустим сервер.

53
00:03:49,870 --> 00:03:50,482
Так.

54
00:03:50,482 --> 00:03:54,040
И вот мне приходят мои сообщения.

55
00:03:54,040 --> 00:03:58,870
Раз в три секунды мне будет
приходить какое-то новое сообщение.

56
00:03:58,870 --> 00:04:02,640
какая-то новая информация.

57
00:04:02,640 --> 00:04:07,066
Это очень удобно для разного
рода нагруженных сервисов,

58
00:04:07,066 --> 00:04:10,670
где много клиентов, где часто
приходят любого рода уведомления.

59
00:04:10,670 --> 00:04:13,941
Сайт становится действительно
очень интерактивным.

60
00:04:13,941 --> 00:04:17,965
Вам пришло письмо,
вы сразу же об этом получаете сообщение,

61
00:04:17,965 --> 00:04:21,681
оно сразу же появляется у вас на странице.

62
00:04:21,681 --> 00:04:29,194
Веб-сокет иметь в целом дешевле,
чем организовывать регулярный polling,

63
00:04:29,194 --> 00:04:33,056
то есть постоянный запрос с клиента
на сервер: «А было ли обновление?

64
00:04:33,056 --> 00:04:38,660
А было ли обновление?» Потому что вам
придётся больше информации в итоге гонять.

65
00:04:38,660 --> 00:04:45,260
А с веб-сокетами вам с сервера может
прийти сообщение тогда, когда оно нужно.