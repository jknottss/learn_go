[БЕЗ_ЗВУКА] Поговорим про веб-сокеты. Веб-сокеты позволяют
установить веб-странице полнодуплексное соединение с веб-сервером,
и, таким образом, уже не только страница может
выступать инициатором общения, но и веб-сервер может со своей
стороны послать сразу что-то в веб. Это позволяет создавать очень
интерактивные приложения, когда при появлении какого-то
рода обновлений на сервере, они сразу же отправляются в веб,
собственно, во фронтенд без ожидания,
пока фронтенд отправит какой-либо запрос с вопросом: «А были
ли какие-то обновления?» Рассмотрим, каким образом можно работать
с веб-сокетами из Go. Для начала стоит рассказать, что в Go
из коробки нет поддержки веб-сокетов. Но есть библиотеки, которые реализуют
полную поддержку протокола. В данном случае мы будем
рассматривать библиотеку websocket из набора компонент gorilla. Итак, собственно,
рассмотрим код нашего сервера. У нас есть страница в корне, которая
ничего не делает, кроме экспанда шаблонов. На нём мы останавливаться не будем. И страница с уведомлениями, которая занимается тем, что она апгрейдит
соединение до веб-сокета, то есть веб отправляет
на сервер запрос о том, можно ли сюда по веб-сокету стучаться,
и мы отвечаем, что да. Отвечаем как раз при
помощи команды upgrade. После этого дела то соединение,
куда оно пришло, тот открытый порт... По сути, веб-сокет — это
труба между сервером и вебом. И клиентом. После этого это соединение
мы уже в отдельной корутине мы начинаем обрабатывать. В случае, если у нас какой-либо
синхронный язык, например, PHP, то там с веб-сокетом
работать не то что бы удобно. Дорого. Веб-сокеты хорошо себя проявляют
при асинхронном подходе. В JavaScript'е, например,
ну и в Go, конечно же, тоже. Мы можем держать очень большое количество
веб-сокет соединений до тех пор, пока у нас хватает памяти. И при появлении какого рода
обновлений сразу слать туда данные. В данном случае я буду каждые 3
секунды слать новое сообщение туда. То есть я получаю новый пакет с данными,
NewWriter. Помимо Writer'а там может ещё быть ping,
pong, сообщение о закрытии соединения. Либо же чтение. В данном случае я хочу
что-то в веб-сокет записать. Если у меня не получилось,
я останавливаю ticker и выхожу из цикла. Ticker надо останавливать,
чтобы не было утечек памяти. После этого я получаю новое сообщение, там какие-то фейковые данные,
пишу его в w.Write(), который я получил от клиента,
ну и сразу это сообщение закрываю. Оно уходит на сервер,
и я жду следующего сообщения. Собственно, вот и всё, как можно организовать отправку
данных с сервера на клиент. Ну и, конечно,
нужно это продемонстрировать. Запустим сервер. Так. И вот мне приходят мои сообщения. Раз в три секунды мне будет
приходить какое-то новое сообщение. какая-то новая информация. Это очень удобно для разного
рода нагруженных сервисов, где много клиентов, где часто
приходят любого рода уведомления. Сайт становится действительно
очень интерактивным. Вам пришло письмо,
вы сразу же об этом получаете сообщение, оно сразу же появляется у вас на странице. Веб-сокет иметь в целом дешевле,
чем организовывать регулярный polling, то есть постоянный запрос с клиента
на сервер: «А было ли обновление? А было ли обновление?» Потому что вам
придётся больше информации в итоге гонять. А с веб-сокетами вам с сервера может
прийти сообщение тогда, когда оно нужно.