1
00:00:00,000 --> 00:00:06,750
[БЕЗ_ЗВУКА] В

2
00:00:06,750 --> 00:00:12,150
этом видео мы рассмотрим возможность
интеграции кода на C с кодом с Go,

3
00:00:12,150 --> 00:00:17,150
то есть вызовов C кода из Go.

4
00:00:17,150 --> 00:00:22,360
Этот механизм называется C Go,
и далее мы рассмотрим,

5
00:00:22,360 --> 00:00:28,480
как это происходит технически, и все те
подводные камни, которые вам встретятся.

6
00:00:28,480 --> 00:00:33,775
Итак, попробуем вызвать
простую функцию из Go.

7
00:00:33,775 --> 00:00:39,972
Реализуется это при помощи
псевдо-пакета C, import C.

8
00:00:39,972 --> 00:00:42,881
Псевдо-пакет, что это значит?

9
00:00:42,881 --> 00:00:48,002
Это значит, что это не какой-то исходник
на Go, который вы можете прочитать.

10
00:00:48,002 --> 00:00:49,850
Нет, он реализуется компилятором.

11
00:00:49,850 --> 00:00:57,340
Для того чтобы им воспользоваться,
нужно давить на import C,

12
00:00:57,340 --> 00:01:03,120
и после этого то,
что идет в комментарии над ним,

13
00:01:03,120 --> 00:01:07,370
это будет являться уже кодом на C,

14
00:01:07,370 --> 00:01:11,620
и компилятор его будет воспринимать
соответствующим образом.

15
00:01:11,620 --> 00:01:18,864
Это сишные комментарии,
это сишная функция.

16
00:01:18,864 --> 00:01:21,471
У меня есть функция multiply,

17
00:01:21,471 --> 00:01:26,240
которая принимает два значения
и возвращает их произведение.

18
00:01:26,240 --> 00:01:30,000
Теперь как я должен это вызывать?

19
00:01:30,000 --> 00:01:33,510
У меня есть две переменные a и b.

20
00:01:33,510 --> 00:01:37,735
И чтобы вызвать вообще любой сишный код,

21
00:01:37,735 --> 00:01:41,960
мне нужно добавить префикс C,
то есть обращение к этому псевдо-пакету.

22
00:01:41,960 --> 00:01:46,890
Я вызываю,

23
00:01:46,890 --> 00:01:51,015
C плохо, назовем его лучше result,

24
00:01:51,015 --> 00:01:56,351
res так

25
00:01:56,351 --> 00:02:01,195
будет лучше.

26
00:02:01,195 --> 00:02:05,804
Я вызываю переменную res,
я вызываю функцию multiply,

27
00:02:05,804 --> 00:02:12,530
то есть я добавляю вызов обращение
к пакету и вызываю его функцию.

28
00:02:12,530 --> 00:02:16,380
А теперь первый подводный камень.

29
00:02:16,380 --> 00:02:21,780
Вы не можете передать гошные переменные

30
00:02:21,780 --> 00:02:26,876
в функцию на C,
она про них ничего не знает.

31
00:02:26,876 --> 00:02:31,370
Они другие, они из другой вселенной,
из другого рантайма.

32
00:02:31,370 --> 00:02:35,990
Поэтому вам нужно их конвертировать
в сишные переменные.

33
00:02:35,990 --> 00:02:40,580
Для простых переменных это сделать просто.

34
00:02:40,580 --> 00:02:42,384
int можно конвертировать.

35
00:02:42,384 --> 00:02:47,185
Я обращаюсь к псевдо-пакету C и говорю
в int и делаю int из этой переменной.

36
00:02:47,185 --> 00:02:51,600
Это будут уже сишные переменные,
которые идут сюда, как раз в int a.

37
00:02:51,600 --> 00:02:56,496
Функция multiply тоже вернет мне сишную

38
00:02:56,496 --> 00:03:02,575
переменную res.

39
00:03:02,575 --> 00:03:08,272
Если я хочу ее привести обратно к гошной,
мне нужно проделать обратное

40
00:03:08,272 --> 00:03:12,920
преобразование, привести ее к гошной.

41
00:03:12,920 --> 00:03:17,555
Давайте теперь это запустим.

42
00:03:17,555 --> 00:03:23,534
Значит, запустили,

43
00:03:23,534 --> 00:03:28,180
ждём какое-то время, все, мне вывелось.

44
00:03:28,180 --> 00:03:33,969
multiply, 2 на 3, получится 6, Вот тип,

45
00:03:33,969 --> 00:03:39,040
к которому оно привелось, main_Ctype_int,

46
00:03:39,040 --> 00:03:44,018
это тот тип, который нам вернула сишка.

47
00:03:44,018 --> 00:03:47,690
Получилось с шести.

48
00:03:47,690 --> 00:03:50,778
Теперь я покажу следующий
подводный камень.

49
00:03:50,778 --> 00:03:53,072
Это должно быть довольно быстро.

50
00:03:53,072 --> 00:03:57,030
Запускаем, и вот он у меня пошёл,

51
00:03:57,030 --> 00:04:02,130
я не успел, ладно.

52
00:04:02,130 --> 00:04:08,036
Сишный код собирается при
помощи GCC компилятора.

53
00:04:08,036 --> 00:04:11,952
Для того чтобы собирать
код при помощи C Go,

54
00:04:11,952 --> 00:04:15,431
вам нужен дополнительный GCC поставить.

55
00:04:15,431 --> 00:04:18,124
Visual Studio компилятор
не поддерживается.

56
00:04:18,124 --> 00:04:20,253
Другие компиляторы тоже не поддерживаются.

57
00:04:20,253 --> 00:04:22,880
Может быть, в будущем что-то изменится,
но пока так.

58
00:04:22,880 --> 00:04:30,280
Раз вы устанавливаете C, то вы
теряете возможность кросс-компиляции.

59
00:04:30,280 --> 00:04:37,353
Вам нужно будет тогда использовать
GCC для целевой платформы,

60
00:04:37,353 --> 00:04:42,516
если вы решите собирать отличный от того,
что он стал в базовом GCC.

61
00:04:42,516 --> 00:04:47,868
Например, я могу под виндой собрать
бинарник под Linux и залить его,

62
00:04:47,868 --> 00:04:49,187
всё будет хорошо.

63
00:04:49,187 --> 00:04:57,600
Но в C Go мне уже нужно будет
использовать линуксовый GCC для сбора.

64
00:04:57,600 --> 00:04:58,197
Это раз.

65
00:04:58,197 --> 00:05:02,456
Два — если вы будете использовать
какие-то внешние библиотеки,

66
00:05:02,456 --> 00:05:08,564
которые подключаются вам
каким-либо модулем, то есть DLL,

67
00:05:08,564 --> 00:05:14,870
или сошкой, то вы теряете всю
прелесть статической компиляции,

68
00:05:14,870 --> 00:05:19,863
вы возвращаете ситуацию, возможного
dependency hell, когда вам нужно будет эти

69
00:05:19,863 --> 00:05:25,330
библиотеки доставлять,
и они будут конфликтовать с чем-то другим.

70
00:05:25,330 --> 00:05:27,021
Это первые минусы.

71
00:05:27,021 --> 00:05:31,400
Ещё код через GCC будет
пересобираться каждый раз,

72
00:05:31,400 --> 00:05:34,051
потому что он не знает, что изменилось.

73
00:05:34,051 --> 00:05:37,020
Это будет ещё замедлять кросс-компиляцию.

74
00:05:37,020 --> 00:05:41,510
Ладно.

75
00:05:41,510 --> 00:05:49,790
Рассмотрим теперь,
каким образом можно вызвать код из C,

76
00:05:49,790 --> 00:05:53,910
вызвать код на Go,
то есть обратная ситуация.

77
00:05:53,910 --> 00:06:00,727
Мы вызвали сначала,
у нас запускается гошная программа,

78
00:06:00,727 --> 00:06:04,873
мы вызвали сишный код, из сишного кода
мы теперь хотим вызвать гошный код.

79
00:06:04,873 --> 00:06:07,790
Это тоже можно реализовать.

80
00:06:07,790 --> 00:06:11,833
Посмотрим следующую функцию.

81
00:06:11,833 --> 00:06:15,130
multiply, которая будет

82
00:06:15,130 --> 00:06:20,364
уже печатать

83
00:06:20,364 --> 00:06:25,080
результат при помощи гошной
функции printResultGolang.

84
00:06:25,080 --> 00:06:30,898
Для того чтобы вызвать нам гошную функцию,
нам ее нужно объявить как

85
00:06:30,898 --> 00:06:35,980
экспортируемой, чтобы компилятор
там все нужные биндинги подготовил.

86
00:06:35,980 --> 00:06:42,985
Поскольку компилятор готовит биндинги
и прочее в заголовочном файле,

87
00:06:42,985 --> 00:06:49,100
то, если я буду теперь,
и там же объявлю реализацию,

88
00:06:49,100 --> 00:06:53,320
то компилятор

89
00:06:53,320 --> 00:06:58,741
может заругаться,
что у вас двойное объявление.

90
00:06:58,741 --> 00:07:02,952
У вас есть объявление и там, и тут.

91
00:07:02,952 --> 00:07:11,313
Поэтому часто делается так, что тот код,

92
00:07:11,313 --> 00:07:16,080
который вы объявляете в гошном файле,
то есть перед псевдо-пакетом C,

93
00:07:16,080 --> 00:07:22,341
там вы объявляете только заголовки,
только объявления этих функций.

94
00:07:22,341 --> 00:07:27,640
Сами же эти функции будут реализованы
уже в каком-то внешнем файле.

95
00:07:27,640 --> 00:07:32,065
Например, у меня есть файл на C.

96
00:07:32,065 --> 00:07:36,209
В C Go он бы объявил все в C Go,
и у вас как раз был бы дубль.

97
00:07:36,209 --> 00:07:39,420
Но поскольку я объявил
там только заголовок,

98
00:07:39,420 --> 00:07:43,640
то теперь у меня есть возможность в C
объявить уже реализацию этой функции.

99
00:07:43,640 --> 00:07:47,780
Внешняя функция моя printResultGolang
будет объявляться как extern void.

100
00:07:47,780 --> 00:07:51,920
Теперь это нужно собрать.

101
00:07:51,920 --> 00:07:58,347
[БЕЗ_ЗВУКА] Я

102
00:07:58,347 --> 00:08:04,109
не могу воспользоваться своим любимым go
run, придётся собирать это полностью.

103
00:08:04,109 --> 00:08:09,223
Теперь запускаем,
result-var internals Ctype int.

104
00:08:09,223 --> 00:08:11,248
Обратите внимание,

105
00:08:11,248 --> 00:08:16,560
что тут моя функция printResultGolang
принимает сишный аргумент.

106
00:08:16,560 --> 00:08:23,360
Всё хорошо, и в main у меня тоже она
объявлена, как принятие сишного аргумента.

107
00:08:23,360 --> 00:08:26,430
Однако в этом случае,
если вы будете так делать,

108
00:08:26,430 --> 00:08:30,134
то вы будете несколько раз
переключаться между рантаймами.

109
00:08:30,134 --> 00:08:34,709
Когда вы вызываете функцию main, у вас
гошный runtime, потом вы вызываете функцию

110
00:08:34,709 --> 00:08:39,410
multiply, вы возвращаетесь опять в сишку,
точнее, переходите в сишку.

111
00:08:39,410 --> 00:08:43,310
Когда вы вызываете printResult,
вы опять вызываете гошку,

112
00:08:43,310 --> 00:08:49,641
опять переключаете runtime,
после этого он всё-таки функцию отработал

113
00:08:49,641 --> 00:08:54,450
и опять вернется в сишный runtime,
потому что multiply нужно доработать.

114
00:08:54,450 --> 00:08:59,710
Здесь что-то есть.

115
00:08:59,710 --> 00:09:02,424
return будет делать сишная функция.

116
00:09:02,424 --> 00:09:06,422
Поэтому вы вернетесь опять-таки ещё раз,
и после уже,

117
00:09:06,422 --> 00:09:11,794
как multiply отработает, вы только
тогда вернетесь в гошный runtime.

118
00:09:11,794 --> 00:09:18,060
Почему я говорю про переключение
рантаймов как про что-то плохое?

119
00:09:18,060 --> 00:09:22,330
Это лучше показать на тесте.

120
00:09:22,330 --> 00:09:25,600
У меня вот есть команда.

121
00:09:25,600 --> 00:09:30,556
Тест, который будет вызывать нам просто

122
00:09:30,556 --> 00:09:35,984
пустую функцию из C, просто пустую
сишную функцию и пустую гошную функцию,

123
00:09:35,984 --> 00:09:37,696
которая ничего не будет делать.

124
00:09:37,696 --> 00:09:40,520
Фактически мы меряем как
раз переключение рантайма.

125
00:09:40,520 --> 00:09:45,366
Давайте посмотрим.

126
00:09:45,366 --> 00:09:51,810
Запускаем, C Go.

127
00:09:51,810 --> 00:09:57,440
Обратите внимание, в C Go одна операция

128
00:09:57,440 --> 00:10:03,116
занимает 119 наносекунд,
при том что В обычной Go эта же операция,

129
00:10:03,116 --> 00:10:07,780
вызов пустой функции, которая ничего
не делает, занимает три наносекунды.

130
00:10:07,780 --> 00:10:11,619
Почему так происходит?

131
00:10:11,619 --> 00:10:18,092
Дело в том,
что вот у вас есть вселенная Go,

132
00:10:18,092 --> 00:10:23,442
где есть garbage collector,
треды, горутины,

133
00:10:23,442 --> 00:10:30,100
асинхронщина, перекладывание горутин
из одного системного треда в другой,

134
00:10:30,100 --> 00:10:34,480
а в C этого ничего нет,
он про это ничего не знает.

135
00:10:34,480 --> 00:10:38,955
Поэтому когда вы вызываете

136
00:10:38,955 --> 00:10:43,394
код через CGO, то что происходит?

137
00:10:43,394 --> 00:10:47,361
Происходит лог треда на этот вызов.

138
00:10:47,361 --> 00:10:51,170
То есть вы лочите
полностью системный тред,

139
00:10:51,170 --> 00:10:57,090
для того чтобы вызвать в
нем эксклюзивно ваш C-код.

140
00:10:57,090 --> 00:11:02,818
В случае если бы это был чистый Go-код, то
какая-то там была бы блокирующая операция,

141
00:11:02,818 --> 00:11:05,658
там могли бы выполняться
какие-то другие горутины.

142
00:11:05,658 --> 00:11:07,210
В случае с Go такого не будет.

143
00:11:07,210 --> 00:11:13,072
Вы полностью залочите тред
эксклюзивно на себя, и как раз

144
00:11:13,072 --> 00:11:18,147
все эти переключения рантаймов, туда-сюда,
они как раз занимают много времени.

145
00:11:18,147 --> 00:11:22,500
То есть 119 наносекунд — это,
в общем-то, очень мало,

146
00:11:22,500 --> 00:11:26,990
однако если у вас в процессе вашего
запроса тысячи таких операций,

147
00:11:26,990 --> 00:11:34,500
то это уже может стать заметно, потому что
оттуда же нужно другие горутины убрать.

148
00:11:34,500 --> 00:11:38,550
нужно в планировщике пометить, что туда
не нужно пускать, он залочен, все такое.

149
00:11:38,550 --> 00:11:39,447
Вот.

150
00:11:39,447 --> 00:11:43,038
Это [НЕРАЗБОЧИВО].

151
00:11:43,038 --> 00:11:49,170
Плюс еще раз скажу, что у вас во вселенной
C нет никакого garbage collector.

152
00:11:49,170 --> 00:11:53,630
Поэтому за памятью придется следить.

153
00:11:53,630 --> 00:11:57,670
Рассмотрим следующий код.

154
00:11:57,670 --> 00:12:01,710
Вот у меня есть функция print,

155
00:12:01,710 --> 00:12:07,493
которая принимает Go-строку,

156
00:12:07,493 --> 00:12:12,780
и теперь я, смотрите,

157
00:12:12,780 --> 00:12:17,500
получил, сконвертировал это в C-строку,
все хорошо,

158
00:12:17,500 --> 00:12:23,094
и теперь вот в этой функции конкретной
я сразу же освобождаю этот pointer.

159
00:12:23,094 --> 00:12:25,800
То есть я занимаюсь ручным
освобождением памяти.

160
00:12:25,800 --> 00:12:29,651
То есть если вы не будете это делать,

161
00:12:29,651 --> 00:12:32,943
у вас сразу начинаются утечки
и все прочие прелести.

162
00:12:32,943 --> 00:12:34,510
Но я запущу эту программу.

163
00:12:34,510 --> 00:12:43,090
[БЕЗ_ЗВУКА] Так.

164
00:12:43,090 --> 00:12:47,215
И вот она начинает печатать.

165
00:12:47,215 --> 00:12:48,865
Найдем ее.

166
00:12:48,865 --> 00:12:50,232
Вот она тут есть.

167
00:12:50,232 --> 00:12:51,759
Вот у меня Performance.

168
00:12:51,759 --> 00:12:55,630
Performance Graph, память,
вот она жрет 2,5 мегабайта,

169
00:12:55,630 --> 00:12:58,840
и нормально, никуда не течем, все хорошо.

170
00:12:58,840 --> 00:13:02,930
Теперь давайте я вам
продемонстрирую утечку памяти.

171
00:13:02,930 --> 00:13:06,276
Так, эту мы закрываем,
эту мы останавливаем.

172
00:13:06,276 --> 00:13:11,850
Теперь, допустим, я в пакете
unsafe уберу освобождение памяти.

173
00:13:11,850 --> 00:13:16,140
То есть как раз таки тут
используется unsafe,

174
00:13:16,140 --> 00:13:22,670
для того чтобы получить ссылку на ту
область, где в реальности она хранится.

175
00:13:22,670 --> 00:13:26,072
И посмотрим, что получилось.

176
00:13:26,072 --> 00:13:27,460
Запускаем.

177
00:13:27,460 --> 00:13:29,814
Поехали.

178
00:13:29,814 --> 00:13:32,170
И вперед.

179
00:13:32,170 --> 00:13:38,050
4, 4.5, 4.9, 5, в общем, мы растем.

180
00:13:38,050 --> 00:13:43,660
То есть у нас это даже
уже не в кишках C-кода.

181
00:13:43,660 --> 00:13:47,311
Это просто я забыл освободить
строковую переменную,

182
00:13:47,311 --> 00:13:49,940
под которую у меня выделилась память.

183
00:13:49,940 --> 00:13:57,315
И у меня сразу же началась утечка памяти,
и она растет.

184
00:13:57,315 --> 00:14:02,300
В данном случае это понятно,
где оно, это более-менее ясно,

185
00:14:02,300 --> 00:14:10,410
и это вы еще более-менее можете найти
через хотя бы профилировщик pprof.

186
00:14:10,410 --> 00:14:15,732
Но еще один нюанс,

187
00:14:15,732 --> 00:14:20,710
еще один подводный камень, что как
только вы уходите в другую вселенную,

188
00:14:20,710 --> 00:14:24,392
pprof перестает видеть,
что там происходит дальше.

189
00:14:24,392 --> 00:14:30,079
То есть если Go-функцию я еще могу
отследить, то на момент ухода в CGO,

190
00:14:30,079 --> 00:14:34,211
у меня просто в pprof будет: вызов в CGO.

191
00:14:34,211 --> 00:14:34,810
Всё.

192
00:14:34,810 --> 00:14:36,324
Дальше он там не знает.

193
00:14:36,324 --> 00:14:41,140
И если вы хотите это профилировать,
если вы хотите искать там утечки памяти,

194
00:14:41,140 --> 00:14:46,055
вам придется использовать [НЕРАЗБОРЧИВО],
либо какие-то другие инструменты,

195
00:14:46,055 --> 00:14:48,870
для того чтобы найти эти утечки.

196
00:14:48,870 --> 00:14:52,790
Поэтому тут стоит быть аккуратнее.

197
00:14:52,790 --> 00:14:56,199
Так, ладно, это мы завершим.

198
00:14:56,199 --> 00:14:57,209
Хорошо.

199
00:14:57,209 --> 00:15:05,240
То есть утечки памяти, надо с ними быть
осторожными, чтобы их не допустить.

200
00:15:05,240 --> 00:15:11,501
То есть в простом Go вы от этого почти
всегда избавлены, в большинстве случаев.

201
00:15:11,501 --> 00:15:14,680
Еще один момент, который стоит знать,

202
00:15:14,680 --> 00:15:19,160
как я уже говорил,

203
00:15:19,160 --> 00:15:24,760
в C не будет у вас никакой синхронщины,

204
00:15:24,760 --> 00:15:32,473
и тред будет лочиться
эксклюзивно на ваш вызов.

205
00:15:32,473 --> 00:15:35,940
Рассмотрим следующий код.

206
00:15:35,940 --> 00:15:37,293
Что я тут делаю?

207
00:15:37,293 --> 00:15:40,490
10 мало, давайте поставим 100.

208
00:15:40,490 --> 00:15:44,680
Здесь я запускаю 100 горутин,
внутри которой я запускаю просто sleep.

209
00:15:44,680 --> 00:15:48,200
Все.

210
00:15:48,200 --> 00:15:54,720
Что произойдет, если я это запущу,
сколько мне системных тредов понадобится?

211
00:15:54,720 --> 00:15:58,775
Так.

212
00:15:58,775 --> 00:16:02,830
Ага.

213
00:16:02,830 --> 00:16:07,318
Так, запустили программу, она ушла спать.

214
00:16:07,318 --> 00:16:09,830
Находим вот мои системные треды.

215
00:16:09,830 --> 00:16:13,741
Вот они все есть: раз, два,
три, четыре, пять, шесть.

216
00:16:13,741 --> 00:16:17,179
Вот он мне создал шесть тредов системных,
все такое,

217
00:16:17,179 --> 00:16:21,826
где он все это вертит, где все это живет.

218
00:16:21,826 --> 00:16:25,832
То есть не блокирующие
операции и все такое.

219
00:16:25,832 --> 00:16:28,826
Что будет,
если я попробую вызвать C-sleep,

220
00:16:28,826 --> 00:16:31,790
то есть симулировать какую-то
блокирующую операцию?

221
00:16:31,790 --> 00:16:37,050
Стоп.

222
00:16:37,050 --> 00:16:41,360
Давайте я увеличу тут количество
тоже до 100, чтобы было наглядно.

223
00:16:41,360 --> 00:16:43,318
Запускаем.

224
00:16:43,318 --> 00:16:45,633
Запустилось.

225
00:16:45,633 --> 00:16:46,525
Вот.

226
00:16:46,525 --> 00:16:51,690
Теперь смотрите,
сколько у меня тредов появилось.

227
00:16:51,690 --> 00:16:57,300
То есть я запустил каждую горутину,

228
00:16:57,300 --> 00:17:01,070
у меня 100 горутин,
и внутри этой горутины я вызвал C.sleep.

229
00:17:01,070 --> 00:17:06,380
А поскольку это вызов C-кода,
то он лочит тред на себя.

230
00:17:06,380 --> 00:17:10,901
Это значит, что в этом треде больше
ничего другого выполняться не сможет.

231
00:17:10,901 --> 00:17:11,685
Это значит,

232
00:17:11,685 --> 00:17:16,990
что для обслуживания этих 100 горутин
мне потребуется 100 системных тредов.

233
00:17:16,990 --> 00:17:23,040
В случае, если вы будете ходить по сети с
какими-то СИшными блокирующими вызовами,

234
00:17:23,040 --> 00:17:28,134
то вы как раз будете получать ту ситуацию,
что ваш запрос висит,

235
00:17:28,134 --> 00:17:31,852
ничего не делает,
ожидает ответа от внешней системы,

236
00:17:31,852 --> 00:17:35,020
хотя там могла бы выполняться
какая-то горутина.

237
00:17:35,020 --> 00:17:39,570
То есть вот оверхед.

238
00:17:39,570 --> 00:17:40,563
Так.

239
00:17:40,563 --> 00:17:42,750
Остановим.

240
00:17:42,750 --> 00:17:48,190
Итак, какие выводы можно из этого сделать?

241
00:17:48,190 --> 00:17:51,407
Первое.

242
00:17:51,407 --> 00:17:56,359
Вызов CGO небесплатен.

243
00:17:56,359 --> 00:17:57,828
Второе.

244
00:17:57,828 --> 00:18:03,810
Вызов CGO, то есть C-кода из Go,

245
00:18:03,810 --> 00:18:06,799
может повлечь за собой
неприятные последствия.

246
00:18:06,799 --> 00:18:09,065
Например, у вас начнет течь память,

247
00:18:09,065 --> 00:18:12,450
либо начнет сильно расти
количество системных тредов.

248
00:18:12,450 --> 00:18:16,700
Также вы теряете возможность
кросс-компиляции.

249
00:18:16,700 --> 00:18:21,248
Но когда вообще стоит использовать это?

250
00:18:21,248 --> 00:18:26,560
Во-первых, у вас может не быть выбора.

251
00:18:26,560 --> 00:18:29,897
То есть у вас есть какая-то уже
скомпилированная библиотека,

252
00:18:29,897 --> 00:18:32,690
для которой у вас есть
только заголовочные файлики.

253
00:18:32,690 --> 00:18:39,130
Поэтому выбора у вас нет,
вам придется это подрубать и использовать.

254
00:18:39,130 --> 00:18:43,760
Надейтесь только,
что там нет хождения по сети.

255
00:18:43,760 --> 00:18:49,890
Какие еще хорошие способы применения?

256
00:18:49,890 --> 00:18:54,548
То есть если у вас какая-то библиотека,
которую вы будете вызывать, например,

257
00:18:54,548 --> 00:18:57,759
один раз,
то есть оверхед на вызов будет маленький,

258
00:18:57,759 --> 00:19:02,069
но при этом она внутри очень
оптимизирована, как числодробилка.

259
00:19:02,069 --> 00:19:04,295
Например, TensorFlow.

260
00:19:04,295 --> 00:19:07,960
В Go есть биндинги для TensorFlow,

261
00:19:07,960 --> 00:19:12,968
которые позволяют вам использовать
его для расчетов модели.

262
00:19:12,968 --> 00:19:15,912
То есть у вас есть уже
предпосчитанная модель,

263
00:19:15,912 --> 00:19:18,344
и вы просто вызываете ее через TensorFlow.

264
00:19:18,344 --> 00:19:20,490
Вот это как раз реализовано через CGO.

265
00:19:20,490 --> 00:19:24,993
То есть у вас есть какая-то мощная
числодробилка, оптимизированная,

266
00:19:24,993 --> 00:19:30,710
которая не ходит по сети,
и в этом случае вы можете хорошо выиграть.

267
00:19:30,710 --> 00:19:36,650
Еще из примеров использования CGO,
например, это библиотека SQLite.

268
00:19:36,650 --> 00:19:42,910
Биндинги к SQLite реализованы
сейчас через CGO.

269
00:19:42,910 --> 00:19:48,480
Когда использовать не стоит?

270
00:19:48,480 --> 00:19:53,790
Когда у вас будет очень
много маленьких вызовов.

271
00:19:53,790 --> 00:20:01,017
То есть операция небольшая, короткая,
вы будете терять на оверхеде на вызове.

272
00:20:01,017 --> 00:20:04,514
Еще, как я говорил,
если вы ходите по сети,

273
00:20:04,514 --> 00:20:10,604
то лучше все-таки это
попробовать переписать на Go.

274
00:20:10,604 --> 00:20:17,640
Есть трансплиттеры

275
00:20:17,640 --> 00:20:22,130
C-кода в Go,
однако они еще неполноценно рабочие.

276
00:20:22,130 --> 00:20:23,566
И есть нюансы.

277
00:20:23,566 --> 00:20:28,075
Однако, возможно,
в будущем ситуация исправится,

278
00:20:28,075 --> 00:20:31,840
у нас будет полноценный
конвертер C-кода в Go-код.

279
00:20:31,840 --> 00:20:36,040
Но пока этого нет,
приходится писать руками.

280
00:20:36,040 --> 00:20:40,481
Я надеюсь, что с CGO вы будете
сталкиваться очень редко и не

281
00:20:40,481 --> 00:20:43,890
наступите на все те грабли,
которые в нем есть.