1
00:00:00,000 --> 00:00:08,116
[БЕЗ_ЗВУКА] В этом видео
мы поговорим про те вещи,

2
00:00:08,116 --> 00:00:11,720
которыми, я надеюсь,
вы никогда не будете пользоваться.

3
00:00:11,720 --> 00:00:15,610
Называется это unsafe.

4
00:00:15,610 --> 00:00:21,750
unsafe — это пакет,
это инструмент компилятора,

5
00:00:21,750 --> 00:00:28,040
он позволяет залезать уже в кишки памяти,

6
00:00:28,040 --> 00:00:31,820
достучаться до того, что там лежит глубже.

7
00:00:31,820 --> 00:00:36,250
Если вы используете unsafe,

8
00:00:36,250 --> 00:00:43,050
вам не гарантируется обратная
совместимость между версиями Go,

9
00:00:43,050 --> 00:00:46,971
потому что там может
что-то внутри меняться.

10
00:00:46,971 --> 00:00:54,520
Также unsafe запрещен в некоторых облачных
платформах, например, в Google облаке.

11
00:00:54,520 --> 00:01:02,868
Unsafe позволяет достучаться
прямо до реальной памяти.

12
00:01:02,868 --> 00:01:06,126
Это бывает иногда нужным,
но я очень надеюсь,

13
00:01:06,126 --> 00:01:08,490
вы никогда не будете этим пользоваться.

14
00:01:08,490 --> 00:01:13,330
Рассмотрим данный пример.

15
00:01:13,330 --> 00:01:17,350
Вот у нас есть int64.

16
00:01:17,350 --> 00:01:21,370
Я хочу посмотреть указатель
на этот адрес и размер.

17
00:01:21,370 --> 00:01:29,425
[БЕЗ_ЗВУКА] Так,

18
00:01:29,425 --> 00:01:34,360
запускаем, и вот мне вывелся
указатель и размер 8 байт.

19
00:01:34,360 --> 00:01:38,592
Это уже не uintptr, не то,

20
00:01:38,592 --> 00:01:45,457
что вот обычный &a,
а там прямо совсем кишки.

21
00:01:45,457 --> 00:01:46,310
Вот.

22
00:01:46,310 --> 00:01:52,486
И рассмотрим другой пример, дальше,
то есть то, что с этим можно сделать.

23
00:01:52,486 --> 00:01:55,589
Рассмотрим функцию Float64bits.

24
00:01:55,589 --> 00:01:59,830
Туда мы передадим float64,
а вернется нам int.

25
00:01:59,830 --> 00:02:05,600
То есть что вообще тут
будет происходить-то?

26
00:02:05,600 --> 00:02:13,145
Мы возьмем адрес &f,

27
00:02:13,145 --> 00:02:17,270
то есть uintptr.

28
00:02:17,270 --> 00:02:20,591
И от него возьмем уже Pointer.

29
00:02:20,591 --> 00:02:27,018
А дальше мы интерпретируем это
уже как память, просто память.

30
00:02:27,018 --> 00:02:31,010
А дальше мы интерпретируем как uint64.

31
00:02:31,010 --> 00:02:35,394
И давайте посмотрим, как это выглядит.

32
00:02:35,394 --> 00:02:39,297
Вот наш float,
который мы туда запихнем, 10.1.

33
00:02:39,297 --> 00:02:44,750
И выведем его в десятеричной
и в других системах.

34
00:02:44,750 --> 00:02:48,487
Запустим.

35
00:02:48,487 --> 00:02:54,470
Вот вывелся в десятеричной, то есть
было у нас 10, стало что-то другое.

36
00:02:54,470 --> 00:03:01,900
Вывелся в x и вывелся в бинарном виде,
например, можно еще что-то добавить.

37
00:03:01,900 --> 00:03:07,450
И значения уже стали совершенно другие.

38
00:03:07,450 --> 00:03:10,653
То есть можно посмотреть прямо в Python,
где мантисса,

39
00:03:10,653 --> 00:03:13,000
где экспонента у целочисленного числа.

40
00:03:13,000 --> 00:03:17,068
То есть можно интерпретировать
какую-то область памяти

41
00:03:17,068 --> 00:03:19,480
как совершенно другое значение.

42
00:03:19,480 --> 00:03:23,765
Я надеюсь,
вы этого никогда делать не будете.

43
00:03:23,765 --> 00:03:25,799
Есть еще один пример.

44
00:03:25,799 --> 00:03:29,666
Рассмотрим вот эту структуру Message.

45
00:03:29,666 --> 00:03:34,250
Есть flag, есть строка,
есть еще один flag.

46
00:03:34,250 --> 00:03:36,560
Именно в таком порядке.

47
00:03:36,560 --> 00:03:38,540
Я создам экземпляр.

48
00:03:38,540 --> 00:03:46,470
Теперь я залезу в кишки
этой структуры и посмотрю,

49
00:03:46,470 --> 00:03:52,890
сколько в памяти занимает
сама эта структура

50
00:03:52,890 --> 00:03:58,582
и сколько занимает какое
из полей ее данных и

51
00:03:58,582 --> 00:04:04,025
какой им Offset желателен, и какой Offset
в памяти находится у этой структуры.

52
00:04:04,025 --> 00:04:08,890
То есть например, вы можете достучаться,
просто сдвинувшись по памяти,

53
00:04:08,890 --> 00:04:13,800
и вы сможете достучаться до вот
этого поля вот в этой структуре.

54
00:04:13,800 --> 00:04:17,612
Конечно, так делать не надо.

55
00:04:17,612 --> 00:04:23,077
Вот рассмотрим, Sizeof, сколько оно весит,

56
00:04:23,077 --> 00:04:26,520
Align, выравнивание и Offset.

57
00:04:26,520 --> 00:04:28,040
Давайте это запустим.

58
00:04:28,040 --> 00:04:29,256
Мы уже запустили.

59
00:04:29,256 --> 00:04:30,020
Смотрите.

60
00:04:30,020 --> 00:04:35,400
Размер этой структуры 32 байта в памяти.

61
00:04:35,400 --> 00:04:39,116
Почему 32 байта, откуда они взялись?

62
00:04:39,116 --> 00:04:44,198
flag1 — он у нас по Offset 0,
то есть его смещение

63
00:04:44,198 --> 00:04:51,646
в памяти относительно этих
32 байт — он нулевой.

64
00:04:51,646 --> 00:04:56,805
Дальше идет name — это строчка,

65
00:04:56,805 --> 00:05:02,253
она занимает 16 байт,
потому что внутри строчки там

66
00:05:02,253 --> 00:05:07,810
есть ссылка на данные и длина.

67
00:05:07,810 --> 00:05:10,513
При этом компилятор нам советует,

68
00:05:10,513 --> 00:05:15,480
что выравнивание должно быть 8,
но находится оно по Offset 8.

69
00:05:15,480 --> 00:05:18,522
Что такое выравнивание?

70
00:05:18,522 --> 00:05:20,460
Зачем оно надо?

71
00:05:20,460 --> 00:05:27,560
Дело в том, что оперирует
компилятор машинными словами.

72
00:05:27,560 --> 00:05:32,130
У меня 64-битная операционная система,
у меня размер машинного слова 8.

73
00:05:32,130 --> 00:05:37,424
Поэтому и занимает bool,
булевая переменная, несмотря на то,

74
00:05:37,424 --> 00:05:41,384
что Sizeof у нее 1, занимает он 8 байт.

75
00:05:41,384 --> 00:05:45,841
То есть Offset находится относительно...

76
00:05:45,841 --> 00:05:50,590
То есть моя переменная name
занимает второе место.

77
00:05:50,590 --> 00:05:54,262
Offset ее относительно flag1.

78
00:05:54,262 --> 00:05:55,970
И что мы видим?

79
00:05:55,970 --> 00:06:01,030
flag1 занимает один байт,
но он занимает целое машинное слово.

80
00:06:01,030 --> 00:06:06,610
То есть если я переделаю свою структуру,

81
00:06:06,610 --> 00:06:13,530
и я смогу вместить в эти 8
байт еще какие-то значения.

82
00:06:13,530 --> 00:06:18,324
Поменяем местами флаги в Message, вот так.

83
00:06:18,324 --> 00:06:22,040
Теперь у меня идет две булевых переменных,
а потом идет string.

84
00:06:22,040 --> 00:06:24,140
Запустим.

85
00:06:24,140 --> 00:06:26,240
Смотрите.

86
00:06:26,240 --> 00:06:32,332
Была структура 32 байта, стала 24 байта.

87
00:06:32,332 --> 00:06:33,710
Почему?

88
00:06:33,710 --> 00:06:38,090
Потому что я эффективнее использую память.

89
00:06:38,090 --> 00:06:43,850
То есть раньше у меня flag1 занимал

90
00:06:43,850 --> 00:06:49,300
по сути 8 байт, и 7 было неиспользуемых.

91
00:06:49,300 --> 00:06:52,510
И потом был еще один такой flag2.

92
00:06:52,510 --> 00:06:59,199
А теперь я в начало,
в эти первые 8 байт, я уместил flag1,

93
00:06:59,199 --> 00:07:04,590
flag2, и потом пошло поле name,
которое уже строковое.

94
00:07:04,590 --> 00:07:06,930
То есть в конце, за счет того,

95
00:07:06,930 --> 00:07:12,690
что я передвинул из конца flag2 в начало,
я сэкономил аж 8 байт.

96
00:07:12,690 --> 00:07:15,610
Если у вас какие-то
очень-очень большие структуры,

97
00:07:15,610 --> 00:07:20,695
то вот такой перекомпоновкой вы
можете выиграть немножко места.

98
00:07:20,695 --> 00:07:24,446
Если вы их вдруг выполните миллионы,
то, возможно,

99
00:07:24,446 --> 00:07:26,420
это будет даже довольно значительно.

100
00:07:26,420 --> 00:07:27,437
Есть инструменты,

101
00:07:27,437 --> 00:07:32,512
которые позволяют анализировать структуру
и предлагают поменять поля местами,

102
00:07:32,512 --> 00:07:37,740
чтобы было эффективнее
использование памяти.

103
00:07:37,740 --> 00:07:41,810
На самом деле вам заморачиваться
по этому поводу не стоит.

104
00:07:41,810 --> 00:07:47,180
Просто это та вещь, про которую
полезно знать для общего развития.

105
00:07:47,180 --> 00:07:50,188
Рассмотрим еще один пример.

106
00:07:50,188 --> 00:07:55,732
Как вы помните, мы можем конвертировать
слайс байт в строку и обратно.

107
00:07:55,732 --> 00:08:03,285
При этом, если мы хотим их потом дальше
использовать, то создается копия данных.

108
00:08:03,285 --> 00:08:07,290
А что делать в случае,
если мы не хотим создавать копию данных?

109
00:08:07,290 --> 00:08:15,500
Мы хотим как-то поэкономить и
оптимизировать нашу программу.

110
00:08:15,500 --> 00:08:19,332
В этом случае мы можем воспользоваться
пакетом unsafe и, используя указатель,

111
00:08:19,332 --> 00:08:24,174
напоминаю, unsafe pointer который,

112
00:08:24,174 --> 00:08:28,520
для того чтобы создать строку,

113
00:08:28,520 --> 00:08:35,570
которая будет ссылаться на те же самые
данные, на которые ссылается слайс байт.

114
00:08:35,570 --> 00:08:40,830
Например, вот у меня есть слайс байт,

115
00:08:40,830 --> 00:08:46,351
ну неважно какой.

116
00:08:46,351 --> 00:08:47,713
Какие-то данные.

117
00:08:47,713 --> 00:08:50,040
Теперь я их конвертирую в строку.

118
00:08:50,040 --> 00:08:51,044
Что я делаю?

119
00:08:51,044 --> 00:08:56,880
Значит, мне приходит слайс байт,
теперь я получаю Pointer на эти данные,

120
00:08:56,880 --> 00:08:59,690
то есть слайс — это тоже структура.

121
00:08:59,690 --> 00:09:06,494
У нее есть, я напоминаю, длина,
capacity и ссылка на данные.

122
00:09:06,494 --> 00:09:11,086
Теперь я воспринимаю то,
что я получил с этой структурой,

123
00:09:11,086 --> 00:09:15,609
я теперь воспринимаю как
указатель на заголовок слайса,

124
00:09:15,609 --> 00:09:20,610
то есть саму ту базовую структуру,
которая в слайсе лежит.

125
00:09:20,610 --> 00:09:26,020
То есть у него есть, давайте это запустим,

126
00:09:26,020 --> 00:09:33,161
[БЕЗ_ЗВУКА] вот этот SliceHeader,

127
00:09:33,161 --> 00:09:37,840
у него есть ссылка на данные,
длина и capacity.

128
00:09:37,840 --> 00:09:43,610
Теперь я могу использовать

129
00:09:43,610 --> 00:09:48,164
эти данные,
потому что мне вернулся uintptr,

130
00:09:48,164 --> 00:09:51,529
то есть указатель на данные
у меня уже есть теперь.

131
00:09:51,529 --> 00:09:56,696
Я могу составить из этого структуру,
которая называется StringHeader,

132
00:09:56,696 --> 00:10:00,720
которая состоит только из
указателей на данные и длину.

133
00:10:00,720 --> 00:10:07,730
И потом вернуть

134
00:10:07,730 --> 00:10:12,357
уже эти данные, воспринимая их как строку.

135
00:10:12,357 --> 00:10:17,713
То есть,
вот я получил мой заголовок слайса,

136
00:10:17,713 --> 00:10:20,612
я тут повыводил данные, вот data.

137
00:10:20,612 --> 00:10:27,760
Теперь я создаю новую структуру,
указываю у нее ссылку на данные туда же,

138
00:10:27,760 --> 00:10:33,640
куда ввел слайс байт,
длину указываю ту же самую.

139
00:10:33,640 --> 00:10:38,420
Теперь я получаю адрес

140
00:10:38,420 --> 00:10:43,387
свежесозданной структуры
через unsafe.Pointer и

141
00:10:43,387 --> 00:10:49,260
воспринимаю данные по этому адресу
как строку, которую и возвращаю.

142
00:10:49,260 --> 00:10:54,540
Соответственно, вы можете попробовать

143
00:10:54,540 --> 00:10:59,336
сделать и обратную операцию,

144
00:10:59,336 --> 00:11:04,731
но это чревато проблемами,
если вы где-то ошибетесь,

145
00:11:04,731 --> 00:11:09,584
потому что эти данные могут либо не
собраться в зависимости от того,

146
00:11:09,584 --> 00:11:13,643
что вы сделаете дальше,
либо не собраться garbage collector'ом.

147
00:11:13,643 --> 00:11:16,300
Либо, наоборот,
они могут собраться garbage collector'ом,

148
00:11:16,300 --> 00:11:21,570
когда они еще вами реально используются.

149
00:11:21,570 --> 00:11:27,630
То есть эта оптимизация
имеет тоже свою цену.

150
00:11:27,630 --> 00:11:30,601
Лучше всего туда не лезть.

151
00:11:30,601 --> 00:11:34,534
То есть вам стоит лезть в unsafe тогда,

152
00:11:34,534 --> 00:11:38,559
когда вы точно знаете,
что вы делаете и зачем вам это надо.

153
00:11:38,559 --> 00:11:43,550
Если вы думаете, что вот так нужно делать
всегда, просто потому что это быстрее,

154
00:11:43,550 --> 00:11:45,630
это не так, и в unsafe лезть не надо.

155
00:11:45,630 --> 00:11:48,135
Есть те вещи, которые пробовать не стоит.

156
00:11:48,135 --> 00:11:53,320
И также я напоминаю, что, например,
в облаке Google вы свое приложение

157
00:11:53,320 --> 00:11:58,597
не разместите,
потому что unsafe там запрещен.

158
00:11:58,597 --> 00:12:03,682
unsafe используется,

159
00:12:03,682 --> 00:12:07,258
например, в cgo,

160
00:12:07,258 --> 00:12:11,890
про который мы поговорим дальше.