1
00:00:00,000 --> 00:00:07,896
[БЕЗ_ЗВУКА] В этом видео
мы поговорим про то,

2
00:00:07,896 --> 00:00:13,320
каким образом можно реализовать изменение
конфига без перезагрузки программы.

3
00:00:13,320 --> 00:00:17,980
Часто это называется online conf

4
00:00:17,980 --> 00:00:22,840
или hot reloadConfig.

5
00:00:22,840 --> 00:00:26,342
Зачем это надо и почему это удобно?

6
00:00:26,342 --> 00:00:30,717
Дело в том, что часто хочется развозить
config без того, чтобы перезагружать

7
00:00:30,717 --> 00:00:35,397
сервис, выводить его из нагрузки,
например, а используя какую-то админку.

8
00:00:35,397 --> 00:00:38,973
В данном случае админку мы
будем использовать консул,

9
00:00:38,973 --> 00:00:43,940
где есть key value хранилище,
которое можно организовать, как config.

10
00:00:43,940 --> 00:00:50,279
Я создал там папку myapi, и у меня есть
несколько полей: api_token и max_length.

11
00:00:50,279 --> 00:00:52,253
Это какие-то абстрактные поля,

12
00:00:52,253 --> 00:00:55,800
я не привязываю к ним никакой
бизнес-логики в этом примере.

13
00:00:55,800 --> 00:00:59,506
Давайте создадим ещё один, например,

14
00:00:59,506 --> 00:01:05,530
назовем его address.

15
00:01:05,530 --> 00:01:12,945
Нет, вот так,

16
00:01:12,945 --> 00:01:17,885
пусть будет session_addr и

17
00:01:17,885 --> 00:01:21,774
там какой-то адрес.

18
00:01:21,774 --> 00:01:24,597
Я добавил ещё один config.

19
00:01:24,597 --> 00:01:29,110
Согласитесь, добавлять config
таким образом довольно удобно.

20
00:01:29,110 --> 00:01:34,210
Очень опасно, безусловно, но удобно.

21
00:01:34,210 --> 00:01:37,980
Итак, давайте теперь рассмотрим,
каким образом это можно сделать в коде.

22
00:01:37,980 --> 00:01:43,762
Для начала мы распарсим флаги,

23
00:01:43,762 --> 00:01:47,540
всё-таки совсем всё через
онлайн conf не пустить.

24
00:01:47,540 --> 00:01:51,517
И хотя бы адрес консула
нужно откуда-то передавать.

25
00:01:51,517 --> 00:01:57,991
Далее мы подключаемся к консулу,
загружаем config, запускаем его

26
00:01:57,991 --> 00:02:02,530
онлайн обновление в отдельной горутине,
которая у нас будет работать постоянно.

27
00:02:02,530 --> 00:02:07,371
Дальше мы регистрируем наш
обработчик запросов и оборачиваем

28
00:02:07,371 --> 00:02:09,660
это всё в configMiddleware.

29
00:02:09,660 --> 00:02:17,560
Начнем рассматривать это со стороны
загрузки config для начала.

30
00:02:17,560 --> 00:02:21,200
Итак, загружаем config.

31
00:02:21,200 --> 00:02:25,235
Сначала я создаю QueryOptions.

32
00:02:25,235 --> 00:02:32,240
Когда я приводил пример с консулом в grpc
для service discovery, там был polling.

33
00:02:32,240 --> 00:02:33,365
Polling это значит,

34
00:02:33,365 --> 00:02:37,810
что я периодически опрашиваю внешний
сервис для получения какой-то информации.

35
00:02:37,810 --> 00:02:45,076
В данном случае я немножко
оптимизирую этот механизм,

36
00:02:45,076 --> 00:02:51,532
я не опрашиваю постоянно, я предаю туда
последний известный мне индекс консула.

37
00:02:51,532 --> 00:02:57,372
Это своего рода инкремент, который
обновляется с каждым обновлением консула.

38
00:02:57,372 --> 00:03:00,580
Там есть ещё, например,
параметр wait time,

39
00:03:00,580 --> 00:03:06,216
можно сказать давай ждать больше.

40
00:03:06,216 --> 00:03:09,906
Таким образом,
мне прилетает обновление сразу же,

41
00:03:09,906 --> 00:03:13,110
как только оно появилось
на стороне консула.

42
00:03:13,110 --> 00:03:19,666
Далее, я получаю config,

43
00:03:19,666 --> 00:03:25,320
я обращаюсь к сервису key value в консул,

44
00:03:25,320 --> 00:03:28,049
говорю, дай мне список из префикса.

45
00:03:28,049 --> 00:03:30,756
cfgPrefix у меня это myapi слэш.

46
00:03:30,756 --> 00:03:35,380
Как раз таки то, что мы видим вот здесь.

47
00:03:35,380 --> 00:03:38,314
Итак, и передаю туда опции о том,

48
00:03:38,314 --> 00:03:42,297
чтобы говорить,
что давай ждать последнего индекса.

49
00:03:42,297 --> 00:03:45,119
По умолчанию при старте
программы он равен у меня нулю,

50
00:03:45,119 --> 00:03:46,930
поэтому consul мне ответит сразу.

51
00:03:46,930 --> 00:03:51,958
Возвращает он мне список его значений

52
00:03:51,958 --> 00:03:56,797
и информацию какую-то о самом консуле.

53
00:03:56,797 --> 00:04:01,045
Из этой информации я беру
LastIndex и обновляю его,

54
00:04:01,045 --> 00:04:04,830
то есть я печатаю, что на той
стороне последний индекс такой-то.

55
00:04:04,830 --> 00:04:09,340
Если он вдруг не изменился,
вдруг такое может случиться, я говорю,

56
00:04:09,340 --> 00:04:10,716
что он не изменился.

57
00:04:10,716 --> 00:04:12,560
Тут нужно написать return.

58
00:04:12,560 --> 00:04:18,000
Мне config обновлять не надо.

59
00:04:18,000 --> 00:04:24,767
Далее, я создаю map с новым config'ом,
это map типа string string.

60
00:04:24,767 --> 00:04:30,200
Дело в том, что consul возвращает
вообще как слайс байт данные,

61
00:04:30,200 --> 00:04:34,860
но я их буду как строк интерпретировать.

62
00:04:34,860 --> 00:04:37,187
Если я запрашиваю по префиксу,

63
00:04:37,187 --> 00:04:42,840
то мне вернется в том числе и
сама эта папка, сам этот folder.

64
00:04:42,840 --> 00:04:47,190
Он мне не нужен,
поэтому я его буду пропускать.

65
00:04:47,190 --> 00:04:55,520
Далее я буду убирать префикс этой
папки из ключа и класть его в map.

66
00:04:55,520 --> 00:05:01,320
После этого дела под локом я буду
обновлять уже глобальный config.

67
00:05:01,320 --> 00:05:05,186
Сейчас config у меня сделан в
виде глобальной переменной,

68
00:05:05,186 --> 00:05:09,281
дальше расскажу,
почему так и что с этим мы будем делать.

69
00:05:09,281 --> 00:05:13,988
Итак, обновляя config, обновляя
последний индекс, который у меня был,

70
00:05:13,988 --> 00:05:16,830
и печатаю на экран,
что теперь у меня config изменился.

71
00:05:16,830 --> 00:05:22,390
Посмотрим вживую, как это работает.

72
00:05:22,390 --> 00:05:24,410
Запустим нашу программу.

73
00:05:24,410 --> 00:05:28,990
При старте она у меня запустилась.

74
00:05:28,990 --> 00:05:33,570
Вот мой токен, тут есть индекс создания,
индекс модификации,

75
00:05:33,570 --> 00:05:38,020
есть лок, флаги и прочее.

76
00:05:38,020 --> 00:05:40,859
Вот мой max_length,

77
00:05:40,859 --> 00:05:46,654
вот мой session_addr,
и последний индекс 1563.

78
00:05:46,654 --> 00:05:51,808
Таким образом, индекс моего
config это 1563, о чём я написал.

79
00:05:51,808 --> 00:05:54,420
Config обновился до версии 1563.

80
00:05:54,420 --> 00:05:57,465
Вейт представляет из себя
и сейчас вот такую map.

81
00:05:57,465 --> 00:05:59,940
token, max_length и session_addr.

82
00:05:59,940 --> 00:06:01,509
Хорошо.

83
00:06:01,509 --> 00:06:03,470
Я обновил.

84
00:06:03,470 --> 00:06:08,260
Теперь надо посмотреть,
что я могу получить.

85
00:06:08,260 --> 00:06:13,122
Я вывел теперь обращение к
этому config уже в вебе.

86
00:06:13,122 --> 00:06:18,263
В вебе моя бизнес-логика
обратилась к этому

87
00:06:18,263 --> 00:06:22,975
config для того,
чтобы получить какие-то значения.

88
00:06:22,975 --> 00:06:26,780
Тут сразу можно заметить
какую-то проблему.

89
00:06:26,780 --> 00:06:28,385
Какая проблема?

90
00:06:28,385 --> 00:06:31,490
Config глобальный, global cfg.

91
00:06:31,490 --> 00:06:36,060
На самом деле там не так,
но почему это проблема, я объясню сейчас.

92
00:06:36,060 --> 00:06:39,142
Может возникнуть такой случай,

93
00:06:39,142 --> 00:06:44,097
что у вас под каким-то config в
вашем приложении включается или

94
00:06:44,097 --> 00:06:49,560
выключается какой-то функционал в начале
вашего запроса и в конце вашего запроса.

95
00:06:49,560 --> 00:06:55,440
Однако тот функционал,
который включается в конце,

96
00:06:55,440 --> 00:06:59,680
он требует того, что было
проинициализировано, например, вот здесь.

97
00:06:59,680 --> 00:07:04,700
А если его не будет, произойдет бабах.

98
00:07:04,700 --> 00:07:05,658
Что это значит?

99
00:07:05,658 --> 00:07:10,083
Это значит что, если между этими
вещами где-нибудь вот здесь произойдет

100
00:07:10,083 --> 00:07:14,870
обновление config,
этой глобальной map, то будет плохо.

101
00:07:14,870 --> 00:07:17,650
Может возникнуть рейз.

102
00:07:17,650 --> 00:07:22,280
Рейз даже не по обращению к map, не на то,
что она конкурентна и безопасна,

103
00:07:22,280 --> 00:07:25,211
а рейз именно по самой логике.

104
00:07:25,211 --> 00:07:29,170
Поэтому даже покрытие локом не поможет.

105
00:07:29,170 --> 00:07:32,270
Как быть и что делать?

106
00:07:32,270 --> 00:07:36,094
Вроде как у меня есть Lock,

107
00:07:36,094 --> 00:07:41,030
но всё равно он от этой
ситуации не спасает.

108
00:07:41,030 --> 00:07:42,364
Хорошо.

109
00:07:42,364 --> 00:07:48,710
Теперь уже посмотрим
наш config MiddleWare.

110
00:07:48,710 --> 00:07:51,710
Что в нём происходит?

111
00:07:51,710 --> 00:08:00,137
В нём я в контекст
записывал локальный config.

112
00:08:00,137 --> 00:08:02,590
Я получаю его под ридлоком.

113
00:08:02,590 --> 00:08:08,153
Read lock — это значит, что я беру
информацию какую-то просто на чтение,

114
00:08:08,153 --> 00:08:11,837
я не буду ее изменять внутри.

115
00:08:11,837 --> 00:08:15,910
Поэтому если у меня будет
много конкурентных запросов,

116
00:08:15,910 --> 00:08:19,954
в этом месте тормозить не будет,
не будет глобального лока,

117
00:08:19,954 --> 00:08:23,550
он будет только в случае,
когда config обновляется.

118
00:08:23,550 --> 00:08:27,646
Хорошо, теперь я получил localCfg.

119
00:08:27,646 --> 00:08:31,330
В чём весь смысл этой операции?

120
00:08:31,330 --> 00:08:36,130
А весь смысл этой операции в том,
что map — это ссылочный тип.

121
00:08:36,130 --> 00:08:39,880
Таким образом,
я получаю ссылку на эту map,

122
00:08:39,880 --> 00:08:45,360
и дальше я прокидываю ее
вместе с контекстом везде,

123
00:08:45,360 --> 00:08:48,112
через контекст WithValue.

124
00:08:48,112 --> 00:08:52,381
И, таким образом, когда я буду
получать эту map из контекста,

125
00:08:52,381 --> 00:08:54,770
я буду всегда обращаться
к одной и той же map.

126
00:08:54,770 --> 00:08:58,935
Таким образом, если я вот здесь
в начале запроса ее создам,

127
00:08:58,935 --> 00:09:02,460
она мне неизменной пройдет
через весь мой запрос.

128
00:09:02,460 --> 00:09:06,604
Таким образом, в случае,
когда вот здесь я требую того,

129
00:09:06,604 --> 00:09:09,609
чтобы здесь нет, у меня не случится.

130
00:09:09,609 --> 00:09:14,710
Но вы скажете, а как же так,
GlobalCfg он же обновляется.

131
00:09:14,710 --> 00:09:21,291
Дело в том, что я меняю только саму
ссылку на GlobalCfg и причём под локом.

132
00:09:21,291 --> 00:09:26,300
Я не меняю саму оригинальную map,
которая была там ранее.

133
00:09:26,300 --> 00:09:32,128
Поэтому, как только я меняю ссылку на
GlobalCfg, то, что там находится внутри,

134
00:09:32,128 --> 00:09:36,514
оно уже теперь лежит
только в тех контекстах,

135
00:09:36,514 --> 00:09:41,534
которые использует этот config,
ту версию предыдущую.

136
00:09:41,534 --> 00:09:42,874
Что это значит?

137
00:09:42,874 --> 00:09:47,848
Это значит, что как только все эти
контексты завершатся, выйдут из памяти,

138
00:09:47,848 --> 00:09:51,000
то старый config просто
уберется сборщиком мусора.

139
00:09:51,000 --> 00:09:54,290
Довольно удобно.

140
00:09:54,290 --> 00:09:59,358
Я кладу в контекст ссылку
на текущую неизменяемую

141
00:09:59,358 --> 00:10:07,580
map с контекстом и протаскиваю ее
сквозь весь свой запрос весь реквест.

142
00:10:07,580 --> 00:10:11,720
Это request scoped config такой.

143
00:10:11,720 --> 00:10:14,536
Хорошо, config WithValue.

144
00:10:14,536 --> 00:10:19,490
Теперь я могу получить его через ctxValue.

145
00:10:19,490 --> 00:10:26,346
Я обращаюсь к config, получаю map
string string и преобразую его...

146
00:10:26,346 --> 00:10:29,978
В контекст Value, напомню,
лежит пустой интерфейс.

147
00:10:29,978 --> 00:10:35,530
Я получаю его, преобразую, если вдруг он
не преобразовался либо там ещё что-то,

148
00:10:35,530 --> 00:10:38,001
я говорю, что ошибка, config нет.

149
00:10:38,001 --> 00:10:43,730
Дальше я его получаю и вывожу
вам на экран то, что вы видели.

150
00:10:43,730 --> 00:10:49,149
Вот мой config теперь 1563.

151
00:10:49,149 --> 00:10:55,350
Теперь, если я что-то обновлю,

152
00:10:55,350 --> 00:10:59,873
то с той стороны он
сразу же обновится 1599.

153
00:10:59,873 --> 00:11:02,310
Всё, config обновился.

154
00:11:02,310 --> 00:11:08,680
По-прежнему есть некоторые опасности,
конечно же, его использования.

155
00:11:08,680 --> 00:11:13,922
Конечно, это создает некоторое
параллельное api, но иногда

156
00:11:13,922 --> 00:11:20,502
всё-таки бывает нужно бизнес-логику
каким-то образом конфигурировать быстро.

157
00:11:20,502 --> 00:11:24,316
Это вот один из вариантов,
это пища вам для размышления.

158
00:11:24,316 --> 00:11:27,977
Это не продакшн вариант,
конечно же, но, я надеюсь,

159
00:11:27,977 --> 00:11:32,690
он вас натолкнет на какие-то решения,
которые подходят к вам.

160
00:11:32,690 --> 00:11:37,110
Какие есть недостатки у этого config?

161
00:11:37,110 --> 00:11:38,532
Во-первых, это map.

162
00:11:38,532 --> 00:11:43,171
Это map string string,
она не структурирована, то есть вы можете

163
00:11:43,171 --> 00:11:48,900
опечататься, там может
не быть нужного ключа,

164
00:11:48,900 --> 00:11:53,930
он может быть не в том формате, валидации
тут никакой нет, поэтому, возможно,

165
00:11:53,930 --> 00:11:58,614
сюда стоит провести какую-то валидацию с
сообщением о том, что config неправильный.

166
00:11:58,614 --> 00:12:00,180
Либо хотя бы писать там Json,

167
00:12:00,180 --> 00:12:04,775
который вы уже будете распаковывать
в нужную вам структуру.

168
00:12:04,775 --> 00:12:11,417
Тут даже есть специальная опция
Validate Json Также это удобно,

169
00:12:11,417 --> 00:12:15,610
когда вы конфигурируете какие-то ваши
бизнес-опции, например, вкл-выкл.

170
00:12:15,610 --> 00:12:19,530
Потому что они всё-таки простые.

171
00:12:19,530 --> 00:12:25,916
Либо ещё какие-то именно
бизнес-опции для бизнес-логики.

172
00:12:25,916 --> 00:12:29,360
Если же вы будете конфигурировать,
например,

173
00:12:29,360 --> 00:12:34,100
адреса к каким-то базам данных
или каким-то микросервисам,

174
00:12:34,100 --> 00:12:37,910
то тут могут возникнуть проблемы в том,

175
00:12:37,910 --> 00:12:42,033
что вам нужно обрабатывать
код для переинициализации,

176
00:12:42,033 --> 00:12:45,632
вам нужно покрывать эти
сервисы локом для того,

177
00:12:45,632 --> 00:12:51,360
чтобы не обратиться случайно туда,
где уже никакого сервиса нет.

178
00:12:51,360 --> 00:12:54,438
Поэтому к этому нужно подходить осторожно.

179
00:12:54,438 --> 00:12:57,280
Это, ещё раз напомню, учебный пример.

180
00:12:57,280 --> 00:13:00,741
Просто для того чтобы показать вообще,
как можно,

181
00:13:00,741 --> 00:13:04,840
каким образом можно организовать
что-то вообще подобное,

182
00:13:04,840 --> 00:13:09,867
и надеюсь, что вы с умом

183
00:13:09,867 --> 00:13:15,200
подойдете к организации вашего config

184
00:13:15,200 --> 00:13:20,460
и у вас не будет тех страшных вещей,
которые я описал в этом видео.