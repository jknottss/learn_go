1
00:00:00,000 --> 00:00:05,430
[БЕЗ_ЗВУКА] В

2
00:00:05,430 --> 00:00:11,156
этом видео мы затронем очень
важную тему для любого сервера,

3
00:00:11,156 --> 00:00:13,840
находящегося под нагрузкой,
а именно мониторинг.

4
00:00:13,840 --> 00:00:18,688
Если нет мониторинга, то непонятно вообще,

5
00:00:18,688 --> 00:00:21,791
жив наш сервер или он вообще не работает.

6
00:00:21,791 --> 00:00:25,756
Может быть, там постоянно идут ошибки,
либо после последнего обновления у

7
00:00:25,756 --> 00:00:28,470
нас очень сильная деградация
производительности.

8
00:00:28,470 --> 00:00:33,497
Для того чтобы мониторить сервер,
мы хотя бы хотим

9
00:00:33,497 --> 00:00:39,230
получать базовые метрики: сколько памяти
он занимает, какое количество горутин.

10
00:00:39,230 --> 00:00:43,270
Давайте рассмотрим, какие инструменты
есть в Go для этих целей.

11
00:00:43,270 --> 00:00:48,010
Начнем мы с пакета,
который называется expvar.

12
00:00:48,010 --> 00:00:54,298
Пакет expvar позволяет
вам зарегистрировать

13
00:00:54,298 --> 00:00:59,448
debug-обработчик в вашем
стандартном HTTP-хендлере.

14
00:00:59,448 --> 00:01:01,830
Видите, у меня здесь ничего нет,

15
00:01:01,830 --> 00:01:05,430
он в init-функции там будет
проинициализирован сам.

16
00:01:05,430 --> 00:01:11,624
После этого по специальному URL,
вот такому — debug/vars

17
00:01:11,624 --> 00:01:16,830
— нам будет доступна некоторая
статистика по вашему серверу.

18
00:01:16,830 --> 00:01:21,076
Например, по умолчанию там идут
параметры командной строки,

19
00:01:21,076 --> 00:01:26,880
из которой была запущена ваша программа,
и статистика по памяти.

20
00:01:26,880 --> 00:01:31,851
Основное, что у нас может тут
интересовать — это размер хипа

21
00:01:31,851 --> 00:01:35,250
— HeapInuse, то есть количество байт,

22
00:01:35,250 --> 00:01:39,870
которые наша программа аллоцировала
в динамической памяти.

23
00:01:39,870 --> 00:01:43,440
Как раз по хипу и работает
garbage collector.

24
00:01:43,440 --> 00:01:48,720
StackInuse — количество памяти,
которое находится на стеке,

25
00:01:48,720 --> 00:01:51,900
которое аллоцировано для стека.

26
00:01:51,900 --> 00:01:56,936
И разного рода информация
по garbage collector: какие

27
00:01:56,936 --> 00:02:01,882
у нас слабые есть, когда последний
раз был запуск сборщика мусора,

28
00:02:01,882 --> 00:02:06,643
сколько времени он занимал
и прочая информация.

29
00:02:06,643 --> 00:02:11,652
То есть уже этого достаточно,
чтобы сделать

30
00:02:11,652 --> 00:02:16,050
простой мониторинг — хотя бы дергать
сервер и смотреть, живой он или неживой.

31
00:02:16,050 --> 00:02:20,201
Однако иногда этого бывает мало,

32
00:02:20,201 --> 00:02:24,328
и мы хотим добавить туда
какую-то свою статистику,

33
00:02:24,328 --> 00:02:28,938
например статистику по количеству горутин,
либо по количеству

34
00:02:28,938 --> 00:02:34,070
обработанных запросов,
либо о просто прошедшем запросе.

35
00:02:34,070 --> 00:02:37,320
Давайте попробуем это сделать.

36
00:02:37,320 --> 00:02:40,315
Я объявлю новую мапу,

37
00:02:40,315 --> 00:02:45,179
специально для expvar, назову ее hits.

38
00:02:45,179 --> 00:02:50,359
И теперь при каждом хите я
буду добавлять туда Path,

39
00:02:50,359 --> 00:02:53,266
который мне пришел.

40
00:02:53,266 --> 00:02:58,305
И автоматически, когда я добавляю
через NewMap — вот оно у меня

41
00:02:58,305 --> 00:03:05,870
тоже называется hits, — автоматически она
добавляется в экспорт в нашу функцию.

42
00:03:05,870 --> 00:03:08,111
Здесь она находится вот в этом месте.

43
00:03:08,111 --> 00:03:14,202
Обратите внимание: тут есть
favicon и api/v1/user, то есть

44
00:03:14,202 --> 00:03:19,050
уже я могу количество уже экспортировать
просто буквально одной функцией.

45
00:03:19,050 --> 00:03:26,720
Единственный нюанс — что эта мапа
по умолчанию не сбрасывается.

46
00:03:26,720 --> 00:03:34,248
Также я могу зарегистрировать
какой-то свой обработчик,

47
00:03:34,248 --> 00:03:40,640
который будет вызываться
при каждом вызове expvar,

48
00:03:40,640 --> 00:03:45,131
и там будет уже отдаваться не статические
данные, а выполняться какая-то функция.

49
00:03:45,131 --> 00:03:50,433
Например, этой функцией вы можете
собрать тайминги по вашим запросам

50
00:03:50,433 --> 00:03:56,934
либо из глобального хранилища тайминга
просто здесь настроить экспорт.

51
00:03:56,934 --> 00:04:01,417
В данном случае я объявляю
переменную mystat, объявляю,

52
00:04:01,417 --> 00:04:03,888
что она будет вызывать функцию.

53
00:04:03,888 --> 00:04:07,880
И в этой функции я возвращаю сейчас
статичную мапу, то есть у меня есть

54
00:04:07,880 --> 00:04:12,090
несколько статичных значений и количество
активных горутин в данный момент.

55
00:04:12,090 --> 00:04:16,857
И вот моя статистика,
вот количество горутин,

56
00:04:16,857 --> 00:04:21,050
в данный момент 5,
и несколько статичных значений,

57
00:04:21,050 --> 00:04:27,700
то есть уже можно делать чуть более
сложный мониторинг, чем количество памяти.

58
00:04:27,700 --> 00:04:36,022
Стоит еще сказать, что подобным образом
можно сбрасывать сбрасывать мапу,

59
00:04:36,022 --> 00:04:40,933
мапу со значениями,
которую мы инкрементим.

60
00:04:40,933 --> 00:04:45,711
У нее есть функция Init, и мы можем,
вызвав ее в подобном обработчике,

61
00:04:45,711 --> 00:04:47,339
просто сбросить все.

62
00:04:47,339 --> 00:04:49,920
Давайте попробуем это запустить.

63
00:04:49,920 --> 00:04:54,585
Запускаем и смотрим.

64
00:04:54,585 --> 00:04:57,430
Так, сейчас китов у меня никаких нету.

65
00:04:57,430 --> 00:05:03,045
Теперь я сделаю несколько
запросов на пользователя.

66
00:05:03,045 --> 00:05:07,704
Вот у меня появилось: 4 запроса
на пользователя и фавиконка.

67
00:05:07,704 --> 00:05:11,500
Если я сейчас перезагружу,
у меня останется только фавиконка,

68
00:05:11,500 --> 00:05:15,745
потому что запросов на пользователя
уже нету, они у меня ушли,

69
00:05:15,745 --> 00:05:20,130
потому что мапа со значениями сбросилась.

70
00:05:20,130 --> 00:05:25,060
То есть вот буквально
в 30 строчек вы можете

71
00:05:25,060 --> 00:05:28,170
организовать простой
мониторинг вашего сервера.

72
00:05:28,170 --> 00:05:32,695
Однако дергать руками,

73
00:05:32,695 --> 00:05:35,763
если у вас, конечно, ваша система
мониторинга не построена на том,

74
00:05:35,763 --> 00:05:40,850
что вы сами опрашиваете сервер,
дергать руками такой URL неудобно.

75
00:05:40,850 --> 00:05:44,980
Гораздо чаще у нас бывает настроен
какой-то сервер статистики,

76
00:05:44,980 --> 00:05:49,680
куда все ваши серверы шлют метрики.

77
00:05:49,680 --> 00:05:53,658
Например, это может быть graphite.

78
00:05:53,658 --> 00:05:58,577
Давайте посмотрим,
каким образом можно слать данные в

79
00:05:58,577 --> 00:06:02,327
graphite вообще без
каких-либо внешних библиотек.

80
00:06:02,327 --> 00:06:04,340
Давайте рассмотрим этот код.

81
00:06:04,340 --> 00:06:10,373
У нас есть функция с простым обработчиком,
который просто пишет значение "Hello,

82
00:06:10,373 --> 00:06:16,005
world", есть адрес graphite — тут,

83
00:06:16,005 --> 00:06:22,970
кстати, надо flags flags.Parse добавить,
а то вы не сможете его переопределить.

84
00:06:22,970 --> 00:06:28,620
Вот, flag.Parse.

85
00:06:28,620 --> 00:06:29,833
Вот так.

86
00:06:29,833 --> 00:06:37,323
У нас есть наша функция-обработчик, и все
— она, на самом деле, ничего не делает.

87
00:06:37,323 --> 00:06:41,060
Основное, что нас в этом примере
интересует — это функция sendStat.

88
00:06:41,060 --> 00:06:46,514
Внутри этой функции — я ее запускаю в
отдельной горутине — я буду получать

89
00:06:46,514 --> 00:06:51,360
статистику по памяти и по
количеству использованных горутин.

90
00:06:51,360 --> 00:06:59,870
Для начала я соединюсь с graphite по TCP —
я хочу, чтобы мои данные доходили всегда.

91
00:06:59,870 --> 00:07:04,636
После этого я буду каждую
минуту слать туда данные.

92
00:07:04,636 --> 00:07:10,563
Я объявляю новый тикер,
и в цикле по нему итерируюсь.

93
00:07:10,563 --> 00:07:15,415
Напомню, что тикер возвращает мне канал,

94
00:07:15,415 --> 00:07:20,912
в котором значение появляется в
тот интервал, который я указал.

95
00:07:20,912 --> 00:07:22,740
В данном случае это минута.

96
00:07:22,740 --> 00:07:26,410
И там возвращается текущее время.

97
00:07:26,410 --> 00:07:26,961
Вот.

98
00:07:26,961 --> 00:07:32,150
Внутри этого цикла я буду
читать статистику по памяти.

99
00:07:32,150 --> 00:07:36,830
Это та же самая статистика,
которая выдает expvar.

100
00:07:36,830 --> 00:07:40,600
Далее.

101
00:07:40,600 --> 00:07:45,450
У графита очень простой текстовый протокол
— туда можно написать значение метрики,

102
00:07:45,450 --> 00:07:50,210
имя метрики, значение метрики и timestamp,

103
00:07:50,210 --> 00:07:53,330
в который было проведено измерение.

104
00:07:53,330 --> 00:07:58,595
Поэтому я просто объявлю новый буфер и
запишу туда три значения: количество

105
00:07:58,595 --> 00:08:03,860
памяти в хипе, количество памяти
в стеке и количество горутин.

106
00:08:03,860 --> 00:08:11,768
Количество памяти я возьму из
MemStats — это специальная функция,

107
00:08:11,768 --> 00:08:17,094
которая может мне записать
используемую в данный момент память.

108
00:08:17,094 --> 00:08:22,757
А количество горутин я получу из
функции Num runtime пакета горутин.

109
00:08:22,757 --> 00:08:27,783
А далее я просто запишу эти
метрики уже в свое TCP-соединение.

110
00:08:27,783 --> 00:08:32,879
То есть обратите внимание: я не
использовал никаких библиотек,

111
00:08:32,879 --> 00:08:37,450
но уже отправляю статистику
во внешнюю систему.

112
00:08:37,450 --> 00:08:39,134
Давайте посмотрим.

113
00:08:39,134 --> 00:08:43,160
Вот интерфейс graphite,
он довольно аскетичен.

114
00:08:43,160 --> 00:08:50,295
Вот мои метрики слева: coursera,
goroutines_num, mem_heap, mem_stack.

115
00:08:50,295 --> 00:08:51,610
И вот сами значения.

116
00:08:51,610 --> 00:08:56,750
То есть вот когда был рост синего —
обратите внимание количество горутин,

117
00:08:56,750 --> 00:09:03,687
я подергал несколько раз запросы,
и у меня отправились значения в graphite.

118
00:09:03,687 --> 00:09:07,811
И память,
она тоже фактически ничего не занимает,

119
00:09:07,811 --> 00:09:12,620
вот она — 500 байт на стеке
и 1 Мб выделено в хипе.

120
00:09:12,620 --> 00:09:17,410
Вот таким нехитрым образом можно
организовать статистику в базовом

121
00:09:17,410 --> 00:09:18,085
варианте.

122
00:09:18,085 --> 00:09:22,476
Вы, конечно же, будете пользоваться
какими-то другими инструментами,

123
00:09:22,476 --> 00:09:27,012
может быть, другими библиотеками,
но вот просто запись

124
00:09:27,012 --> 00:09:31,780
в порт graphite, и уже оно работает.

125
00:09:31,780 --> 00:09:36,640
А далее мы рассмотрим систему
Prometheus: каким образом можно

126
00:09:36,640 --> 00:09:39,430
отправлять метрики при помощи нее.