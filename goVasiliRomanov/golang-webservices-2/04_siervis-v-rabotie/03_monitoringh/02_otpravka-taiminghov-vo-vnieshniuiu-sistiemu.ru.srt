1
00:00:00,000 --> 00:00:05,578
[БЕЗ_ЗВУКА] В

2
00:00:05,578 --> 00:00:10,990
этом видео мы поговорим про систему
мониторинга под названием Prometheus.

3
00:00:10,990 --> 00:00:15,830
Это довольно молодое решение,
оно было разработано в компании

4
00:00:15,830 --> 00:00:20,320
SoundCloud для задачи мониторинга
их огромного количества серверов.

5
00:00:20,320 --> 00:00:26,117
По сути, это целый фреймворк
для организации мониторинга и

6
00:00:26,117 --> 00:00:33,060
также многомерная база данных для хранения
множества метрик с разными свойствами.

7
00:00:33,060 --> 00:00:34,613
Давайте рассмотрим,

8
00:00:34,613 --> 00:00:39,690
как базово при помощи Prometheus
собирать статистику с вашего сервера.

9
00:00:39,690 --> 00:00:44,190
Итак, рассмотрим этот
очень небольшой пример.

10
00:00:44,190 --> 00:00:48,730
Здесь я подключаю библиотеку
для работы с Prometheus,

11
00:00:48,730 --> 00:00:53,940
после чего я регистрирую по url
metrics какой-то разработчик.

12
00:00:53,940 --> 00:00:54,948
Все.

13
00:00:54,948 --> 00:01:00,320
То есть по коду больше ничего не будет.

14
00:01:00,320 --> 00:01:03,220
Что делает этот обработчик?

15
00:01:03,220 --> 00:01:06,456
Обработчик нам регистрирует функцию,

16
00:01:06,456 --> 00:01:12,060
которая при обращении к нужному url
выводит вот такого рода статистику.

17
00:01:12,060 --> 00:01:20,480
Тут есть информация про время работы
коллектора, количество горутин,

18
00:01:20,480 --> 00:01:25,611
версию Go, с которым она была создана,
количество локаций и так далее.

19
00:01:25,611 --> 00:01:31,020
То есть фактически та же самая информация,
которую мы видели в expvar,

20
00:01:31,020 --> 00:01:35,690
с одним отличием.

21
00:01:35,690 --> 00:01:43,965
Дело в том,
что Prometheus работает по принципу...

22
00:01:43,965 --> 00:01:51,250
То есть он сам ходит по вашим
серверам и сам собирает статистику.

23
00:01:51,250 --> 00:01:57,383
Сервера можно указать у него в config,
по которым он будет ходить.

24
00:01:57,383 --> 00:02:01,062
Вот, например,
у меня объявлено job coursera,

25
00:02:01,062 --> 00:02:06,120
он будет ставить тег coursera ко
всем метрикам, которые собирает,

26
00:02:06,120 --> 00:02:10,370
и два сервера, с которых собирать метрики.

27
00:02:10,370 --> 00:02:15,122
После этого он регистрирует у

28
00:02:15,122 --> 00:02:19,720
себя эти сервера и выступает заодно
не только сборщиком статистики,

29
00:02:19,720 --> 00:02:27,118
но еще и своеобразной проверкой статуса
вашего сервера на то, что он жив.

30
00:02:27,118 --> 00:02:29,730
Вот тут есть даже маленький дашборд.

31
00:02:29,730 --> 00:02:33,420
После того как вы собрали
все ваши метрики,

32
00:02:33,420 --> 00:02:38,445
после того как Prometheus пришел
на ваш сервер, собрал метрики,

33
00:02:38,445 --> 00:02:42,258
они доступны будут в его
простеньком дашборде.

34
00:02:42,258 --> 00:02:43,470
Вот например.

35
00:02:43,470 --> 00:02:48,450
Вот график по количеству горутин.

36
00:02:48,450 --> 00:02:51,280
Prometheus, обратите внимание,

37
00:02:51,280 --> 00:02:55,965
собирает даже сам с себя метрики,
и вот две моих job,

38
00:02:55,965 --> 00:03:01,670
в которых я собираю количество горутин
уже с моих запущенных сервисов.

39
00:03:01,670 --> 00:03:05,950
Конечно, у самого Prometheus их побольше,
там больше работы внутри происходит,

40
00:03:05,950 --> 00:03:09,950
и в среднем у него 50 горутин активно.

41
00:03:09,950 --> 00:03:13,370
В моих серверах же семь-восемь.

42
00:03:13,370 --> 00:03:21,176
Интерфейс этот довольно простой и,
я бы сказал, даже аскетичный.

43
00:03:21,176 --> 00:03:24,600
Сам Prometheus даже не
рекомендует им пользоваться,

44
00:03:24,600 --> 00:03:28,505
а для организации нормальных дашбордов,
панелей с графиками,

45
00:03:28,505 --> 00:03:31,630
он рекомендует использовать
расширение Grafana.

46
00:03:31,630 --> 00:03:38,460
Grafana — это очень популярная система для
построения графиков, как я уже сказал.

47
00:03:38,460 --> 00:03:42,917
Как и Prometheus,
она тоже написана на Go и позволяет

48
00:03:42,917 --> 00:03:47,110
собирать вам информацию
с разных источников,

49
00:03:47,110 --> 00:03:52,330
с разных баз данных,
и выводить их в виде красивых графиков.

50
00:03:52,330 --> 00:03:56,250
Вот, например, панель,
которая показывает мне

51
00:03:56,250 --> 00:04:01,037
использование памяти по разным
серверам и количество горутин.

52
00:04:01,037 --> 00:04:03,831
Количество горутин — это тот график,

53
00:04:03,831 --> 00:04:09,360
который мы видели на предыдущей странице,
но вот он уже в более красивом виде.

54
00:04:09,360 --> 00:04:14,020
Prometheus позволяет вам,

55
00:04:14,020 --> 00:04:17,600
у него есть не только простая метрика,

56
00:04:17,600 --> 00:04:22,520
но у этой метрики есть
еще какой-то набор тегов.

57
00:04:22,520 --> 00:04:27,470
Например, вот количество локаций,
я сейчас уберу

58
00:04:27,470 --> 00:04:32,924
instance и уберу фильтрацию,
и вот полная информация.

59
00:04:32,924 --> 00:04:39,835
То есть instance localhost с портом

60
00:04:39,835 --> 00:04:44,781
и job, имя работы,
по которой собирается эта метрика.

61
00:04:44,781 --> 00:04:50,800
Например, если я укажу job="coursera",
то я не буду видеть метрик Prometheus тут.

62
00:04:50,800 --> 00:04:55,115
Если я тут укажу Prometheus,
буду видеть его.

63
00:04:55,115 --> 00:04:58,054
Либо я могу сделать фильтрацию,
например, по конкретному хосту,

64
00:04:58,054 --> 00:04:59,430
если мне нужны другие метрики.

65
00:04:59,430 --> 00:05:04,886
Окей, с метриками по
памяти мы разобрались,

66
00:05:04,886 --> 00:05:06,860
это вроде бы достаточно просто.

67
00:05:06,860 --> 00:05:11,010
А как собирать метрики по
работе самого моего приложения?

68
00:05:11,010 --> 00:05:16,530
Ведь сервер может работать, а приложение
— не отвечать, потому что оно зависло,

69
00:05:16,530 --> 00:05:20,800
либо же огромная деградация
в последнем обновлении.

70
00:05:20,800 --> 00:05:24,136
Рассмотрим следующий пример.

71
00:05:24,136 --> 00:05:28,935
В нем я буду регистрировать
количество вызовов

72
00:05:28,935 --> 00:05:33,314
моего API и время,
которое эти вызовы заняли.

73
00:05:33,314 --> 00:05:38,220
Для этого я объявлю две
переменных: timings и counter.

74
00:05:38,220 --> 00:05:43,390
Там я могу сразу указать метод, простите,

75
00:05:43,390 --> 00:05:48,470
имя этой переменной и какое-то
текстовое описание для нее.

76
00:05:48,470 --> 00:05:54,090
После этого я зарегистрирую
эти переменные в Prometheus,

77
00:05:54,090 --> 00:05:58,150
чтобы он их опрашивал,
когда будет выгружать статистику по url.

78
00:05:58,150 --> 00:06:01,176
Ну и далее уже идет моя бизнес-логика.

79
00:06:01,176 --> 00:06:04,380
Она представлена всего тремя строчками,

80
00:06:04,380 --> 00:06:08,974
в которых я просто сплю
случайное значение времени.

81
00:06:08,974 --> 00:06:09,516
Вот.

82
00:06:09,516 --> 00:06:14,010
И самим сбором статистики
занимается middleware,

83
00:06:14,010 --> 00:06:17,241
который я назвал timeTrackingMiddleware.

84
00:06:17,241 --> 00:06:22,410
В нем я засекаю время,
и после выполнения моей функции я уже,

85
00:06:22,410 --> 00:06:27,271
отправляя статистику,
вызываю определенный метод.

86
00:06:27,271 --> 00:06:30,064
Отправляю статистику, обратите внимание,

87
00:06:30,064 --> 00:06:33,032
для конкретного пути,
который ко мне пришел.

88
00:06:33,032 --> 00:06:38,320
Он приходит от пользователя, поэтому если
у вас нет строгих ограничений на него,

89
00:06:38,320 --> 00:06:40,457
то не надо так делать.

90
00:06:40,457 --> 00:06:43,720
И я регистрирую свое наблюдение,

91
00:06:43,720 --> 00:06:49,590
сколько времени оно у меня заняло,
и счетчик тоже просто инкрементирую.

92
00:06:49,590 --> 00:06:56,589
Давайте посмотрим, как это выглядит
в экспорте для самого Prometheus.

93
00:06:56,589 --> 00:07:01,369
Вот мой счетчик, method_counter,
и для него указан метод,

94
00:07:01,369 --> 00:07:07,506
то есть api/v1, favicon либо сами метрики,
которые дергает Prometheus.

95
00:07:07,506 --> 00:07:12,050
Там самое большое значение, потому
что Prometheus дергает их постоянно.

96
00:07:12,050 --> 00:07:13,750
Вот тайминги.

97
00:07:13,750 --> 00:07:19,365
Обратите внимание,
тут для каждого метода указаны квантили,

98
00:07:19,365 --> 00:07:22,670
то есть сколько в среднем заняло, сколько,

99
00:07:22,670 --> 00:07:27,719
в какое время уложились
90 % пользователей,

100
00:07:27,719 --> 00:07:32,336
99 % пользователей,
запросов, в моем случае,

101
00:07:32,336 --> 00:07:37,190
суммарно сколько времени я потратил
на этот метод и количество.

102
00:07:37,190 --> 00:07:40,860
То есть можно было обойтись
только одной этой метрикой.

103
00:07:40,860 --> 00:07:48,685
Далее я могу уже посмотреть в своем
дашборде, я настроил отдельный дашборд,

104
00:07:48,685 --> 00:07:53,604
вот у меня смотрится method_counter,
какое количество хитов было.

105
00:07:53,604 --> 00:07:57,602
Вот, например, статус,
он будет всего один раз.

106
00:07:57,602 --> 00:08:01,330
Если я сейчас сделаю еще
один запрос на статус,

107
00:08:01,330 --> 00:08:06,034
то там будет довольно быстро уже два.

108
00:08:06,034 --> 00:08:08,680
Оп, уже появилось.

109
00:08:08,680 --> 00:08:09,501
Вот.

110
00:08:09,501 --> 00:08:13,450
User, можно user дернуть.

111
00:08:13,450 --> 00:08:14,017
User.

112
00:08:14,017 --> 00:08:20,270
У меня обновляется раз в 15 секунд,
поэтому придется немножко подождать.

113
00:08:20,270 --> 00:08:21,394
Favicon и метрики.

114
00:08:21,394 --> 00:08:24,967
Метрики постоянно растут,
я не делал внутри никакого сброса,

115
00:08:24,967 --> 00:08:29,921
потому что Prometheus опрашивает мой
сервер постоянно за статистикой.

116
00:08:29,921 --> 00:08:33,827
User, вот появился user, отлично.

117
00:08:33,827 --> 00:08:35,420
Вот тайминги.

118
00:08:35,420 --> 00:08:36,448
Вот тайминги.

119
00:08:36,448 --> 00:08:40,330
Давайте залезем вглубь
таймингов чуть-чуть побольше.

120
00:08:40,330 --> 00:08:41,857
Редактировать.

121
00:08:41,857 --> 00:08:46,096
В данном случае я смотрю
только 99-ю квантиль.

122
00:08:46,096 --> 00:08:50,476
Если я уберу,
то тут появится довольно много информации,

123
00:08:50,476 --> 00:08:57,340
то есть сервер-то у меня один,
instance, job тоже одна, методов много.

124
00:08:57,340 --> 00:09:01,180
До этого график выглядел вот так,
я смотрел квантиль.

125
00:09:01,180 --> 00:09:07,670
Теперь же я хочу посмотреть
все квантили по методу.

126
00:09:07,670 --> 00:09:11,940
Допустим, favicon.

127
00:09:11,940 --> 00:09:12,625
Вот.

128
00:09:12,625 --> 00:09:18,800
Теперь мне вывелись все
квантили по методу favicon.

129
00:09:18,800 --> 00:09:23,922
Обратите внимание,
мы буквально за семьдесят

130
00:09:23,922 --> 00:09:29,770
строчек сделали уже довольно
неплохую систему мониторинга.

131
00:09:29,770 --> 00:09:34,456
Мы уже можем отслеживать количество
запросов, которое у нас было,

132
00:09:34,456 --> 00:09:39,380
и время, которое занял каждый запрос.

133
00:09:39,380 --> 00:09:43,560
Если мы выкатим обновление и увидим,
что какой-то из таймингов вырос,

134
00:09:43,560 --> 00:09:48,387
мы по крайней мере будем знать,
где искать эту информацию.

135
00:09:48,387 --> 00:09:53,294
Prometheus может стать довольно
хорошим решением для начала,

136
00:09:53,294 --> 00:09:56,130
а может быть, и не только для начала.