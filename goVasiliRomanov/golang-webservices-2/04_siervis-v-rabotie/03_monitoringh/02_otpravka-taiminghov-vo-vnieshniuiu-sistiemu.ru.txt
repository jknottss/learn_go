[БЕЗ_ЗВУКА] В этом видео мы поговорим про систему
мониторинга под названием Prometheus. Это довольно молодое решение,
оно было разработано в компании SoundCloud для задачи мониторинга
их огромного количества серверов. По сути, это целый фреймворк
для организации мониторинга и также многомерная база данных для хранения
множества метрик с разными свойствами. Давайте рассмотрим, как базово при помощи Prometheus
собирать статистику с вашего сервера. Итак, рассмотрим этот
очень небольшой пример. Здесь я подключаю библиотеку
для работы с Prometheus, после чего я регистрирую по url
metrics какой-то разработчик. Все. То есть по коду больше ничего не будет. Что делает этот обработчик? Обработчик нам регистрирует функцию, которая при обращении к нужному url
выводит вот такого рода статистику. Тут есть информация про время работы
коллектора, количество горутин, версию Go, с которым она была создана,
количество локаций и так далее. То есть фактически та же самая информация,
которую мы видели в expvar, с одним отличием. Дело в том,
что Prometheus работает по принципу... То есть он сам ходит по вашим
серверам и сам собирает статистику. Сервера можно указать у него в config,
по которым он будет ходить. Вот, например,
у меня объявлено job coursera, он будет ставить тег coursera ко
всем метрикам, которые собирает, и два сервера, с которых собирать метрики. После этого он регистрирует у себя эти сервера и выступает заодно
не только сборщиком статистики, но еще и своеобразной проверкой статуса
вашего сервера на то, что он жив. Вот тут есть даже маленький дашборд. После того как вы собрали
все ваши метрики, после того как Prometheus пришел
на ваш сервер, собрал метрики, они доступны будут в его
простеньком дашборде. Вот например. Вот график по количеству горутин. Prometheus, обратите внимание, собирает даже сам с себя метрики,
и вот две моих job, в которых я собираю количество горутин
уже с моих запущенных сервисов. Конечно, у самого Prometheus их побольше,
там больше работы внутри происходит, и в среднем у него 50 горутин активно. В моих серверах же семь-восемь. Интерфейс этот довольно простой и,
я бы сказал, даже аскетичный. Сам Prometheus даже не
рекомендует им пользоваться, а для организации нормальных дашбордов,
панелей с графиками, он рекомендует использовать
расширение Grafana. Grafana — это очень популярная система для
построения графиков, как я уже сказал. Как и Prometheus,
она тоже написана на Go и позволяет собирать вам информацию
с разных источников, с разных баз данных,
и выводить их в виде красивых графиков. Вот, например, панель,
которая показывает мне использование памяти по разным
серверам и количество горутин. Количество горутин — это тот график, который мы видели на предыдущей странице,
но вот он уже в более красивом виде. Prometheus позволяет вам, у него есть не только простая метрика, но у этой метрики есть
еще какой-то набор тегов. Например, вот количество локаций,
я сейчас уберу instance и уберу фильтрацию,
и вот полная информация. То есть instance localhost с портом и job, имя работы,
по которой собирается эта метрика. Например, если я укажу job="coursera",
то я не буду видеть метрик Prometheus тут. Если я тут укажу Prometheus,
буду видеть его. Либо я могу сделать фильтрацию,
например, по конкретному хосту, если мне нужны другие метрики. Окей, с метриками по
памяти мы разобрались, это вроде бы достаточно просто. А как собирать метрики по
работе самого моего приложения? Ведь сервер может работать, а приложение
— не отвечать, потому что оно зависло, либо же огромная деградация
в последнем обновлении. Рассмотрим следующий пример. В нем я буду регистрировать
количество вызовов моего API и время,
которое эти вызовы заняли. Для этого я объявлю две
переменных: timings и counter. Там я могу сразу указать метод, простите, имя этой переменной и какое-то
текстовое описание для нее. После этого я зарегистрирую
эти переменные в Prometheus, чтобы он их опрашивал,
когда будет выгружать статистику по url. Ну и далее уже идет моя бизнес-логика. Она представлена всего тремя строчками, в которых я просто сплю
случайное значение времени. Вот. И самим сбором статистики
занимается middleware, который я назвал timeTrackingMiddleware. В нем я засекаю время,
и после выполнения моей функции я уже, отправляя статистику,
вызываю определенный метод. Отправляю статистику, обратите внимание, для конкретного пути,
который ко мне пришел. Он приходит от пользователя, поэтому если
у вас нет строгих ограничений на него, то не надо так делать. И я регистрирую свое наблюдение, сколько времени оно у меня заняло,
и счетчик тоже просто инкрементирую. Давайте посмотрим, как это выглядит
в экспорте для самого Prometheus. Вот мой счетчик, method_counter,
и для него указан метод, то есть api/v1, favicon либо сами метрики,
которые дергает Prometheus. Там самое большое значение, потому
что Prometheus дергает их постоянно. Вот тайминги. Обратите внимание,
тут для каждого метода указаны квантили, то есть сколько в среднем заняло, сколько, в какое время уложились
90 % пользователей, 99 % пользователей,
запросов, в моем случае, суммарно сколько времени я потратил
на этот метод и количество. То есть можно было обойтись
только одной этой метрикой. Далее я могу уже посмотреть в своем
дашборде, я настроил отдельный дашборд, вот у меня смотрится method_counter,
какое количество хитов было. Вот, например, статус,
он будет всего один раз. Если я сейчас сделаю еще
один запрос на статус, то там будет довольно быстро уже два. Оп, уже появилось. Вот. User, можно user дернуть. User. У меня обновляется раз в 15 секунд,
поэтому придется немножко подождать. Favicon и метрики. Метрики постоянно растут,
я не делал внутри никакого сброса, потому что Prometheus опрашивает мой
сервер постоянно за статистикой. User, вот появился user, отлично. Вот тайминги. Вот тайминги. Давайте залезем вглубь
таймингов чуть-чуть побольше. Редактировать. В данном случае я смотрю
только 99-ю квантиль. Если я уберу,
то тут появится довольно много информации, то есть сервер-то у меня один,
instance, job тоже одна, методов много. До этого график выглядел вот так,
я смотрел квантиль. Теперь же я хочу посмотреть
все квантили по методу. Допустим, favicon. Вот. Теперь мне вывелись все
квантили по методу favicon. Обратите внимание,
мы буквально за семьдесят строчек сделали уже довольно
неплохую систему мониторинга. Мы уже можем отслеживать количество
запросов, которое у нас было, и время, которое занял каждый запрос. Если мы выкатим обновление и увидим,
что какой-то из таймингов вырос, мы по крайней мере будем знать,
где искать эту информацию. Prometheus может стать довольно
хорошим решением для начала, а может быть, и не только для начала.