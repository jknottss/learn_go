[БЕЗ_ЗВУКА] В этом видео мы затронем очень
важную тему для любого сервера, находящегося под нагрузкой,
а именно мониторинг. Если нет мониторинга, то непонятно вообще, жив наш сервер или он вообще не работает. Может быть, там постоянно идут ошибки,
либо после последнего обновления у нас очень сильная деградация
производительности. Для того чтобы мониторить сервер,
мы хотя бы хотим получать базовые метрики: сколько памяти
он занимает, какое количество горутин. Давайте рассмотрим, какие инструменты
есть в Go для этих целей. Начнем мы с пакета,
который называется expvar. Пакет expvar позволяет
вам зарегистрировать debug-обработчик в вашем
стандартном HTTP-хендлере. Видите, у меня здесь ничего нет, он в init-функции там будет
проинициализирован сам. После этого по специальному URL,
вот такому — debug/vars — нам будет доступна некоторая
статистика по вашему серверу. Например, по умолчанию там идут
параметры командной строки, из которой была запущена ваша программа,
и статистика по памяти. Основное, что у нас может тут
интересовать — это размер хипа — HeapInuse, то есть количество байт, которые наша программа аллоцировала
в динамической памяти. Как раз по хипу и работает
garbage collector. StackInuse — количество памяти,
которое находится на стеке, которое аллоцировано для стека. И разного рода информация
по garbage collector: какие у нас слабые есть, когда последний
раз был запуск сборщика мусора, сколько времени он занимал
и прочая информация. То есть уже этого достаточно,
чтобы сделать простой мониторинг — хотя бы дергать
сервер и смотреть, живой он или неживой. Однако иногда этого бывает мало, и мы хотим добавить туда
какую-то свою статистику, например статистику по количеству горутин,
либо по количеству обработанных запросов,
либо о просто прошедшем запросе. Давайте попробуем это сделать. Я объявлю новую мапу, специально для expvar, назову ее hits. И теперь при каждом хите я
буду добавлять туда Path, который мне пришел. И автоматически, когда я добавляю
через NewMap — вот оно у меня тоже называется hits, — автоматически она
добавляется в экспорт в нашу функцию. Здесь она находится вот в этом месте. Обратите внимание: тут есть
favicon и api/v1/user, то есть уже я могу количество уже экспортировать
просто буквально одной функцией. Единственный нюанс — что эта мапа
по умолчанию не сбрасывается. Также я могу зарегистрировать
какой-то свой обработчик, который будет вызываться
при каждом вызове expvar, и там будет уже отдаваться не статические
данные, а выполняться какая-то функция. Например, этой функцией вы можете
собрать тайминги по вашим запросам либо из глобального хранилища тайминга
просто здесь настроить экспорт. В данном случае я объявляю
переменную mystat, объявляю, что она будет вызывать функцию. И в этой функции я возвращаю сейчас
статичную мапу, то есть у меня есть несколько статичных значений и количество
активных горутин в данный момент. И вот моя статистика,
вот количество горутин, в данный момент 5,
и несколько статичных значений, то есть уже можно делать чуть более
сложный мониторинг, чем количество памяти. Стоит еще сказать, что подобным образом
можно сбрасывать сбрасывать мапу, мапу со значениями,
которую мы инкрементим. У нее есть функция Init, и мы можем,
вызвав ее в подобном обработчике, просто сбросить все. Давайте попробуем это запустить. Запускаем и смотрим. Так, сейчас китов у меня никаких нету. Теперь я сделаю несколько
запросов на пользователя. Вот у меня появилось: 4 запроса
на пользователя и фавиконка. Если я сейчас перезагружу,
у меня останется только фавиконка, потому что запросов на пользователя
уже нету, они у меня ушли, потому что мапа со значениями сбросилась. То есть вот буквально
в 30 строчек вы можете организовать простой
мониторинг вашего сервера. Однако дергать руками, если у вас, конечно, ваша система
мониторинга не построена на том, что вы сами опрашиваете сервер,
дергать руками такой URL неудобно. Гораздо чаще у нас бывает настроен
какой-то сервер статистики, куда все ваши серверы шлют метрики. Например, это может быть graphite. Давайте посмотрим,
каким образом можно слать данные в graphite вообще без
каких-либо внешних библиотек. Давайте рассмотрим этот код. У нас есть функция с простым обработчиком,
который просто пишет значение "Hello, world", есть адрес graphite — тут, кстати, надо flags flags.Parse добавить,
а то вы не сможете его переопределить. Вот, flag.Parse. Вот так. У нас есть наша функция-обработчик, и все
— она, на самом деле, ничего не делает. Основное, что нас в этом примере
интересует — это функция sendStat. Внутри этой функции — я ее запускаю в
отдельной горутине — я буду получать статистику по памяти и по
количеству использованных горутин. Для начала я соединюсь с graphite по TCP —
я хочу, чтобы мои данные доходили всегда. После этого я буду каждую
минуту слать туда данные. Я объявляю новый тикер,
и в цикле по нему итерируюсь. Напомню, что тикер возвращает мне канал, в котором значение появляется в
тот интервал, который я указал. В данном случае это минута. И там возвращается текущее время. Вот. Внутри этого цикла я буду
читать статистику по памяти. Это та же самая статистика,
которая выдает expvar. Далее. У графита очень простой текстовый протокол
— туда можно написать значение метрики, имя метрики, значение метрики и timestamp, в который было проведено измерение. Поэтому я просто объявлю новый буфер и
запишу туда три значения: количество памяти в хипе, количество памяти
в стеке и количество горутин. Количество памяти я возьму из
MemStats — это специальная функция, которая может мне записать
используемую в данный момент память. А количество горутин я получу из
функции Num runtime пакета горутин. А далее я просто запишу эти
метрики уже в свое TCP-соединение. То есть обратите внимание: я не
использовал никаких библиотек, но уже отправляю статистику
во внешнюю систему. Давайте посмотрим. Вот интерфейс graphite,
он довольно аскетичен. Вот мои метрики слева: coursera,
goroutines_num, mem_heap, mem_stack. И вот сами значения. То есть вот когда был рост синего —
обратите внимание количество горутин, я подергал несколько раз запросы,
и у меня отправились значения в graphite. И память,
она тоже фактически ничего не занимает, вот она — 500 байт на стеке
и 1 Мб выделено в хипе. Вот таким нехитрым образом можно
организовать статистику в базовом варианте. Вы, конечно же, будете пользоваться
какими-то другими инструментами, может быть, другими библиотеками,
но вот просто запись в порт graphite, и уже оно работает. А далее мы рассмотрим систему
Prometheus: каким образом можно отправлять метрики при помощи нее.