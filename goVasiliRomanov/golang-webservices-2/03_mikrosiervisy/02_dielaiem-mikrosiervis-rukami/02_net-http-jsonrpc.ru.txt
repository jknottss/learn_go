[БЕЗ_ЗВУКА] В предыдущем
видео мы рассмотрели, каким образом можно сделать базовый
микросервис, используя пакет net/rpc. Однако он использует формат gobs,
что является, скорее, недостатком, потому что искать его для другого языка
программирования то еще удовольствие. И плюс придется на бинарный формат накручивать какую-то
авторизацию и еще какой-то сервис. Это не всегда удобно. Есть достаточно популярный формат jsonrpc, который описывает удаленный
вызов процедур в json формате. Например, вот так это выглядит. Указываем, какая версия jsonrpc,
номер запроса, метод, который мы хотим вызвать, и параметры,
которые мы туда передаем. Хотелось бы, чтобы наша программа, наш микросервис, умела парсить такое и
отвечать опять-таки в jsonrpc формате. В Go есть специальные коды для этого,
Codec для net/rpc, которые позволяют
организовать это действо. Давайте рассмотрим пример. Я не стал делать обслуживание
чисто на основе net/rpc, а воспользовался стандартным пакетом
не http, чтобы можно было еще какие-то другие запросы туда
подмешать или добавить больше логики. Вызывать мы это будем в
данном примере через curl без клиента,
потому что мы хотим проверить, что мы можем отсылать json из
других клиентов, которые не Go. А в данном случае это вообще
будет командная строка. Сначала посмотрим создание сервера. Мы по-прежнему создаем наш sessionManager. Теперь мы получаем сервер из пакета rpc. В прошлом примере мы
пользовались стандартным. Регистрируем нашу структуру там,
чтобы вызывать ее методы, а теперь, если вы помните, у структуры может быть метод ServeHTTP, который будет обрабатывать запросы. Этим мы и воспользуемся. Создадим структуру,
куда передадим наш сервер в качестве поля, и теперь начнем обрабатывать запросы,
которые приходят на url rpc. Вот теперь на этом url
будет лучше наша структура. Что происходит дальше? Вот наша структура,
вот наш метод ServeHTTP, мы можем обращаться уже к хедерам,
которые приходят в http запросы. В данном случае я проверяю хедер X-Auth,
для того чтобы авторизоваться на этом сервисе, потому что вы же наверняка
не захотите выставлять ваш менеджер сессии в открытый мир и
вообще без авторизации. Хорошо. То есть как минимум я могу получить
доступ к чему угодно и запросу. Далее я воспользуюсь небольшим хелпером, который реализует мне нужный интерфейс, для того чтобы передать
его в Codec для json rpc. Отлично. При помощи этого Codec я распакую запрос и потом
запакую его обратно. Далее я запишу, что хедер,
что я верну его в json. Действительно, я его верну. Но дальше я паршусь к своему rpc сервису,
скажу, обслужи, пожалуйста, запрос. А дальше передам туда Codec,
и уже сервер оттуда вычитает все, что нужно,
при помощи jsonrpc, а Codec распакует, запакует и запишет результат опять-таки
туда, куда мы ему вот тут говорим. Вроде все просто. Тут обработка ошибок. Что если что-то пошло не так,
то мы это напечатаем в лог либо мы выведем клиенту какую-то ошибку опять-таки
в формате json, чтобы он не сходил с ума. И в случае успеха мы запишем Header(200). Теперь надо запускать. Для начала я создам пользователя,
создам сессию пользователя. Обратите внимание. У меня просто curl запрос,
и я его шлю постом. Говорю, что в посте json у меня, ставлю
хедер X-Auth, который вот тут я проверяю. И в json непосредственно идут все данные,
которые я хочу. И шлю на адрес rpc. Все. Копируем, вставляем. И все успешно прошло. Смотрите, вот результат
вызова моей функции. Он уже сериализовался в json сразу,
и id вот пожалуйста. Поскольку я не устанавливаю соль
генератор случайных чисел, на основе которых генерируется id сессии, он у меня
будет при каждом запуске постоянный. Поэтому я его даже не буду копировать,
он у меня уже тут есть. И теперь я его попробую запустить еще раз. И теперь я в первом запросе я создал
сессию, во втором я ее получаю, и вот отлично. Вот мой запрос, он вернулся. Id 2, результат,
логин и юзер-агент chrome. И нет ошибок. Уже хорошо. Теперь давайте попробуем ошибочный случай. Не можем распарсить json,
например, удалим тут что-нибудь. Пятисотка, не смогли обслужить,
и наш json, собранный руками для случая ошибки. Вот это уже получше. Сюда можно уже все-таки
добавить чуть больше логики и что-то на основе этого уже сделать. jsonrpc очень удобный формат. Очень удобно гонять его,
например, по веб-сокетам. В целом, можно пользоваться. Далее мы рассмотрим целый
фреймворк для организации rpc сервисов и микросервисов,
которые называются grpc.