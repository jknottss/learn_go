[БЕЗ_ЗВУКА] В предыдущем видео мы
немножко порефакторили наш код так, что у нас получился модуль
для работы с сессиями. В этом видео мы рассмотрим, каким образом
можно вынести его в отдельный микросервис. Очень часто микросервисы основаны на
подходе RPC — Remote Procedure Call. По-русски это значит
«удалённый вызов процедур». Этот подход отличается тем,
что код оформляется так, что вы вызываете какую-то удалённую процедуру
так, словно она какая-то локальная. То есть есть какая-то обёртка
над вызовом удалённого метода. То есть если вы просто дёргаете какую-то
апишку и потом руками всё там парсите каждый раз, это близко, но не совсем то. RPC — это просто дёргает методы. В данном примере мы рассмотрим
модуль стандартной библиотеки, который называется net/rpc. Он достаточно беден по
функционалу; пожалуй, я не буду рекомендовать вам
его использовать в продакшене. Однако для учебных целей
в начале он нам подойдёт. Рассмотрим этот код. Мы получаем менеджер сессии,
как в прошлый раз. Теперь в модуле RPC мы регистрируем
нашу структуру для управления сессиями. Говорим модулю, что давай,
начинай обрабатывать http, слушаем порт и всё. В общем-то, вот почти готов микросервис, то есть сейчас его можно
запустить и обращаться. Всё было бы очень замечательно, но net/rpc требует небольших правок в организации методов; я расскажу, каких. Если раньше (вот, например,
метод Create), собственно, наша основная структура и
получение экземпляра структуры, они остались как раньше,
там по-прежнему Mutex сессии, всё. Итак, модуль Create. Если вы помните,
раньше мы возвращали по-другому; раньше у нас был один параметр, и мы возвращали несколько
результатов исходящих. Вот так это примерно выглядело. Сейчас нам пришлось изменить наши методы, потому что модуль net/rpc требует,
чтобы у нас было ровно два параметра. Первый параметр — с входящими
аргументами функции, а второй — это адрес,
куда запишется результат. Поэтому всё-таки немножко
есть отличия в методах. Но идеологически более-менее всё осталось. Итак, Create. То есть я по-прежнему получаю и потом
записываю туда, куда у нас было. То же самое с Check: тоже потом
записываю результат в эту переменную. И для out'а я тоже сделал заглушку,
чтобы тоже записывать результат. Всё.
То есть у нас, в общем-то, микросервис наш готов буквально
минимальными абсолютно правками. Теперь каким-то образом нужно его вызвать. Посмотрим модуль сессии,
который остался в клиентской части. У нас по-прежнему есть
интерфейс SessionManager'а, у которого указывают нужные
нам методы: он не менялся. Однако сама структура теперь
уже претерпела изменения. Раньше там было уже хранилище сессии,
а теперь — ссылка на rpc.Client. В функции получения менеджера мы соединяемся с удалённым сервером, и уже клиента возвращаем;
то есть клиент поменялся. Соответственно, поменялись функции, через которые мы обращаемся
к удалённым процедурам. Теперь это выглядит вот так; раньше
в этом месте мы шли в мапку и чего-то там проверяли, теперь нам нужно
сначала создать переменную, в которую запишется результат, если он будет;
и потом вызвать удалённую процедуру. То есть SessionManager —
это как раз та структура. Я вам покажу SessionManager. Вот SessionManager,
который я зарегистрировал в обработчике, и метод Create,
который вызовется на той стороне. Туда я передаю входящие параметры и
указываю, куда записать результат. То же самое для проверки и для удаления. Вот. То есть нам пришлось внести небольшие
изменения в сигнатуры наших методов, чтобы они поддерживались
библиотекой net/rpc, и пришлось сделать реализацию для вызова удалённых
процедур в клиентской части библиотеки. При этом сам клиентский код для работы
с сессиями, он абсолютно не поменялся. Так. Для начала мы запустим сервер. [БЕЗ_ЗВУКА] Теперь мы запустим клиент и видим, что, в общем-то,
результат особо не изменился. [БЕЗ_ЗВУКА] Net/rpc работает на основе формата Go; это
встроенный формат сериализации языка Go. Он не очень популярен; я не буду
останавливаться на том, как он работает. Далее я рассмотрю вариацию модуля net/rpc, которая называется JSON-RPC и
оперирует уже форматом json.