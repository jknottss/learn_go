1
00:00:00,000 --> 00:00:08,527
[БЕЗ_ЗВУКА] В предыдущем
видео мы рассмотрели,

2
00:00:08,527 --> 00:00:12,990
каким образом можно сделать базовый
микросервис, используя пакет net/rpc.

3
00:00:12,990 --> 00:00:18,970
Однако он использует формат gobs,
что является, скорее, недостатком,

4
00:00:18,970 --> 00:00:23,070
потому что искать его для другого языка
программирования то еще удовольствие.

5
00:00:23,070 --> 00:00:27,902
И плюс придется на бинарный

6
00:00:27,902 --> 00:00:31,979
формат накручивать какую-то
авторизацию и еще какой-то сервис.

7
00:00:31,979 --> 00:00:33,320
Это не всегда удобно.

8
00:00:33,320 --> 00:00:36,720
Есть достаточно популярный формат jsonrpc,

9
00:00:36,720 --> 00:00:41,183
который описывает удаленный
вызов процедур в json формате.

10
00:00:41,183 --> 00:00:43,950
Например, вот так это выглядит.

11
00:00:43,950 --> 00:00:49,050
Указываем, какая версия jsonrpc,
номер запроса, метод,

12
00:00:49,050 --> 00:00:54,030
который мы хотим вызвать, и параметры,
которые мы туда передаем.

13
00:00:54,030 --> 00:00:59,171
Хотелось бы, чтобы наша программа,

14
00:00:59,171 --> 00:01:05,200
наш микросервис, умела парсить такое и
отвечать опять-таки в jsonrpc формате.

15
00:01:05,200 --> 00:01:11,940
В Go есть специальные коды для этого,
Codec для net/rpc,

16
00:01:11,940 --> 00:01:16,897
которые позволяют
организовать это действо.

17
00:01:16,897 --> 00:01:19,787
Давайте рассмотрим пример.

18
00:01:19,787 --> 00:01:23,626
Я не стал делать обслуживание
чисто на основе net/rpc,

19
00:01:23,626 --> 00:01:28,221
а воспользовался стандартным пакетом
не http, чтобы можно было еще

20
00:01:28,221 --> 00:01:33,240
какие-то другие запросы туда
подмешать или добавить больше логики.

21
00:01:33,240 --> 00:01:38,160
Вызывать мы это будем в
данном примере через curl

22
00:01:38,160 --> 00:01:42,923
без клиента,
потому что мы хотим проверить,

23
00:01:42,923 --> 00:01:48,500
что мы можем отсылать json из
других клиентов, которые не Go.

24
00:01:48,500 --> 00:01:52,128
А в данном случае это вообще
будет командная строка.

25
00:01:52,128 --> 00:01:54,875
Сначала посмотрим создание сервера.

26
00:01:54,875 --> 00:01:58,686
Мы по-прежнему создаем наш sessionManager.

27
00:01:58,686 --> 00:02:02,615
Теперь мы получаем сервер из пакета rpc.

28
00:02:02,615 --> 00:02:06,734
В прошлом примере мы
пользовались стандартным.

29
00:02:06,734 --> 00:02:11,410
Регистрируем нашу структуру там,
чтобы вызывать ее методы,

30
00:02:11,410 --> 00:02:14,930
а теперь, если вы помните,

31
00:02:14,930 --> 00:02:19,800
у структуры может быть метод ServeHTTP,

32
00:02:19,800 --> 00:02:24,255
который будет обрабатывать запросы.

33
00:02:24,255 --> 00:02:25,808
Этим мы и воспользуемся.

34
00:02:25,808 --> 00:02:34,192
Создадим структуру,
куда передадим наш сервер в качестве поля,

35
00:02:34,192 --> 00:02:38,750
и теперь начнем обрабатывать запросы,
которые приходят на url rpc.

36
00:02:38,750 --> 00:02:42,695
Вот теперь на этом url
будет лучше наша структура.

37
00:02:42,695 --> 00:02:44,630
Что происходит дальше?

38
00:02:44,630 --> 00:02:49,980
Вот наша структура,
вот наш метод ServeHTTP,

39
00:02:49,980 --> 00:02:54,299
мы можем обращаться уже к хедерам,
которые приходят в http запросы.

40
00:02:54,299 --> 00:02:59,207
В данном случае я проверяю хедер X-Auth,
для того чтобы авторизоваться на этом

41
00:02:59,207 --> 00:03:03,648
сервисе, потому что вы же наверняка
не захотите выставлять ваш менеджер

42
00:03:03,648 --> 00:03:08,300
сессии в открытый мир и
вообще без авторизации.

43
00:03:08,300 --> 00:03:09,025
Хорошо.

44
00:03:09,025 --> 00:03:14,110
То есть как минимум я могу получить
доступ к чему угодно и запросу.

45
00:03:14,110 --> 00:03:18,590
Далее я воспользуюсь небольшим хелпером,

46
00:03:18,590 --> 00:03:23,562
который реализует мне нужный интерфейс,

47
00:03:23,562 --> 00:03:26,800
для того чтобы передать
его в Codec для json rpc.

48
00:03:26,800 --> 00:03:28,548
Отлично.

49
00:03:28,548 --> 00:03:32,431
При помощи этого Codec я

50
00:03:32,431 --> 00:03:37,796
распакую запрос и потом
запакую его обратно.

51
00:03:37,796 --> 00:03:41,746
Далее я запишу, что хедер,
что я верну его в json.

52
00:03:41,746 --> 00:03:43,610
Действительно, я его верну.

53
00:03:43,610 --> 00:03:48,020
Но дальше я паршусь к своему rpc сервису,
скажу, обслужи, пожалуйста, запрос.

54
00:03:48,020 --> 00:03:53,290
А дальше передам туда Codec,
и уже сервер оттуда

55
00:03:53,290 --> 00:03:58,109
вычитает все, что нужно,
при помощи jsonrpc, а Codec распакует,

56
00:03:58,109 --> 00:04:03,421
запакует и запишет результат опять-таки
туда, куда мы ему вот тут говорим.

57
00:04:03,421 --> 00:04:05,060
Вроде все просто.

58
00:04:05,060 --> 00:04:09,315
Тут обработка ошибок.

59
00:04:09,315 --> 00:04:16,085
Что если что-то пошло не так,
то мы это напечатаем в лог либо мы

60
00:04:16,085 --> 00:04:23,216
выведем клиенту какую-то ошибку опять-таки
в формате json, чтобы он не сходил с ума.

61
00:04:23,216 --> 00:04:25,650
И в случае успеха мы запишем Header(200).

62
00:04:25,650 --> 00:04:28,717
Теперь надо запускать.

63
00:04:28,717 --> 00:04:32,954
Для начала я создам пользователя,
создам сессию пользователя.

64
00:04:32,954 --> 00:04:34,040
Обратите внимание.

65
00:04:34,040 --> 00:04:36,822
У меня просто curl запрос,
и я его шлю постом.

66
00:04:36,822 --> 00:04:43,170
Говорю, что в посте json у меня, ставлю
хедер X-Auth, который вот тут я проверяю.

67
00:04:43,170 --> 00:04:47,900
И в json непосредственно идут все данные,
которые я хочу.

68
00:04:47,900 --> 00:04:50,464
И шлю на адрес rpc.

69
00:04:50,464 --> 00:04:51,270
Все.

70
00:04:51,270 --> 00:04:55,180
Копируем, вставляем.

71
00:04:55,180 --> 00:04:58,580
И все успешно прошло.

72
00:04:58,580 --> 00:05:02,700
Смотрите, вот результат
вызова моей функции.

73
00:05:02,700 --> 00:05:09,592
Он уже сериализовался в json сразу,
и id вот пожалуйста.

74
00:05:09,592 --> 00:05:15,361
Поскольку я не устанавливаю соль
генератор случайных чисел, на основе

75
00:05:15,361 --> 00:05:20,214
которых генерируется id сессии, он у меня
будет при каждом запуске постоянный.

76
00:05:20,214 --> 00:05:23,739
Поэтому я его даже не буду копировать,
он у меня уже тут есть.

77
00:05:23,739 --> 00:05:26,240
И теперь я его попробую запустить еще раз.

78
00:05:26,240 --> 00:05:30,700
И теперь я в первом запросе я создал
сессию, во втором я ее получаю,

79
00:05:30,700 --> 00:05:32,161
и вот отлично.

80
00:05:32,161 --> 00:05:35,090
Вот мой запрос, он вернулся.

81
00:05:35,090 --> 00:05:38,870
Id 2, результат,
логин и юзер-агент chrome.

82
00:05:38,870 --> 00:05:39,794
И нет ошибок.

83
00:05:39,794 --> 00:05:40,641
Уже хорошо.

84
00:05:40,641 --> 00:05:43,647
Теперь давайте попробуем ошибочный случай.

85
00:05:43,647 --> 00:05:48,987
Не можем распарсить json,
например, удалим тут что-нибудь.

86
00:05:48,987 --> 00:05:53,849
Пятисотка, не смогли обслужить,
и наш json,

87
00:05:53,849 --> 00:05:57,160
собранный руками для случая ошибки.

88
00:05:57,160 --> 00:05:58,769
Вот это уже получше.

89
00:05:58,769 --> 00:06:02,961
Сюда можно уже все-таки
добавить чуть больше логики и

90
00:06:02,961 --> 00:06:08,120
что-то на основе этого уже сделать.

91
00:06:08,120 --> 00:06:09,983
jsonrpc очень удобный формат.

92
00:06:09,983 --> 00:06:13,300
Очень удобно гонять его,
например, по веб-сокетам.

93
00:06:13,300 --> 00:06:17,140
В целом, можно пользоваться.

94
00:06:17,140 --> 00:06:22,410
Далее мы рассмотрим целый
фреймворк для организации rpc

95
00:06:22,410 --> 00:06:28,350
сервисов и микросервисов,
которые называются grpc.