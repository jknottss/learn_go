1
00:00:00,000 --> 00:00:09,073
[НЕТ_ЗВУКА] В этой лекции мы
поговорим про микросервисы.

2
00:00:09,073 --> 00:00:13,678
Микросервисы это популярный
в последнее время паттерн

3
00:00:13,678 --> 00:00:19,020
организации программы для
упрощения и борьбы со сложностью.

4
00:00:19,020 --> 00:00:22,043
Потому что программ становится все больше,
больше и больше,

5
00:00:22,043 --> 00:00:24,850
сложность их растет,
и как-то в этом надо разбираться.

6
00:00:24,850 --> 00:00:28,491
Но для начала давайте вообще разберемся,
что такое монолит,

7
00:00:28,491 --> 00:00:30,700
и чем он отличается от микросервиса.

8
00:00:30,700 --> 00:00:34,261
Допустим, у вас есть программа — одна!

9
00:00:34,261 --> 00:00:39,277
— которая ходит во все
базы данных и делает все,

10
00:00:39,277 --> 00:00:45,148
то есть у вас есть кластер серверов,
на который катится только одна программа.

11
00:00:45,148 --> 00:00:47,560
Все.
Это называется монолит.

12
00:00:47,560 --> 00:00:50,460
Монолит, потому что он один — и все!

13
00:00:50,460 --> 00:00:55,110
А в нем, как правило,
намешано довольно много.

14
00:00:55,110 --> 00:01:00,320
В нем много разных частей, много кусков.

15
00:01:00,320 --> 00:01:01,952
Если же...

16
00:01:01,952 --> 00:01:02,496
да!

17
00:01:02,496 --> 00:01:04,400
и делает он все.

18
00:01:04,400 --> 00:01:12,014
Если же эта программа не большая, и
делает она ограниченное количество вещей,

19
00:01:12,014 --> 00:01:17,460
но все-таки более-менее разных,
это можно назвать просто сервис.

20
00:01:17,460 --> 00:01:23,480
А микросервис — это очень
маленькая программа,

21
00:01:23,480 --> 00:01:28,380
то есть в пределах, ну конечно,
в зависимости от языка,

22
00:01:28,380 --> 00:01:33,340
от нескольких сотен до нескольких тысяч
строк, и делает она только одну вещь.

23
00:01:33,340 --> 00:01:36,043
То есть принцип единой ответственности.

24
00:01:36,043 --> 00:01:38,300
Это такой идеальный микросервис.

25
00:01:38,300 --> 00:01:41,510
Для того чтобы понять,

26
00:01:41,510 --> 00:01:47,242
почему вообще стоит разбивать,
нужно разобрать проблемы монолита.

27
00:01:47,242 --> 00:01:50,260
Первая проблема монолита — это сложность.

28
00:01:50,260 --> 00:01:55,710
Когда ваша кодовая база переваливает
за несколько миллионов строк,

29
00:01:55,710 --> 00:02:00,492
разобраться там бывает довольно тяжело,

30
00:02:00,492 --> 00:02:03,920
и когда приходишь так, смотришь — ого!

31
00:02:03,920 --> 00:02:06,047
— и бросает в дрожь.

32
00:02:06,047 --> 00:02:11,008
Потому что оно между собой
вот так вот перекручено,

33
00:02:11,008 --> 00:02:14,480
интегрировано, связано — это тяжело.

34
00:02:14,480 --> 00:02:18,346
Если вам нужно подправить в одном месте,
довольно часто бывает,

35
00:02:18,346 --> 00:02:21,670
что в монолите может стрельнуть
где-то в другом месте,

36
00:02:21,670 --> 00:02:24,890
которое вроде бы никак
не должно затрагиваться.

37
00:02:24,890 --> 00:02:30,250
Но и опять-таки вам приходится
выкатывать это все вместе,

38
00:02:30,250 --> 00:02:35,246
и чем больше у вас изменений,
тем больше вероятность,

39
00:02:35,246 --> 00:02:40,354
что вам придется откатить какие-то другие
ваши изменения из-за того, что где-то

40
00:02:40,354 --> 00:02:46,502
что-то в одном месте сломалось, но оно
критичное для работы вашего сервиса.

41
00:02:46,502 --> 00:02:49,427
Еще одной проблемой монолита является то,

42
00:02:49,427 --> 00:02:52,270
что все-таки рано или поздно
появляется другой сервис.

43
00:02:52,270 --> 00:02:56,930
Например, старый был написан на php,
новый вы пишете на Go.

44
00:02:56,930 --> 00:03:01,880
И вам надо дублировать код,
вам надо дублировать вашу бизнес-логику,

45
00:03:01,880 --> 00:03:07,321
хотя хорошо бы этого не делать.

46
00:03:07,321 --> 00:03:12,185
Либо же еще худший случай — вам
нужно копипэйстить один и тот

47
00:03:12,185 --> 00:03:13,661
же код в разные места.

48
00:03:13,661 --> 00:03:16,848
Если вдруг вам нужно
где-то что-то поменять,

49
00:03:16,848 --> 00:03:20,970
вам нужно будет обновлять везде все.

50
00:03:20,970 --> 00:03:25,638
Поэтому стараются разделять,

51
00:03:25,638 --> 00:03:29,110
то есть следовать принципу
«разделяй и властвуй»,

52
00:03:29,110 --> 00:03:33,066
для того чтобы разделить
монолит на несколько сервисов.

53
00:03:33,066 --> 00:03:35,010
Как обычно это происходит?

54
00:03:35,010 --> 00:03:38,917
Вначале у нас есть
какая-то просто гора кода,

55
00:03:38,917 --> 00:03:45,688
которую мы периодически копаем лопатой,
для того чтобы что-то получилось.

56
00:03:45,688 --> 00:03:49,502
И если мы хотим оттуда
выделить микросервис,

57
00:03:49,502 --> 00:03:53,626
для начала мы должны как-то
организовать нашу программу.

58
00:03:53,626 --> 00:03:57,480
В случае, если у нас правильная
архитектура, это хорошо.

59
00:03:57,480 --> 00:04:02,595
У нас и так уже все изолировано,
и общих пересечений совсем нету.

60
00:04:02,595 --> 00:04:05,461
Итак, мы изолируем наш отдельный сервис.

61
00:04:05,461 --> 00:04:10,430
То есть у нас, по сути, монолит,
но такой, микросервисный, монолит,

62
00:04:10,430 --> 00:04:15,230
то есть когда есть несколько отдельных,
изолированных кусков кода,

63
00:04:15,230 --> 00:04:18,850
которые выступают как отдельные сервисы.

64
00:04:18,850 --> 00:04:21,835
Но просто внутри вот одной общей кучи.

65
00:04:21,835 --> 00:04:25,870
Соответственно, когда мы
выделили такой микросервис,

66
00:04:25,870 --> 00:04:29,260
такой сервис внутри вашего монолита,

67
00:04:29,260 --> 00:04:33,450
мы можем просто выделить
его в отдельную программу.

68
00:04:33,450 --> 00:04:38,176
В монолите же, ну или в том, что осталось
от этого монолита, потому что он,

69
00:04:38,176 --> 00:04:41,030
конечно же, должен уменьшиться в размерах,

70
00:04:41,030 --> 00:04:46,180
мы можем оставить только интерфейс
похода в наш микросервис.

71
00:04:46,180 --> 00:04:51,504
В идеале это будет выглядеть

72
00:04:51,504 --> 00:04:56,676
примерно вот так: у нас есть некоторое
количество умеренно больших сервисов,

73
00:04:56,676 --> 00:05:00,540
где сосредоточена наша
основная бизнес-логика.

74
00:05:00,540 --> 00:05:06,165
Есть такое же небольшое
количество микросервисов,

75
00:05:06,165 --> 00:05:11,226
которые следуют принципу единой
ответственности и делают одну

76
00:05:11,226 --> 00:05:16,510
небольшую вещь,
но для всех клиентов к этому микросервису.

77
00:05:16,510 --> 00:05:21,171
Однако тут надо не переусердствовать и не

78
00:05:21,171 --> 00:05:26,106
получить кучу-малу уже не
внутри одной программы,

79
00:05:26,106 --> 00:05:29,560
а разнесенную на несколько программ.

80
00:05:29,560 --> 00:05:36,444
Это будет довольно печально
и жизнь вам не упростит.

81
00:05:36,444 --> 00:05:40,933
То есть микросервисы не
нужно ставить во главу угла,

82
00:05:40,933 --> 00:05:45,362
не надо начинать разработку
программы с микросервисов оттого,

83
00:05:45,362 --> 00:05:48,330
что вы будете их создавать 20-30 штук.

84
00:05:48,330 --> 00:05:52,000
Потому что почему...

85
00:05:52,000 --> 00:05:53,925
микросервис — это не всегда хорошо.

86
00:05:53,925 --> 00:05:58,552
Ну, во-первых, у микросервисов есть
накладные расходы на коммуникацию.

87
00:05:58,552 --> 00:06:05,580
Когда у вас ваш, давайте будем оставлять
это — монолит, микросервис и база данных.

88
00:06:05,580 --> 00:06:09,480
Раньше монолит ходил сразу в базу,
и все было хорошо.

89
00:06:09,480 --> 00:06:12,909
А потом монолит начал
ходить в микросервис,

90
00:06:12,909 --> 00:06:17,198
то есть у вас получилось
один шаг накладных расходов.

91
00:06:17,198 --> 00:06:20,532
В случае, если у вас нестабильная сеть,

92
00:06:20,532 --> 00:06:24,770
либо запросов много — это
может стать проблемой.

93
00:06:24,770 --> 00:06:29,347
Также, если раньше вы
катили одну программу,

94
00:06:29,347 --> 00:06:34,820
один бинарник, или набор кода, то теперь
вам придется катить много программ.

95
00:06:34,820 --> 00:06:40,900
То есть ваша сложность может перекочевать
просто из одного места в другое.

96
00:06:40,900 --> 00:06:44,230
Вы не решите так своих проблем.

97
00:06:44,230 --> 00:06:49,351
Ну и надо, наконец, понимать,
что микросервис — это не панацея.

98
00:06:49,351 --> 00:06:51,840
Они не решат всех ваших проблем.

99
00:06:51,840 --> 00:06:56,016
Если ваши проблемы не в том,

100
00:06:56,016 --> 00:07:00,230
что у вас монолит,

101
00:07:00,230 --> 00:07:04,823
где что-то много стреляет,
где бывают ошибки из-за того,

102
00:07:04,823 --> 00:07:09,628
что стрельнуло в одном месте,
а какие-то организационные проблемы,

103
00:07:09,628 --> 00:07:14,490
либо проблема именно с написанием кода:
там много ошибок, нет тестирования,

104
00:07:14,490 --> 00:07:18,967
то микросервисы, не факт,
что решат эти проблемы.

105
00:07:18,967 --> 00:07:21,860
Поэтому об этом не надо забывать.

106
00:07:21,860 --> 00:07:26,838
Далее мы рассмотрим,
каким образом уже в коде

107
00:07:26,838 --> 00:07:32,795
можно выделить сервис и
как-то заизолировать его,

108
00:07:32,795 --> 00:07:35,730
а потом вынести в отдельный микросервис.

109
00:07:35,730 --> 00:07:37,829
Мы рассморим всю цепочку и рассмотрим,

110
00:07:37,829 --> 00:07:40,370
какие инструменты Go
предоставляет для этого.

111
00:07:40,370 --> 00:07:44,581
Рассмотрим встроенный пакет для RPC —

112
00:07:44,581 --> 00:07:49,570
вызов удаленных процедур,
для JSON RPC, и рассмотрим большую

113
00:07:49,570 --> 00:07:53,900
библиотеку для организации
микросервисов под названием gRPC.