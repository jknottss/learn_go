[БЕЗ_ЗВУКА] В прошлых видео я продемонстрировал
возможность выноса какого-то кода в микросервисы, используя стандартную
библиотеку и пакеты net/rpc и json/rpc. Однако эти пакеты довольно бедные,
там очень мало фич; например, там сложности с авторизацией,
балансингом и прочим. В этом видео мы поговорим
про фреймворк GRPC, который значительно богаче на возможности, чем предыдущие варианты,
и основан он на формате protobuf и описании сервисов,
используя также этот формат. Сначала давайте посмотрим на сервис. Так. У нас уже есть знакомый вам protobuf-файл, где описаны структуры SessionID и session. Однако добавляется ещё описание сервиса. Message описывает структуру,
сервис описывает уже GRPC-шный сервис. Называется он у нас AuthChecker. И я описываю несколько
методов в нём: Create, Check и Delete; для Delete'а
я сделал заглушку в качестве возвращаемого ответа, потому
что GRPC не может не возвращать ответ. И сделано это для того, чтобы когда
вы будете расширять ваш сервис, у вас не возникло трудностей с тем,
чтобы добавлять туда что-то. Итак, для генерации уже кода самого сервиса нам
необходимо указать плагины, что мы хотим не только
сгенерировать сам protobuf-файл, но и сгенерировать GRPC-обвязку
для сервисов, которые там есть. Хорошо. После запуска что у нас получается? Получается у нас вот
такой вот здоровый файл. Править его,
опять-таки ещё раз повторюсь, не надо, потому что при следующей
генерации он перезапишется. Там есть наши структуры,
которые вы в целом уже видели, а теперь там добавляются
уже следующие сервисы. Есть интерфейс для клиента,
то есть который вы будете вызывать и
создавать со стороны клиента, есть реализация этого сервиса. То есть вот интерфейс, а вот реализация. Реализация внутренняя,
она то есть в данном случае не публичная, за пределы пакета не выходит;
получается она вот из этой функции. Я покажу, как это использовать. Ну и вот есть вызов. Вызов уже сам генерирует, точнее, этот код уже сгенерирован для
того, чтобы вызвать на той стороне нужную нам функцию в нужном пакете. То есть grpc.Invoke, Delete. И есть сервер. То есть GRPC-генератор сервиса
сразу генерирует вам интерфейс, в котором жёстко заданы входящие
параметры и исходящие параметры. И вам нужно будет только
реализовать структуру, методы которой удовлетворяют
этому интерфейсу. Ну и тут регистрация и всё прочее;
в общем, много служебных функций. Ну и сам protobuf. Хорошо. Теперь давайте посмотрим на реализацию. Реализация мало отличается от того, что мы видели в самом первом варианте: у нас
есть Mutex, хранилище сессии в виде мапки. NewSessionManager возвращает нам указатель на эту структуру. Методы. Отличие от самого-самого первого
варианта в методах в том, что мы теперь принимаем
первым аргументом context. В нём могут быть какие-то дополнительные
параметры переданные; либо можно получить какую-то информацию о запросе,
например, вход, с которого он пришёл. В целом в остальном практически не
отличается от первоначального варианта. Получаем id'шник. И мы его кладём в мапку. В Check'е пытаемся проверить
из мапки; если нет, в данном случае мы просто вернём
ошибку со статусом «Не найдено». Удаление тоже. Теперь как это вызывать,
как создать сервер. Итак, сервер. Я создаю Listener на 8081 порту. Создаю новый сервер GRPC-шный, регистрирую там мой сервис и — в общем, и всё. Вот этот вот session — это пакет, для которого сгенерировался мой код. RegisterAuthCheckerServer —
это тоже сгенерированный код, давайте я его даже найду, который регистрирует в сервисе экземпляр моей структуры,
который удовлетворяет нужному интерфейсу. Я туда передаю сервер,
создаю мою структуру и всё. И поехали. То есть в базовом варианте
это выглядит вот так. И буквально всего ничего. Как теперь это вызывать? Вот файл, который уже будет
вызывать методы моего микросервиса. Для начала нам к нему нужно
подключиться; я указываю адрес и указываю grpc-опцию WithInsecure. Это значит, что у меня там
никакого шифрования, ничего нет, голые бинарные данные по TCP гоняем. Ну если там у меня функция выходит,
я её закрываю. Теперь я создаю клиента к
своему сервису; опять-таки я пользуюсь сгенерированным кодом,
в котором уже есть методы все, нужные мне,
которые идут в правильное место. То есть я туда просто
передаю соединение и всё. У меня готов уже connect и
готов клиент к моему менеджеру сессии на той стороне,
который крутится внутри микросервиса. Теперь это нужно вызвать. Как я уже говорил, у нас добавился context; в данном случае
я просто беру context Background, однако я могу взять, например, context с
Timeout'ом в данном случае или передать туда какие-то дополнительные опции,
это мы будем рассматривать отдельно. Итак. Вызываем Create. Опять-таки это очень близко к тому, что вы видели первоначально; единственное,
что добавилось — context. Хорошо, мы создали сессию, проверили сессию: опять всё
то же самое плюс context. Единственное, что я обращаюсь, конечно,
уже не к структуре в данном пакете, а к структуре в другом пакете,
то есть добавится префикс к session. Удаление и проверка. Попробуем теперь это запустить. [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] Запустили сервер. И запустили клиент. Отлично. Создалась моя сессия, причём поскольку
protobuf тоже генерит много чего, он сразу генерит красивый вывод для неё. Ошибки нет. Я теперь проверил сессию; login и
username, всё хорошо, ошибки тоже нет. После удаления я пытаюсь
ещё раз проверить сессию. Уже сессии нет, и мне вернулась ошибка,
что с кодом не найдено. И описание то же: session not found. Вот это GRPC. Мы используем его в продакшене. Мы довольны и производительностью,
и набором возможностей, которые мы рассмотрим дальше.