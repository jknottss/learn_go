1
00:00:00,000 --> 00:00:07,099
[БЕЗ_ЗВУКА] В этом видео мы

2
00:00:07,099 --> 00:00:12,310
продолжим рассматривать те возможности,
которые нам предоставляет grpc.

3
00:00:12,310 --> 00:00:17,630
Как мы видели ранее,
мы можем просто дернуть удаленную функцию,

4
00:00:17,630 --> 00:00:19,711
удаленный метод, и все.

5
00:00:19,711 --> 00:00:24,030
Однако там не было ни
проверок авторизации, ничего.

6
00:00:24,030 --> 00:00:29,760
Это хотелось бы иметь,
это в общем-то надо,

7
00:00:29,760 --> 00:00:35,000
но и еще хочется логировать это,
делать access log, timing и все такое.

8
00:00:35,000 --> 00:00:40,840
Что мы можем с этим делать,
что нам grpc может предложить?

9
00:00:40,840 --> 00:00:45,010
Для этого у grpc есть

10
00:00:45,010 --> 00:00:52,560
возможность делать UnaryInterceptor.

11
00:00:52,560 --> 00:00:56,891
UnaryInterceptor — это
перехватчик одиночных запросов,

12
00:00:56,891 --> 00:01:01,324
по сути это как раз таки MiddleWare,
который будет выполняться,

13
00:01:01,324 --> 00:01:05,090
перед тем как запрос уйдет
на удаленный сервер.

14
00:01:05,090 --> 00:01:12,040
Также в grpc есть возможность
передачи метадаты,

15
00:01:12,040 --> 00:01:18,470
метаданных, как с запросом на сервер,
так и со стороны сервера.

16
00:01:18,470 --> 00:01:23,130
То есть это какие-то данные,
которые приходят помимо самого запроса,

17
00:01:23,130 --> 00:01:28,670
помимо самого результата
удаленной функции.

18
00:01:28,670 --> 00:01:30,029
Зачем это нужно?

19
00:01:30,029 --> 00:01:33,834
В частности, например,
чтобы передать токен,

20
00:01:33,834 --> 00:01:38,702
то есть какие-то общесистемные вещи,
которые относятся не непосредственно к

21
00:01:38,702 --> 00:01:44,080
бизнес-логике самого удаленного сервиса,
а скорее к движку.

22
00:01:44,080 --> 00:01:49,800
В этом видео я как раз покажу,
как это делать.

23
00:01:49,800 --> 00:01:53,033
Для начала UnaryInterceptor.

24
00:01:53,033 --> 00:02:00,370
При подключении к grpc я говорю,
что можно указать n-е количество опций.

25
00:02:00,370 --> 00:02:05,780
Я указываю UnaryInterceptor и в
скобках указываю свою функцию.

26
00:02:05,780 --> 00:02:07,333
Как она работает?

27
00:02:07,333 --> 00:02:14,003
Вот код этой функции, сюда передается
куча всяких параметров: контекст,

28
00:02:14,003 --> 00:02:18,742
метод, запрос, ответ и все такое, коннект,

29
00:02:18,742 --> 00:02:23,730
invoker — это как раз та функцию, которую
мне нужно вызвать, и много всякого.

30
00:02:23,730 --> 00:02:25,410
То есть что я тут делаю?

31
00:02:25,410 --> 00:02:27,930
Я просто обернул это все в тайминг.

32
00:02:27,930 --> 00:02:33,690
Я засек время начала, после этого я
вывел всю сопутствующую информацию,

33
00:02:33,690 --> 00:02:36,126
которая там есть, и все.

34
00:02:36,126 --> 00:02:38,541
И вернул ошибку.

35
00:02:38,541 --> 00:02:42,048
То есть у нас удаленный
метод может вернуть ошибку.

36
00:02:42,048 --> 00:02:43,860
Посмотрим, как это работает.

37
00:02:43,860 --> 00:02:49,300
Ага.

38
00:02:49,300 --> 00:02:50,580
Хорошо.

39
00:02:50,580 --> 00:02:52,820
Вот мой запрос.

40
00:02:52,820 --> 00:02:57,089
Я вызвал метод session.AuthChecker/Create,

41
00:02:57,089 --> 00:03:00,850
и я туда передал запрос,
потом мне вернулся результат.

42
00:03:00,850 --> 00:03:07,417
Результат записывается в ту переменную
по адресу, время, и ошибки не было.

43
00:03:07,417 --> 00:03:11,870
Время много, потому что первое
соединение слов и коннектов, все такое.

44
00:03:11,870 --> 00:03:16,387
У последующей функции вызовов
ничего нет фактически по времени.

45
00:03:16,387 --> 00:03:18,723
Очень быстро, локальный хост.

46
00:03:18,723 --> 00:03:23,345
То есть интерсептор вроде бы
очень простой на стороне клиента.

47
00:03:23,345 --> 00:03:25,217
Туда приходят все параметры,

48
00:03:25,217 --> 00:03:29,250
и мы потом должны вызвать какую-то
функцию с этими параметрами.

49
00:03:29,250 --> 00:03:34,540
Это очень похоже на то,
что мы рассматривали в MiddleWare.

50
00:03:34,540 --> 00:03:38,880
Теперь метаданные.

51
00:03:38,880 --> 00:03:44,335
Метаданные можно передавать
несколькими способами.

52
00:03:44,335 --> 00:03:49,570
Первый способ передать общие
метаданные ко всем запросам

53
00:03:49,570 --> 00:03:54,340
— это установить PerRPCCredentials.

54
00:03:54,340 --> 00:04:01,670
PerRPCCredentials принимает в себя
интерфейс, который можно реализовать.

55
00:04:01,670 --> 00:04:05,964
В данном случае у меня есть тип
авторизация по токену — то есть я создаю

56
00:04:05,964 --> 00:04:08,110
структуру, не использую токен.

57
00:04:08,110 --> 00:04:13,419
Когда эта штука будет вызываться,
будет запрашиваться GetRequestMetadata,

58
00:04:13,419 --> 00:04:16,140
я возвращаю там map,
где как раз указываю токен.

59
00:04:16,140 --> 00:04:21,384
И еще один метод, который запрашивает

60
00:04:21,384 --> 00:04:27,817
информацию: нужна ли для этого
способа авторизация с шифрованием.

61
00:04:27,817 --> 00:04:33,320
Должно ли она работать по TLS/SSL.

62
00:04:33,320 --> 00:04:35,010
Я говорю, что нет.

63
00:04:35,010 --> 00:04:38,988
То есть этот метод будет
вызываться перед тем,

64
00:04:38,988 --> 00:04:42,735
как я пошлю запрос, и те данные,
которые у меня есть,

65
00:04:42,735 --> 00:04:47,690
в данном случае access-token, будут
каждый раз добавляться к каждому запросу.

66
00:04:47,690 --> 00:04:51,840
То есть чтобы даже не делать интерсептор,
а указать.

67
00:04:51,840 --> 00:04:56,395
То есть для каждого запроса понятно: если
у нас есть какая-то система, у которой я

68
00:04:56,395 --> 00:05:01,786
хочу указать токен или какие-то еще
данные, я могу сделать это таким образом.

69
00:05:01,786 --> 00:05:05,332
А если я хочу указывать
запросы для каждого вызова?

70
00:05:05,332 --> 00:05:07,587
Например, у меня есть request ID,

71
00:05:07,587 --> 00:05:13,540
по которому я хочу отследить вызов моих
процедур, где оно пошло и что было не так.

72
00:05:13,540 --> 00:05:21,340
Для этого тоже есть способ:
метаданные передаются через контекст.

73
00:05:21,340 --> 00:05:26,070
Вот метадата, и это пакет от grpc.

74
00:05:26,070 --> 00:05:29,600
Я сначала создаю контекст,
потом создаю метаданные.

75
00:05:29,600 --> 00:05:34,529
В данном случае pairs просто
принимает четное число строк: первая

76
00:05:34,529 --> 00:05:36,947
строка — это ключ, вторая — значение.

77
00:05:36,947 --> 00:05:39,650
Но там есть и способ
преобразовать это из map.

78
00:05:39,650 --> 00:05:44,577
Потом я создаю контекст,
NewOutgoingContext, уже с этими

79
00:05:44,577 --> 00:05:49,846
метаданными, то есть метаданные
туда присваиваются через WithValue.

80
00:05:49,846 --> 00:05:52,800
И я вызываю свою функцию
с этим контекстом.

81
00:05:52,800 --> 00:05:57,130
То есть метаданные я могу
добавить к любому своему вызову,

82
00:05:57,130 --> 00:05:59,946
тоже довольно просто.

83
00:05:59,946 --> 00:06:04,500
Как получить метаданные,
которые мне вернулись со стороны запроса?

84
00:06:04,500 --> 00:06:10,085
Я создам две переменные header,
trailer: header — это то,

85
00:06:10,085 --> 00:06:13,913
что придет в начале запроса,
trailer — то, что придет в конце запроса.

86
00:06:13,913 --> 00:06:15,790
Там можно даже вот так ограничить.

87
00:06:15,790 --> 00:06:21,655
Теперь раньше у меня был вызов вот такой:
то есть я туда передавал только аргумент

88
00:06:21,655 --> 00:06:28,942
функции, однако вызовы grpc принимают еще
дополнительные опции, и вот эти опции.

89
00:06:28,942 --> 00:06:33,400
То есть я указал, что я хочу получать
header вот в эту переменную,

90
00:06:33,400 --> 00:06:36,579
и trailer — вот в эту переменную.

91
00:06:36,579 --> 00:06:41,384
Ранее я печатал sessionID,
и тут я напечатаю еще header и trailer.

92
00:06:41,384 --> 00:06:42,620
Как это выглядит?

93
00:06:42,620 --> 00:06:44,132
А вот так это выглядит.

94
00:06:44,132 --> 00:06:47,256
Вот sessionID, который мне вернулся, то,

95
00:06:47,256 --> 00:06:52,703
что я печатал в предыдущем примере,
и вот header и trailer,

96
00:06:52,703 --> 00:06:56,280
то есть какая-то map с ключами,
в которых есть какое-то значение.

97
00:06:56,280 --> 00:07:02,340
Опять-таки не используйте

98
00:07:02,340 --> 00:07:09,240
header и trailer как параллели API для
передачи параметров в удаленной функции.

99
00:07:09,240 --> 00:07:12,840
Туда должны передаваться только
какие-то общесистемные вещи,

100
00:07:12,840 --> 00:07:17,790
типа requestID или токена авторизации.

101
00:07:17,790 --> 00:07:21,534
На стороне клиента вроде бы все несложно.

102
00:07:21,534 --> 00:07:25,180
Передали пару опций, указали функцию,

103
00:07:25,180 --> 00:07:29,633
указали, в какую переменную
записать результат.

104
00:07:29,633 --> 00:07:31,460
Можно разобраться.

105
00:07:31,460 --> 00:07:34,908
Теперь, каким образом
это выглядит на сервере?

106
00:07:34,908 --> 00:07:36,304
Давайте смотреть.

107
00:07:36,304 --> 00:07:37,460
Вот наш сервер.

108
00:07:37,460 --> 00:07:42,791
Значит, у сервера тоже

109
00:07:42,791 --> 00:07:48,570
есть UnaryInterceptor,
то есть перехватчик одиночных запросов.

110
00:07:48,570 --> 00:07:52,750
Он тоже принимает функцию,

111
00:07:52,750 --> 00:07:56,264
что он внутри этой функции делает?

112
00:07:56,264 --> 00:07:58,958
Да фактически то же самое.

113
00:07:58,958 --> 00:08:03,169
Очень похоже на перехватчик в клиенте.

114
00:08:03,169 --> 00:08:10,293
Я тут тоже вывожу всякое,
вызываю handler, вот

115
00:08:10,293 --> 00:08:15,634
так даже будет лучше, то есть ту функцию,
которая проделает реальную работу.

116
00:08:15,634 --> 00:08:17,790
Я могу уже обернуть ее так, как мне надо.

117
00:08:17,790 --> 00:08:22,464
В данном случае я получаю метаданные
из запроса и вывожу их вместе со

118
00:08:22,464 --> 00:08:23,700
всем остальным.

119
00:08:23,700 --> 00:08:27,806
Вот в этом месте, например,
можно вкрутить уже авторизацию по токену.

120
00:08:27,806 --> 00:08:31,685
То есть я могу проверять в метаданных,
есть ли там access-token,

121
00:08:31,685 --> 00:08:36,610
правильный ли он, и разрешен ли для
этого access-token вызов данного метода.

122
00:08:36,610 --> 00:08:41,530
Смотрим, как это выглядит.

123
00:08:41,530 --> 00:08:47,695
Вот, например, Check.

124
00:08:47,695 --> 00:08:51,117
Сначала вызвался check ratelimit
— это следующий пункт,

125
00:08:51,117 --> 00:08:52,828
про который я буду говорить.

126
00:08:52,828 --> 00:08:57,670
Вот вызвался call — это то,
что я пишу руками.

127
00:08:57,670 --> 00:09:03,085
А вот вызвался мой уже интерсептор.

128
00:09:03,085 --> 00:09:08,500
Вот функция, которая у меня выводится, вот
то, что у меня пришло, вот то, что ушло.

129
00:09:08,500 --> 00:09:11,070
Время опять-таки нисколько.

130
00:09:11,070 --> 00:09:14,938
И метаданные: то есть с
какого сервера пришел запрос,

131
00:09:14,938 --> 00:09:19,530
с какого юзер-агента он пришел,
access-token, request ID и subsystem.

132
00:09:19,530 --> 00:09:23,560
На основе этого уже можно делать
какие-то проверки, что-то считать,

133
00:09:23,560 --> 00:09:25,060
что-то оттуда получать.

134
00:09:25,060 --> 00:09:30,870
То есть все более-менее просто.

135
00:09:30,870 --> 00:09:34,450
Теперь, каким образом добавить
метаданные к ответам?

136
00:09:34,450 --> 00:09:37,580
Рассмотрим session.

137
00:09:37,580 --> 00:09:39,560
Тут все тоже просто.

138
00:09:39,560 --> 00:09:44,167
Создаем метаданные,
структуру с метаданными,

139
00:09:44,167 --> 00:09:50,140
и используя функцию SendHeader из grpc,
я указываю уже сами эти метаданные.

140
00:09:50,140 --> 00:09:55,570
С trailer аналогично: я просто указываю
те значения, которые я хочу отправить.

141
00:09:55,570 --> 00:10:00,409
То есть оно в таком виде
никак не документировано,

142
00:10:00,409 --> 00:10:03,014
это все будет чисто runtime проверятся.

143
00:10:03,014 --> 00:10:06,897
Это параллельно API тому,
что проверяется через compare time.

144
00:10:06,897 --> 00:10:09,966
Используйте, пожалуйста,
это с осторожностью,

145
00:10:09,966 --> 00:10:15,590
ни в коем случае не как параллельно
API для вашей бизнес-логики.

146
00:10:15,590 --> 00:10:18,743
И есть еще одна функция,
про которую я расскажу.

147
00:10:18,743 --> 00:10:19,950
Это InTapHandle.

148
00:10:19,950 --> 00:10:25,115
InTapHandle — это функция,
которая выполняется при

149
00:10:25,115 --> 00:10:31,066
приходе запроса,
любого запроса на соединение.

150
00:10:31,066 --> 00:10:36,223
В случае, если у нас UnaryInterceptor
я уже все распаковал,

151
00:10:36,223 --> 00:10:40,882
у меня уже есть метаданные, у меня уже
есть параметры запроса, у меня есть метод,

152
00:10:40,882 --> 00:10:45,828
куда я хочу это отправить, то InTapHandle,
tapper, в данном случае у меня

153
00:10:45,828 --> 00:10:51,021
эта функция rateLimiter называется, хотя
реальной проверки rateLimiter там нет,

154
00:10:51,021 --> 00:10:53,735
она вызывается,
как только пришло само соединение.

155
00:10:53,735 --> 00:10:56,630
То есть там еще ничего не распаршено,
там еще нет ничего.

156
00:10:56,630 --> 00:11:02,676
В этом месте она не выполняется
в отдельной горутине,

157
00:11:02,676 --> 00:11:05,010
в отличие от того же UnaryInterceptor.

158
00:11:05,010 --> 00:11:10,110
Она нужна, для того чтобы вы
могли проверить rateLimiter

159
00:11:10,110 --> 00:11:14,646
или посчитать какую-то жесткую статистику
до того, как все начнет паршится.

160
00:11:14,646 --> 00:11:17,990
Потому что если у нас сервер
перезагружается, нам не нужно

161
00:11:17,990 --> 00:11:22,510
парсить дополнительные данные, чтобы потом
выяснить, что мы не справляемся в работой.

162
00:11:22,510 --> 00:11:27,030
Мы должны в самом-самом начале соединения,

163
00:11:27,030 --> 00:11:30,255
на самом-самом приходе
запроса это определить.

164
00:11:30,255 --> 00:11:33,921
Определить это мы можем по методу,
ну и если что,

165
00:11:33,921 --> 00:11:37,850
мы можем докопаться до
метаданных и прочего.

166
00:11:37,850 --> 00:11:43,073
Но тут не стоит сажать
какие-то блокирующие операции,

167
00:11:43,073 --> 00:11:48,550
потому что этот перехватчик,
этот TapHandle выполняется

168
00:11:48,550 --> 00:11:53,685
в одном потоке на соединении.

169
00:11:53,685 --> 00:11:58,357
Это те средства,
которые предоставляет вам grpc для того,

170
00:11:58,357 --> 00:12:02,740
чтобы вставить какие-то перехватчики
и передать какие-то значения.

171
00:12:02,740 --> 00:12:08,519
Оно используется в реальной работе,
оно удобно, это, конечно, не все,

172
00:12:08,519 --> 00:12:14,680
что предоставляет grpc,
но это одно из самых основных.