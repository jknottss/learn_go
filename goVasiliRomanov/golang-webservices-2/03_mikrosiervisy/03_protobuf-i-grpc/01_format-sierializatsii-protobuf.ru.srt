1
00:00:00,000 --> 00:00:05,764
[БЕЗ_ЗВУКА] Прежде

2
00:00:05,764 --> 00:00:10,540
чем двигаться дальше,
стоит поговорить о форматах сериализации.

3
00:00:10,540 --> 00:00:14,960
В предыдущих видео мы видели
активное использование json.

4
00:00:14,960 --> 00:00:20,600
Также в примере с NET RPC я упоминал,
что он использует формат gob.

5
00:00:20,600 --> 00:00:26,570
В чем разница и почему один формат
выгоднее или невыгоднее другого?

6
00:00:26,570 --> 00:00:30,230
Сначала давайте рассмотрим json.

7
00:00:30,230 --> 00:00:36,710
Вот код, который сериализует уже
знакомую вам структуру Session.

8
00:00:36,710 --> 00:00:42,490
В json эта структура занимает 40 байт,

9
00:00:42,490 --> 00:00:47,419
хотя данных там вдвое меньше.

10
00:00:47,419 --> 00:00:53,200
Дело в том, что json — это формат
без схемы, схему он сериализует

11
00:00:53,200 --> 00:00:58,240
прямо туда в виде имен полей.

12
00:00:58,240 --> 00:01:03,040
Соответственно, вам нужно каждый
раз сначала распаковать поле,

13
00:01:03,040 --> 00:01:05,867
после этого распаковать тип данных.

14
00:01:05,867 --> 00:01:11,264
Причем вам нужно проверять каждый символ,
действительно каждый символ,

15
00:01:11,264 --> 00:01:15,910
а не является ли он кавычкой,
например, которая закрывает строку.

16
00:01:15,910 --> 00:01:20,460
Или вдруг там перенос строки,
который тоже нужно экранировать?

17
00:01:20,460 --> 00:01:28,900
То есть формат json распаковать несколько
накладнее, чем бинарный формат.

18
00:01:28,900 --> 00:01:32,856
Он больше по размеру,

19
00:01:32,856 --> 00:01:36,777
однако его плюсом является то,
что он человекочитаем.

20
00:01:36,777 --> 00:01:40,716
То есть вы можете открыть логи либо
какой-то текстовый файл и посмотреть

21
00:01:40,716 --> 00:01:42,060
глазами, что там есть.

22
00:01:42,060 --> 00:01:47,070
Бинарный формат, как следует из названия,
упакован гораздо плотнее,

23
00:01:47,070 --> 00:01:52,080
он представлен не в текстовом виде, а в
виде бинарных данных прямо, вот как есть.

24
00:01:52,080 --> 00:02:01,028
За счет этого он гораздо легче в
распаковке и может быть легче в упаковке.

25
00:02:01,028 --> 00:02:05,977
Формат gob мы рассматривать не будем,
потому что он специфичен для языка Go и

26
00:02:05,977 --> 00:02:08,900
не очень широко распространен
за его пределами.

27
00:02:08,900 --> 00:02:11,666
Мы будем рассматривать формат protobuf,

28
00:02:11,666 --> 00:02:15,900
protobuf — это формат,
который разработан в компании Google.

29
00:02:15,900 --> 00:02:21,590
Сейчас он достаточно широко распространен,

30
00:02:21,590 --> 00:02:26,100
и я вам покажу,
как он выглядит в бинарном виде.

31
00:02:26,100 --> 00:02:30,610
Упаковка в этот формат,
распаковка очень похожи на json:

32
00:02:30,610 --> 00:02:35,754
json.Marshal и proto.Marshal,
соответственно Marshal.

33
00:02:35,754 --> 00:02:40,034
Теперь, сколько занимает эта
же структура в protobuf.

34
00:02:40,034 --> 00:02:43,574
Эта же структура в
protobuf занимает 17 байт,

35
00:02:43,574 --> 00:02:47,820
что более,
чем в два раза меньше, чем json.

36
00:02:47,820 --> 00:02:49,682
За счет чего?

37
00:02:49,682 --> 00:02:56,220
Во-первых, protobuf — это формат
с жестко заданной схемой.

38
00:02:56,220 --> 00:03:01,667
То есть в json может быть любое
количество полей, и, например,

39
00:03:01,667 --> 00:03:06,780
в распаковке структур вы
просто возьмете себе нужные.

40
00:03:06,780 --> 00:03:09,362
С protobuf так не совсем получится,

41
00:03:09,362 --> 00:03:13,811
вам нужна схема, вам нужен
какой-то декодировщик этих полей.

42
00:03:13,811 --> 00:03:17,290
Но сначала посмотрим,
что лежит в этих 17 байтах.

43
00:03:17,290 --> 00:03:22,498
Сначала у нас идет байт 10,
в нем запакован

44
00:03:22,498 --> 00:03:28,977
номер поля и его тип.

45
00:03:28,977 --> 00:03:34,948
После этого — это у нас строковый тип
— идет длина данных и сами данные.

46
00:03:34,948 --> 00:03:40,115
Потом идет следующее поле,
там идет тоже номер поля,

47
00:03:40,115 --> 00:03:45,092
вместе с типом, которые упакованы
в один байт, и опять-таки

48
00:03:45,092 --> 00:03:50,204
длина данных 6 байт,
вот эти 6 байт: 3 и 3, 6.

49
00:03:50,204 --> 00:03:54,124
То есть для того чтобы,
например, распаковать строку,

50
00:03:54,124 --> 00:03:58,468
вам не нужно проходиться по каждому
символу, вы просто копируете 6 байт и все,

51
00:03:58,468 --> 00:04:03,136
вы знаете, что там уже все хорошо,
что там нет никаких проблем

52
00:04:03,136 --> 00:04:06,810
с экранированием или с
внезапным концом строки.

53
00:04:06,810 --> 00:04:09,525
Теперь я покажу,

54
00:04:09,525 --> 00:04:15,230
каким образом используется этот формат,
каким образом задается схема.

55
00:04:15,230 --> 00:04:22,030
Формат protobuf описывается при
помощи промежуточного языка EDL,

56
00:04:22,030 --> 00:04:26,590
который описывает схему этого формата.

57
00:04:26,590 --> 00:04:29,213
В данном случае у нас есть message,

58
00:04:29,213 --> 00:04:34,408
message в Go переводится в
структуру SessionID и Session.

59
00:04:34,408 --> 00:04:39,672
Я задаю тип данных,
имя этого поля и номер.

60
00:04:39,672 --> 00:04:44,217
Обратите внимание, поля пакуются

61
00:04:44,217 --> 00:04:49,069
в виде номеров, не в виде имени поля,

62
00:04:49,069 --> 00:04:54,118
как, например, в json, а в виде номера.

63
00:04:54,118 --> 00:04:57,900
За счет этого получается очень компактно.

64
00:04:57,900 --> 00:05:02,600
Вы можете потом какие-то поля пропустить,
например, добавить,

65
00:05:02,600 --> 00:05:08,429
сделать вот так: ip = 3.

66
00:05:08,429 --> 00:05:14,731
То есть формат расширяем, если каких-то
полей в нем не будет, они будут null.

67
00:05:14,731 --> 00:05:20,800
После этого вам нужно запустить
внешний генератор кода,

68
00:05:20,800 --> 00:05:24,899
который сгенерирует вам в
случае с Go все структуры и

69
00:05:24,899 --> 00:05:28,074
необходимый код для их десериализации.

70
00:05:28,074 --> 00:05:32,643
Это запускается, всё,
структура сгенерировалась.

71
00:05:32,643 --> 00:05:34,980
И получаем вот такой файл.

72
00:05:34,980 --> 00:05:39,300
Тут довольно много служебного кода,
руками его трогать вам никогда не надо,

73
00:05:39,300 --> 00:05:41,860
потому что в следующий
раз он перезапишется.

74
00:05:41,860 --> 00:05:46,370
И вот, например,
структура SessionID: поле ID, строк,

75
00:05:46,370 --> 00:05:52,540
ввод помощь для protobuf, структурные
теги, то есть это для внутри bytes.

76
00:05:52,540 --> 00:05:56,820
за номером ID, оно опционально,

77
00:05:56,820 --> 00:06:01,160
наследие из второй версией protobuf,
и имя.

78
00:06:01,160 --> 00:06:03,721
Еще и для json сразу там
все сгенерировалось.

79
00:06:03,721 --> 00:06:08,564
И еще вспомогательные методы: сброс,
привести к строке,

80
00:06:08,564 --> 00:06:12,573
получить сообщение,

81
00:06:12,573 --> 00:06:19,900
описание схемы в нем есть,
ну и getter'ы для каждого из полей.

82
00:06:19,900 --> 00:06:22,906
Теперь смотрим дальше.

83
00:06:22,906 --> 00:06:25,770
Вот наше поле Session.

84
00:06:25,770 --> 00:06:28,509
В нем тоже сгенерировалось два поля.

85
00:06:28,509 --> 00:06:32,710
Ну и тут еще есть немножко,
и в том числе схема там же есть.

86
00:06:32,710 --> 00:06:39,792
Вроде кажется не очень удобно,
каждый раз генерировать схему,

87
00:06:39,792 --> 00:06:45,082
однако по этой схеме вы
можете сгенерировать

88
00:06:45,082 --> 00:06:49,446
код для других языков, не только для Go,

89
00:06:49,446 --> 00:06:54,947
но и для «плюсов», для php,
для json, для java, для python.

90
00:06:54,947 --> 00:06:58,860
То есть,
есть кодогенерация практически подо всё.

91
00:06:58,860 --> 00:07:03,515
Это очень удобный формат,
когда у вас очень много сообщений и вы

92
00:07:03,515 --> 00:07:07,720
хотите сэкономить хотя бы на их
сериализации, десериализации.

93
00:07:07,720 --> 00:07:12,720
Формат protobuf используется в gRPC

94
00:07:12,720 --> 00:07:17,090
как основной формат передачи данных,

95
00:07:17,090 --> 00:07:21,160
который мы будем рассматривать дальше.

96
00:07:21,160 --> 00:07:23,393
Следует заметить,
что protobuf, конечно же,

97
00:07:23,393 --> 00:07:26,940
не единственный формат в бинарной
сериализации, который распространен.

98
00:07:26,940 --> 00:07:32,930
Еще есть MessagePack и формат AVR.

99
00:07:32,930 --> 00:07:37,500
Но мы их рассматривать не будем,
а сосредоточимся на protobuf.

100
00:07:37,500 --> 00:07:43,440
А теперь давайте перейдем уже к gRPC,
посмотрим,

101
00:07:43,440 --> 00:07:49,223
как при помощи protobuf можно
сгенерировать весь код, нужный там,

102
00:07:49,223 --> 00:07:55,220
и вдобавок ко всем структурам
сгенерировать сразу еще и сервис.