[БЕЗ_ЗВУКА] В этом видео мы рассмотрим еще одну особенность
grpc, которая называется streaming. Рассмотрим следующий protobuf
пакет и объявление сервиса. Допустим, у нас есть какой-то
сервис с транслитерацией, причем мы заранее не знаем,
сколько туда текста придет. Я говорю, и в реальном времени это уходит на какой-то
удаленный сервис по grpc. Там это переводится,
в данном случае транслитерируется, и возвращается мне обратно. То есть от меня идет
постоянный поток сообщений, и соответственно мне нужен
постоянный поток сообщений в ответ. Нет возможности отправить
это одним большим куском, потому что тогда ответ придет тоже одним
куском в самом конце, что не устраивает. Такое тоже можно реализовать,
и как раз вот это и называется стримингом. Рассмотрим сервис. Допустим, мой сервис транслитерации. Раньше для одиночных вызовов он
выглядел так: я отправляю слово, мне присылается слово,
но стриминга там нет. Если я напишу всего лишь
одно слово stream либо во входящем аргументе, либо в исходящем,
то сразу же появляется стриминг. В данном случае у меня и входящий
аргумент является потоком, и исходящий аргумент является потоком. Что это значит? Это значит, что у меня и в ту сторону,
и в ту сторону идут потоки данных непрерывные,
пока я не скажу, что завершить. Если бы у меня было вот так,
то есть это значит, что я отправил один одиночный запрос,
а в ответ мне идет поток постоянно. Если же сделать вот так, то это значит,
что от меня идет поток постоянно, а с той стороны мне вернется ответ всего
один раз, тогда этот поток закрою. Но в данном примере у меня сервис
транслитерации, он двусторонний стриминг. Directional streaming называется. Рассмотрим, как это выглядит в коде. Я сгенерировал по этому protobuf код, написал реализацию. Вот моя функция EnRu, я тут использую
внешний пакет для транслитерации. Вот смотрите. У нас двусторонний стриминг, поэтому мне приходит на вход только
один аргумент как раз этот стрим. Я из него буду и читать,
и писать в него же. Начнем. У меня есть бесконечный цикл. Я читаю, приходящий мне в protopath пакет. Если мне пришел EOF, это значит,
что с той стороны стрим закрылся. Если пришел не EOF,
какая-то ошибка, надо разбираться. Ладно, я прочитал пакет, там есть word. Теперь я делаю обратный пакет, я создаю тоже translit.Word, и там уже, применив функцию транслитерации,
и делаю send. То есть Recv он не читает,
Send он не отправляет. Вот и все. Когда я выйду из этого цикла? Либо когда мне придет EOF, то есть значит,
что с той стороны пакет закрылся, либо вернется ошибка. И также я могу написать в любом
месте return, и оно завершится. Это на стороне сервера,
то есть я считаю и сразу же отвечаю. Обратите внимание, я это делаю
синхронно: прочитал одно, записал одно. Потенциально это можно разделить
по разным горутинам и делать эти операции абсолютно синхронно. Допустим, есть у нас
какой-то сильный сервис, то там можно выстроить
какую-то очередь с лимитами. Рассмотрим теперь клиента. Обычное подключение к grpc, создание клиента, контекст. И теперь я создал этот поток. Клиент у меня в данном случае стрим. И вот тут я уже как раз и отправляю,
и читаю асинхронно. Создадим WaitGroup. Теперь начинаем туда писать. У меня есть три слова: privet, kak, dela. Я иду по ним в цикле и просто делаю Send туда и немножко сплю, чтобы хотя
бы как-то вы видели синхронность. Я отправил слово. В конце, когда у меня все слова
закончились, я из цикла вышел, я отправляю на ту сторону Send,
то есть я говорю клиенту: закройся. Я не могу его закрыть сразу просто убить, потому что я оттуда еще
могу что-то читать. Поэтому я просто отправляю
признак закрытия. Когда этот признак закрытия сработает, как
раз таки EOF придет вот сюда на сервер. Хорошо, отправка у меня закончилась,
горутина вышла. Теперь посмотрим чтение. Я по-прежнему в цикле читаю Recv так же,
как и на той стороне. Тут я делал Send, и на сервере я делал
Send, а тут просто делаю только чтение. То есть мне пришло одно слово,
и я его просто вывожу на экран. Все.
То есть я в двух отдельных горутинах: почти параллельно одна горутина шлет,
вторая оттуда читает. Что-то типа такого канала между серверами,
либо что-то похожее на pushsub. Надо это запустить. Запустим client.go. Отлично. Привет, как дела. И закончили отправку. Привет, как дела. Нам вернулся результат, и поток закрылся. Не очень получилось синхронно. Давайте запустим еще разок. Отлично. Привет, как дела. До нас успел дойти ответ,
прежде чем отправилось третье сообщение.Только на этом месте закрылся
отправлятор, и мне вернулись дела. Что в это время происходит на сервере? Вот мои два запроса. Вот раз транслитерация,
вот два транслитерация, что как я перевел. Стриминг — очень мощный инструмент. Например, в Google сервис
распознавания речи работает как раз через grpc streaming. То есть вы отправляете аудиопоток, как я здесь одиночные слова отправил, вы
отправляете в аудиопоток просто бинарные данные на ту сторону,
а вам возвращается распознанный текст. Так же, например, телеком и CISC,
Jupiter или Alcatel-Lucent используют в своих железках grpc стриминг
для отправки телеметрии. Поэтому если вам нужно отправить большой набор данных
либо принять большой набор данных, причем вы это хотите делать не одним
большим куском, а по мере того, как они поступают,
то как раз в этом и помогает вам стриминг.