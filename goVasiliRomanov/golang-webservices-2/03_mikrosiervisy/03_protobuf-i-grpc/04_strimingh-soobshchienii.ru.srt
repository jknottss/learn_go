1
00:00:00,000 --> 00:00:06,263
[БЕЗ_ЗВУКА] В этом

2
00:00:06,263 --> 00:00:13,770
видео мы рассмотрим еще одну особенность
grpc, которая называется streaming.

3
00:00:13,770 --> 00:00:19,600
Рассмотрим следующий protobuf
пакет и объявление сервиса.

4
00:00:19,600 --> 00:00:24,500
Допустим, у нас есть какой-то
сервис с транслитерацией,

5
00:00:24,500 --> 00:00:30,130
причем мы заранее не знаем,
сколько туда текста придет.

6
00:00:30,130 --> 00:00:35,948
Я говорю, и в реальном времени это

7
00:00:35,948 --> 00:00:41,060
уходит на какой-то
удаленный сервис по grpc.

8
00:00:41,060 --> 00:00:46,400
Там это переводится,
в данном случае транслитерируется,

9
00:00:46,400 --> 00:00:50,250
и возвращается мне обратно.

10
00:00:50,250 --> 00:00:54,410
То есть от меня идет
постоянный поток сообщений,

11
00:00:54,410 --> 00:00:58,570
и соответственно мне нужен
постоянный поток сообщений в ответ.

12
00:00:58,570 --> 00:01:02,051
Нет возможности отправить
это одним большим куском,

13
00:01:02,051 --> 00:01:07,660
потому что тогда ответ придет тоже одним
куском в самом конце, что не устраивает.

14
00:01:07,660 --> 00:01:13,170
Такое тоже можно реализовать,
и как раз вот это и называется стримингом.

15
00:01:13,170 --> 00:01:15,039
Рассмотрим сервис.

16
00:01:15,039 --> 00:01:18,680
Допустим, мой сервис транслитерации.

17
00:01:18,680 --> 00:01:23,258
Раньше для одиночных вызовов он
выглядел так: я отправляю слово,

18
00:01:23,258 --> 00:01:26,480
мне присылается слово,
но стриминга там нет.

19
00:01:26,480 --> 00:01:32,077
Если я напишу всего лишь
одно слово stream либо

20
00:01:32,077 --> 00:01:37,694
во входящем аргументе, либо в исходящем,
то сразу же появляется стриминг.

21
00:01:37,694 --> 00:01:42,098
В данном случае у меня и входящий
аргумент является потоком,

22
00:01:42,098 --> 00:01:45,090
и исходящий аргумент является потоком.

23
00:01:45,090 --> 00:01:47,045
Что это значит?

24
00:01:47,045 --> 00:01:52,329
Это значит, что у меня и в ту сторону,
и в ту сторону

25
00:01:52,329 --> 00:01:57,656
идут потоки данных непрерывные,
пока я не скажу, что завершить.

26
00:01:57,656 --> 00:02:02,706
Если бы у меня было вот так,
то есть это значит, что я отправил один

27
00:02:02,706 --> 00:02:07,393
одиночный запрос,
а в ответ мне идет поток постоянно.

28
00:02:07,393 --> 00:02:13,660
Если же сделать вот так, то это значит,
что от меня идет поток постоянно,

29
00:02:13,660 --> 00:02:19,780
а с той стороны мне вернется ответ всего
один раз, тогда этот поток закрою.

30
00:02:19,780 --> 00:02:25,900
Но в данном примере у меня сервис
транслитерации, он двусторонний стриминг.

31
00:02:25,900 --> 00:02:28,901
Directional streaming называется.

32
00:02:28,901 --> 00:02:32,000
Рассмотрим, как это выглядит в коде.

33
00:02:32,000 --> 00:02:36,958
Я сгенерировал по этому protobuf код,

34
00:02:36,958 --> 00:02:39,819
написал реализацию.

35
00:02:39,819 --> 00:02:45,744
Вот моя функция EnRu, я тут использую
внешний пакет для транслитерации.

36
00:02:45,744 --> 00:02:46,780
Вот смотрите.

37
00:02:46,780 --> 00:02:48,306
У нас двусторонний стриминг,

38
00:02:48,306 --> 00:02:51,780
поэтому мне приходит на вход только
один аргумент как раз этот стрим.

39
00:02:51,780 --> 00:02:55,510
Я из него буду и читать,
и писать в него же.

40
00:02:55,510 --> 00:02:56,311
Начнем.

41
00:02:56,311 --> 00:02:58,920
У меня есть бесконечный цикл.

42
00:02:58,920 --> 00:03:06,069
Я читаю, приходящий мне в protopath пакет.

43
00:03:06,069 --> 00:03:12,640
Если мне пришел EOF, это значит,
что с той стороны стрим закрылся.

44
00:03:12,640 --> 00:03:18,333
Если пришел не EOF,
какая-то ошибка, надо разбираться.

45
00:03:18,333 --> 00:03:21,640
Ладно, я прочитал пакет, там есть word.

46
00:03:21,640 --> 00:03:25,339
Теперь я делаю обратный пакет,

47
00:03:25,339 --> 00:03:31,430
я создаю тоже translit.Word, и там уже,

48
00:03:31,430 --> 00:03:36,560
применив функцию транслитерации,
и делаю send.

49
00:03:36,560 --> 00:03:40,600
То есть Recv он не читает,
Send он не отправляет.

50
00:03:40,600 --> 00:03:41,919
Вот и все.

51
00:03:41,919 --> 00:03:45,590
Когда я выйду из этого цикла?

52
00:03:45,590 --> 00:03:51,012
Либо когда мне придет EOF, то есть значит,
что с той стороны пакет закрылся,

53
00:03:51,012 --> 00:03:55,020
либо вернется ошибка.

54
00:03:55,020 --> 00:04:00,630
И также я могу написать в любом
месте return, и оно завершится.

55
00:04:00,630 --> 00:04:03,439
Это на стороне сервера,
то есть я считаю и сразу же отвечаю.

56
00:04:03,439 --> 00:04:07,030
Обратите внимание, я это делаю
синхронно: прочитал одно, записал одно.

57
00:04:07,030 --> 00:04:10,726
Потенциально это можно разделить
по разным горутинам и делать эти

58
00:04:10,726 --> 00:04:12,580
операции абсолютно синхронно.

59
00:04:12,580 --> 00:04:16,360
Допустим, есть у нас
какой-то сильный сервис,

60
00:04:16,360 --> 00:04:20,282
то там можно выстроить
какую-то очередь с лимитами.

61
00:04:20,282 --> 00:04:22,420
Рассмотрим теперь клиента.

62
00:04:22,420 --> 00:04:26,026
Обычное подключение к grpc,

63
00:04:26,026 --> 00:04:30,401
создание клиента, контекст.

64
00:04:30,401 --> 00:04:33,929
И теперь я создал этот поток.

65
00:04:33,929 --> 00:04:37,560
Клиент у меня в данном случае стрим.

66
00:04:37,560 --> 00:04:42,460
И вот тут я уже как раз и отправляю,
и читаю асинхронно.

67
00:04:42,460 --> 00:04:46,640
Создадим WaitGroup.

68
00:04:46,640 --> 00:04:48,816
Теперь начинаем туда писать.

69
00:04:48,816 --> 00:04:52,000
У меня есть три слова: privet, kak, dela.

70
00:04:52,000 --> 00:04:57,239
Я иду по ним в цикле и просто делаю

71
00:04:57,239 --> 00:05:03,170
Send туда и немножко сплю, чтобы хотя
бы как-то вы видели синхронность.

72
00:05:03,170 --> 00:05:04,425
Я отправил слово.

73
00:05:04,425 --> 00:05:08,665
В конце, когда у меня все слова
закончились, я из цикла вышел,

74
00:05:08,665 --> 00:05:12,659
я отправляю на ту сторону Send,
то есть я говорю клиенту: закройся.

75
00:05:12,659 --> 00:05:15,408
Я не могу его закрыть сразу просто убить,

76
00:05:15,408 --> 00:05:19,060
потому что я оттуда еще
могу что-то читать.

77
00:05:19,060 --> 00:05:22,041
Поэтому я просто отправляю
признак закрытия.

78
00:05:22,041 --> 00:05:28,610
Когда этот признак закрытия сработает, как
раз таки EOF придет вот сюда на сервер.

79
00:05:28,610 --> 00:05:36,360
Хорошо, отправка у меня закончилась,
горутина вышла.

80
00:05:36,360 --> 00:05:39,553
Теперь посмотрим чтение.

81
00:05:39,553 --> 00:05:46,185
Я по-прежнему в цикле читаю Recv так же,
как и на той стороне.

82
00:05:46,185 --> 00:05:52,517
Тут я делал Send, и на сервере я делал
Send, а тут просто делаю только чтение.

83
00:05:52,517 --> 00:05:56,371
То есть мне пришло одно слово,
и я его просто вывожу на экран.

84
00:05:56,371 --> 00:05:59,170
Все.
То есть я в двух отдельных горутинах:

85
00:05:59,170 --> 00:06:04,100
почти параллельно одна горутина шлет,
вторая оттуда читает.

86
00:06:04,100 --> 00:06:10,400
Что-то типа такого канала между серверами,
либо что-то похожее на pushsub.

87
00:06:10,400 --> 00:06:12,790
Надо это запустить.

88
00:06:12,790 --> 00:06:15,450
Запустим client.go.

89
00:06:15,450 --> 00:06:16,366
Отлично.

90
00:06:16,366 --> 00:06:18,095
Привет, как дела.

91
00:06:18,095 --> 00:06:20,131
И закончили отправку.

92
00:06:20,131 --> 00:06:21,870
Привет, как дела.

93
00:06:21,870 --> 00:06:25,670
Нам вернулся результат, и поток закрылся.

94
00:06:25,670 --> 00:06:27,775
Не очень получилось синхронно.

95
00:06:27,775 --> 00:06:29,660
Давайте запустим еще разок.

96
00:06:29,660 --> 00:06:30,656
Отлично.

97
00:06:30,656 --> 00:06:32,538
Привет, как дела.

98
00:06:32,538 --> 00:06:37,285
До нас успел дойти ответ,
прежде чем отправилось третье

99
00:06:37,285 --> 00:06:43,184
сообщение.Только на этом месте закрылся
отправлятор, и мне вернулись дела.

100
00:06:43,184 --> 00:06:45,980
Что в это время происходит на сервере?

101
00:06:45,980 --> 00:06:47,799
Вот мои два запроса.

102
00:06:47,799 --> 00:06:53,870
Вот раз транслитерация,
вот два транслитерация, что как я перевел.

103
00:06:53,870 --> 00:06:58,864
Стриминг — очень мощный инструмент.

104
00:06:58,864 --> 00:07:03,788
Например, в Google сервис
распознавания речи работает как раз

105
00:07:03,788 --> 00:07:05,620
через grpc streaming.

106
00:07:05,620 --> 00:07:10,310
То есть вы отправляете аудиопоток,

107
00:07:10,310 --> 00:07:14,684
как я здесь одиночные слова отправил, вы
отправляете в аудиопоток просто бинарные

108
00:07:14,684 --> 00:07:18,767
данные на ту сторону,
а вам возвращается распознанный текст.

109
00:07:18,767 --> 00:07:24,558
Так же, например, телеком и CISC,
Jupiter или Alcatel-Lucent используют

110
00:07:24,558 --> 00:07:30,250
в своих железках grpc стриминг
для отправки телеметрии.

111
00:07:30,250 --> 00:07:35,380
Поэтому если вам нужно

112
00:07:35,380 --> 00:07:40,856
отправить большой набор данных
либо принять большой набор данных,

113
00:07:40,856 --> 00:07:44,460
причем вы это хотите делать не одним
большим куском, а по мере того,

114
00:07:44,460 --> 00:07:49,790
как они поступают,
то как раз в этом и помогает вам стриминг.