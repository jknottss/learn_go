[БЕЗ_ЗВУКА] В этом видео
мы поговорим про redis. Изначально redis был
мемкэшем на астероидах, однако сейчас это key value
хранилище общего назначения, которое поддерживает просто огромное количество
команд буквально на все случаи жизни. У нас будет уже знакомый вам
пример с менеджером сессии, который кочует по всему курсу,
и мы будем хранить эти сессии в redis. Сразу оговорюсь, что это учебный пример. Если вы хотите использовать
redis для хранения сессии, лучше используйте готовый
протестированный модуль. В нем будет гораздо больше возможностей. Итак, redis, конечно,
не поставляется с Go, это внешняя библиотека, создается она,
как и все остальное через go get. Для начала нужно установить
соединение к redis. Делается это через DialURL,
у меня он по умолчанию вот такой вот. Я задаю его через флаги по умолчанию. Далее я создаю менеджер сессии и в
него передаю соединение до redis. Теперь рассмотрим,
как это работает в самом веб-сайте. Итак, вот моя страница логина пароля, я ввожу rvasiliy,
ввожу login test и логинюсь. Хорошо. Теперь при логине у меня создалась
сессия и положилась в redis. Если я открою еще раз, у меня сессия сохранится,
и достанется она как раз из сессии. При лог-ауте сессия моя удалится в redis. Теперь посмотрим,
какими командами все это выполняется. Итак, рассмотрим сам менеджер сессии. В нем ничего нет,
кроме соединения до самого redis. Теперь при попытке создать сессию, я создаю какой-то случайный ключ,
сериализую данные в json. Мой менеджер сессии очень простой, он не поддерживает никакие переменные,
которые хранятся внутри сессии, не поддерживает ничего,
просто сохранение логина и юзер-агента. Теперь я выполняю команду set,
и вообще-то всё. Теперь я сохранил значение. Команда Do у соединения отправляет
все значения уже как раз в сам redis, то есть туда можно передать ту команду,
которую вы хотите исполнить, ключ, для которого вы хотите
исполнить эту команду, данные и опции, если они поддерживаются. Команда Do на самом деле возвращает
какие-то данные и ошибку. data, err : = выглядит это обычно вот так. Поскольку данные, которые возвращает
сессия, не понятно, в каком они формате, и мы хотели бы их все-таки привести к
данным, которые соответствуют Go-типам. В redis есть набор утилитарных функций
как раз для конвертации данных. Стринги, инты, возврат в множество
значений, вот выглядит это вот так. То есть можно передавать команду
напрямую в этот хелпер для распаковки, можно вот так. Вот сейчас у меня распаковывается
значение в result, и если вдруг у меня команда на set
вернула не OK, я скажу, что не OK. И ошибки вернула. Собственно, всё для того,
чтобы вам установить значение в redis. Очень похоже на мемкэш. Чек. Тут все то же самое. Я выполняю команду уже не set,
а get на ключ. И теперь получаю данные. Обратите внимание,
раньше у меня был стринг, то есть команда set мне возвращает
какой-то строковый ответ: OK, не OK. В get я получаю просто slice byte, использую для этого хелпер bytes,
а далее распаковываю в нем json. Ну и наконец, команда delete,
которая удаляет значения. Всё то же самое. Вызываю метод Do у соединения,
и парсим его. Я распаковываю ответ в Int, точнее,
не распаковываю, а пропускаю его. Но команда delete будет рассказывать,
сколько записей удалено по данному ключу. Собственно, вот и все: то есть get, set, delete, add у redis реализованы очень
просто, и работать с этим хорошо. Как выглядит сама наша функция? Мой SessionManager я
могу проверять по Cookie, могу получать SessionID по тому,
что пришло мне из Cookie. И отправлять пользователя
на форум авторизации, либо же показывать ему какой-то текст. Но создание сессии тоже все просто. Я создаю структуру,
куда указываю свои данные и юзер-агента. На этом все. Все очень просто.