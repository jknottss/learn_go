1
00:00:00,000 --> 00:00:08,514
[БЕЗ_ЗВУКА] В этом видео мы рассмотрим,

2
00:00:08,514 --> 00:00:12,860
каким образом можно работать
с memcache из гошки.

3
00:00:12,860 --> 00:00:17,002
memcache — это очень простое
key-value хранилище.

4
00:00:17,002 --> 00:00:19,800
У него не очень много возможностей,

5
00:00:19,800 --> 00:00:23,860
однако это компенсируется
его простой и надежностью.

6
00:00:23,860 --> 00:00:28,810
На самом деле, рассматривать

7
00:00:28,810 --> 00:00:33,760
просто сохранение значений memcache и

8
00:00:33,760 --> 00:00:38,686
получение оттуда данных —
это примерно такой же драйв,

9
00:00:38,686 --> 00:00:45,001
как и рассматривать присвоение
значений в переменные.

10
00:00:45,001 --> 00:00:48,650
Поэтому пройдемся мы очень быстро и
перейдем к более практическому примеру.

11
00:00:48,650 --> 00:00:55,862
Итак, команда Set сохраняет запись,
независимо от того была она там или нет.

12
00:00:55,862 --> 00:00:58,310
Если она там была, она ее перезаписывает.

13
00:00:58,310 --> 00:01:03,640
Для этого вам нужно передать
полностью всю запись memcache Item,

14
00:01:03,640 --> 00:01:09,373
ключ — строка,
Value — слайс-байт, и Expiration

15
00:01:09,373 --> 00:01:14,196
— время в секундах, через которое вы через
которое запись будет уже неактуальна.

16
00:01:14,196 --> 00:01:17,146
Increment увеличивает
запись на 1 или на −1,

17
00:01:17,146 --> 00:01:20,100
в зависимости от того что вы передадите.

18
00:01:20,100 --> 00:01:22,935
Get получает запись по ключу.

19
00:01:22,935 --> 00:01:26,427
Обратите внимание,
что если запись не найдена,

20
00:01:26,427 --> 00:01:29,170
признак об этом вернется вам
в специальном коде ошибки.

21
00:01:29,170 --> 00:01:34,441
Удаление — ничего сложного и интересного.

22
00:01:34,441 --> 00:01:37,910
Поэтому не будем на этом
останавливаться и пойдем дальше.

23
00:01:37,910 --> 00:01:41,900
memcache очень простой,

24
00:01:41,900 --> 00:01:46,280
но кеширование все-таки хочется
делать какое-то посложнее.

25
00:01:46,280 --> 00:01:48,763
Рассмотрим следующую схему.

26
00:01:48,763 --> 00:01:54,472
Представьте, что у нас
контент-проект и есть много

27
00:01:54,472 --> 00:02:00,740
различных закешированных данных,

28
00:02:00,740 --> 00:02:04,880
например RSS, главная страница,
какой-то информер для партнеров.

29
00:02:04,880 --> 00:02:09,170
И там их больше, больше, больше, больше.

30
00:02:09,170 --> 00:02:13,572
При этом если вы будете пытаться
каждую из этих запись — RSS, mainPage,

31
00:02:13,572 --> 00:02:16,231
partnersInformer — сохранять в админке,

32
00:02:16,231 --> 00:02:20,310
для того чтобы сбросить,
когда у вас что-то новое добавляется,

33
00:02:20,310 --> 00:02:25,450
вы быстро утомитесь и
наверняка что-то пропустите.

34
00:02:25,450 --> 00:02:29,070
Поэтому есть подход,
который называется «тегированный кеш»,

35
00:02:29,070 --> 00:02:34,800
когда вы храните не сразу свои данные,

36
00:02:34,800 --> 00:02:38,252
а еще какую-то небольшую
метаинформацию в нем.

37
00:02:38,252 --> 00:02:40,890
Например, это теги в данном случае.

38
00:02:40,890 --> 00:02:46,920
Теги — это такая мапа,
string, int в данном случае,

39
00:02:46,920 --> 00:02:53,060
где ключ указывает на какую-то
другую запись в memcache,

40
00:02:53,060 --> 00:02:59,330
а значение — это какой-то числовой код,
например timestamp, время.

41
00:02:59,330 --> 00:03:00,445
Вот.

42
00:03:00,445 --> 00:03:03,790
И если вы хотите,

43
00:03:03,790 --> 00:03:09,368
если вы увеличите время,

44
00:03:09,368 --> 00:03:13,370
инкрементируете счетчик в этом теге,

45
00:03:13,370 --> 00:03:18,120
то есть в этой записи memcache,
используя команду Increment,

46
00:03:18,120 --> 00:03:23,260
либо просто поставите туда
текущее значение Unix timestamp,

47
00:03:23,260 --> 00:03:28,930
то все записи, у которых есть такой тег,

48
00:03:28,930 --> 00:03:34,464
когда вы их достанете из кеша, распакуете,

49
00:03:34,464 --> 00:03:39,880
то вы можете понять, что эта запись
не валидна и кеш нужно перестроить.

50
00:03:39,880 --> 00:03:47,192
Вот, например, смотрите:
partnersInformer я выделил красным.

51
00:03:47,192 --> 00:03:47,993
Почему?

52
00:03:47,993 --> 00:03:51,100
Потому что тег video у него равен 3,

53
00:03:51,100 --> 00:03:56,730
то есть он был сохранен,
когда тег video был равен 3.

54
00:03:56,730 --> 00:04:01,473
Однако текущее значение у тега video — 4.

55
00:04:01,473 --> 00:04:05,100
Это значит, что вот этот кеш,

56
00:04:05,100 --> 00:04:10,330
он уже не валиден,
и его нужно перестроить.

57
00:04:10,330 --> 00:04:17,457
Вот это один из вариантов
такой инвалидации кеша,

58
00:04:17,457 --> 00:04:23,166
когда у вас неизвестно количество
самих закешированных данных.

59
00:04:23,166 --> 00:04:27,870
Например, вы в админке
просто инкрементните video,

60
00:04:27,870 --> 00:04:33,225
поставите там 5, и уже mainPage,
кеш для mainPage будет невалиден.

61
00:04:33,225 --> 00:04:38,917
В следующий раз, когда он выберется,
там сравнится значение

62
00:04:38,917 --> 00:04:42,954
тегов и будет перестроение кеша.

63
00:04:42,954 --> 00:04:46,433
При этом вы сразу же не вызываете
каскадное перестроение всего,

64
00:04:46,433 --> 00:04:50,450
просто увеличиваете значение в админке,

65
00:04:50,450 --> 00:04:54,860
а перестраиваться кеш
будет по мере запроса.

66
00:04:54,860 --> 00:05:01,700
Теперь давайте посмотрим,
как реализовать такую схему, используя Go.

67
00:05:01,700 --> 00:05:09,340
Итак, теперь рассмотрим уже
код тегированного кеша.

68
00:05:09,340 --> 00:05:12,502
Этот пример будет довольно большой,

69
00:05:12,502 --> 00:05:17,217
если у вас закипят мозги, так и задумано.

70
00:05:17,217 --> 00:05:18,670
Хорошо.

71
00:05:18,670 --> 00:05:24,838
Для начала сделаем структуру нашу.

72
00:05:24,838 --> 00:05:28,342
Я ее взял тут в комментарии,
потому что, на самом деле,

73
00:05:28,342 --> 00:05:30,830
она у меня определена в соседнем файле.

74
00:05:30,830 --> 00:05:37,212
Назовем это Cache,
и она включает в себя клиент memcache,

75
00:05:37,212 --> 00:05:41,590
то есть я могу пользоваться
всеми методами,

76
00:05:41,590 --> 00:05:48,932
которые предоставляет мне memcache.Client,
вызывая их у экземпляра этой структуры.

77
00:05:48,932 --> 00:05:55,235
Вот так она инициализируется,
инициируется.

78
00:05:55,235 --> 00:05:58,344
И начну с того,
что я грохну старые данные,

79
00:05:58,344 --> 00:06:02,355
которые были закешированы,
чтобы пример у нас был чистым.

80
00:06:02,355 --> 00:06:02,872
Вот.

81
00:06:02,872 --> 00:06:05,872
tc — так я буду называть свой кеш.

82
00:06:05,872 --> 00:06:07,527
Я вызываю Delete.

83
00:06:07,527 --> 00:06:12,240
Delete — это метод memcache.Client,

84
00:06:12,240 --> 00:06:16,630
то есть в данном случае я
демонстрирую вам композицию.

85
00:06:16,630 --> 00:06:20,427
В этом примере я вообще буду
демонстрировать половину возможностей

86
00:06:20,427 --> 00:06:21,020
языка Go.

87
00:06:21,020 --> 00:06:25,060
Хорошо, удалили.

88
00:06:25,060 --> 00:06:31,768
Теперь как выглядит интрефейс
по тегированному кешу?

89
00:06:31,768 --> 00:06:36,128
Вот вызов, вот вызов кеша.

90
00:06:36,128 --> 00:06:40,249
Я вызываю mkey — не важно,

91
00:06:40,249 --> 00:06:45,500
какое там значение,
то есть значение ключа с кешом.

92
00:06:45,500 --> 00:06:48,836
30 — это время жизни этого ключа,
30 секунд.

93
00:06:48,836 --> 00:06:54,640
И я говорю, что запиши мне, пожалуйста,
вот в этот RSS, вот в это значение.

94
00:06:54,640 --> 00:06:57,690
И передаю в функцию к rebuild.

95
00:06:57,690 --> 00:07:02,889
Ее нужно посмотреть внимательней

96
00:07:02,889 --> 00:07:06,842
— что она делает и когда
она будет вызвана.

97
00:07:06,842 --> 00:07:12,872
Эта функция, она получает значение уже,

98
00:07:12,872 --> 00:07:16,484
например, из холодного хранилища,
из базы данных.

99
00:07:16,484 --> 00:07:21,775
В данном примере она идет на сайт
«Хабра» в RSS и получает оттуда посты.

100
00:07:21,775 --> 00:07:26,123
Возвращает она interface,
слайс стрингов и ошибку.

101
00:07:26,123 --> 00:07:31,952
interface нужен, для того чтобы я мог
возвращать, чтобы этот механизм был

102
00:07:31,952 --> 00:07:37,494
универсальный, то есть я делаю функцию,
которая мне возвращает что угодно.

103
00:07:37,494 --> 00:07:41,147
Это что угодно я потом сохраню
и в случае чего достану.

104
00:07:41,147 --> 00:07:43,700
В данном случае у меня там RSS внутри.

105
00:07:43,700 --> 00:07:49,510
Дальше слайс стрингов — это те теги,
которые я хочу сохранить.

106
00:07:49,510 --> 00:07:53,223
для данной структуры, для данного кеша.

107
00:07:53,223 --> 00:07:57,990
Если вернуться к нашей схеме, то в data

108
00:07:57,990 --> 00:08:04,505
будет уже значение постов с «Хабра»,

109
00:08:04,505 --> 00:08:10,135
а в tags в tags будут сохранены те данные,

110
00:08:10,135 --> 00:08:13,642
которые я вернул в слайсе стрингов.

111
00:08:13,642 --> 00:08:14,550
Хорошо.

112
00:08:14,550 --> 00:08:18,046
То есть так мы посмотрели,

113
00:08:18,046 --> 00:08:23,970
каким образом я получу, собственно,
настоящие данные уже честно.

114
00:08:23,970 --> 00:08:27,433
Да, это анонимная функция.

115
00:08:27,433 --> 00:08:29,930
И я передаю ее в TGet.

116
00:08:29,930 --> 00:08:33,198
Потом я вызываю еще раз,

117
00:08:33,198 --> 00:08:37,769
теперь полезли внутрь, в TGet.

118
00:08:37,769 --> 00:08:40,739
Так, mkey, ttl,

119
00:08:40,739 --> 00:08:45,595
in interface,
то есть я передаю сюда — напоминаю,

120
00:08:45,595 --> 00:08:50,943
это у меня универсальная функция,
она должна работать с любыми данными.

121
00:08:50,943 --> 00:08:53,010
Сюда я передал RSS.

122
00:08:53,010 --> 00:08:56,920
Теперь я хочу себя немножко обезопасить,

123
00:08:56,920 --> 00:09:02,850
я проверяю через reflect тип данных,
которые мне прислали.

124
00:09:02,850 --> 00:09:05,030
В данном случае я хочу проверить,

125
00:09:05,030 --> 00:09:09,400
что мне прислали действительно
указатель на какую-то структуру,

126
00:09:09,400 --> 00:09:13,360
то есть если я туда запишу результат,
он наверху там где-то уже появится.

127
00:09:13,360 --> 00:09:14,397
Отлично.

128
00:09:14,397 --> 00:09:16,818
Дальше идет checklock.

129
00:09:16,818 --> 00:09:20,050
Что такое checklock, зачем он?

130
00:09:20,050 --> 00:09:24,977
Он проверяет, есть ли

131
00:09:24,977 --> 00:09:30,063
уже в данном случае lock на этот кеш,

132
00:09:30,063 --> 00:09:34,070
то есть вдруг его кто-то в
данный момент перестраивает.

133
00:09:34,070 --> 00:09:37,150
Что я в нем делаю?

134
00:09:37,150 --> 00:09:41,400
Я в нем пытаюсь несколько раз сходить

135
00:09:41,400 --> 00:09:46,628
в в

136
00:09:46,628 --> 00:09:51,990
memcache по ключу lock + mkey,

137
00:09:51,990 --> 00:09:57,791
и если я вдруг вижу, что я получил
эту запись, то есть если ее там нет,

138
00:09:57,791 --> 00:10:01,410
это хорошо, значит, никто не
перестраивает, я могу идти дальше,

139
00:10:01,410 --> 00:10:06,950
В противном случае я просто сплю,

140
00:10:06,950 --> 00:10:11,277
то есть жду, пока кто-то перестроит.

141
00:10:11,277 --> 00:10:15,370
Обращу внимание,
что это несколько учебный пример.

142
00:10:15,370 --> 00:10:19,062
У вас может быть другая логика, вы можете
спать дольше или в зависимости от кэша,

143
00:10:19,062 --> 00:10:21,220
или захотите передавать
эти параметры извне.

144
00:10:21,220 --> 00:10:23,523
То есть я подождал.

145
00:10:23,523 --> 00:10:26,370
Допустим, я дождался.

146
00:10:26,370 --> 00:10:30,460
Идем дальше.

147
00:10:30,460 --> 00:10:32,152
Идем дальше.

148
00:10:32,152 --> 00:10:40,030
Теперь я получаю уже сами записи из
моего кэша, то есть уже по mkey.

149
00:10:40,030 --> 00:10:44,303
Допустим, я столкнулся с ситуацией,

150
00:10:44,303 --> 00:10:50,305
когда записи в кэше еще нет,
и мне нужно теперь перестроить кэш.

151
00:10:50,305 --> 00:10:54,570
Я вызываю функцию memcache rebuilt,

152
00:10:54,570 --> 00:11:00,240
куда передаю фактически все те же
данные — mkey, время жизни, переменную,

153
00:11:00,240 --> 00:11:04,130
куда нужно записать, и callback,
который мне вернет настоящие данные.

154
00:11:04,130 --> 00:11:07,502
Сейчас в rebuild мы не будем углубляться,
а потом дальше.

155
00:11:07,502 --> 00:11:10,340
Предположим, что значение
в кэше у нас нашлось.

156
00:11:10,340 --> 00:11:14,080
Окей.

157
00:11:14,080 --> 00:11:16,456
То есть я хочу его распаковать.

158
00:11:16,456 --> 00:11:18,130
Там json, я напомню.

159
00:11:18,130 --> 00:11:20,093
Покажу еще раз на схеме.

160
00:11:20,093 --> 00:11:20,934
Это json.

161
00:11:20,934 --> 00:11:23,647
Фигурные скобочки, все хорошо.

162
00:11:23,647 --> 00:11:25,518
Я хочу её распаковать.

163
00:11:25,518 --> 00:11:32,786
Причем давайте посмотрим,
как выглядит структура CacheItem.

164
00:11:32,786 --> 00:11:34,621
Там полноценный кэш.

165
00:11:34,621 --> 00:11:38,270
В Data я использую
параметр json.RawMessage.

166
00:11:38,270 --> 00:11:42,440
Это значит, что, даже если там
будут дальше фигурные скобки,

167
00:11:42,440 --> 00:11:48,770
оно не будет их распаковывать
дальше во что-то другое,

168
00:11:48,770 --> 00:11:52,090
а сохранит прямо как есть, как слайс байт.

169
00:11:52,090 --> 00:11:55,098
Это понадобится чуть дальше.

170
00:11:55,098 --> 00:11:57,527
Хорошо, я распаковал.

171
00:11:57,527 --> 00:12:00,930
Теперь у меня есть какие-то мои данные.

172
00:12:00,930 --> 00:12:05,000
Я не знаю, какова их структура сейчас,
на этом моменте,

173
00:12:05,000 --> 00:12:08,215
поэтому я не могу их распаковать сразу.

174
00:12:08,215 --> 00:12:13,864
И распаковал теги в map[string]int.

175
00:12:13,864 --> 00:12:19,057
Теперь мне нужно пойти и проверить,
валидны ли мои теги.

176
00:12:19,057 --> 00:12:20,500
Вернемся к схеме.

177
00:12:20,500 --> 00:12:24,874
То есть для выделенного
красным кэша я должен

178
00:12:24,874 --> 00:12:29,490
пройтись по news и узнать,
действительно ли в new лежит значение 2,

179
00:12:29,490 --> 00:12:34,575
и video, и действительно ли
в video лежит значение 3.

180
00:12:34,575 --> 00:12:37,290
В данном случае там лежит 4.

181
00:12:37,290 --> 00:12:41,710
Значит, isTagsValid

182
00:12:41,710 --> 00:12:46,845
вернет мне false, что внутри isTagsValid.

183
00:12:46,845 --> 00:12:51,980
Для начала я конструирую слайс строк.

184
00:12:51,980 --> 00:12:58,033
Потом я использую метод
GetMulti из memcache-клиента.

185
00:12:58,033 --> 00:13:00,630
Он мне получает сразу много записей.

186
00:13:00,630 --> 00:13:07,621
И по ним я начинаю уже
строить мапу текущих записей.

187
00:13:07,621 --> 00:13:12,491
Я конвертирую,
мне вернулось много memcache item'ов.

188
00:13:12,491 --> 00:13:15,204
Мне вернулось много
структур memcache item.

189
00:13:15,204 --> 00:13:16,670
Я прохожусь, вот curr.

190
00:13:16,670 --> 00:13:20,740
Я прохожусь по ним.

191
00:13:20,740 --> 00:13:24,580
Key — это те ключи которые я передал,
и Item.

192
00:13:24,580 --> 00:13:31,667
Я то, что там есть, я преобразую
слайс байт в int и кладу в мапу.

193
00:13:31,667 --> 00:13:37,110
Теперь у меня есть две мапы — одна мапа,
которая лежала у меня в кэше,

194
00:13:37,110 --> 00:13:40,910
и вторая мапа с текущими значениями,
актуальными.

195
00:13:40,910 --> 00:13:48,630
Используя функцию DeepEqual из
пакета reflect я сравниваю,

196
00:13:48,630 --> 00:13:53,040
действительно ли обе эти
мапы полностью равны.

197
00:13:53,040 --> 00:13:58,500
И, как я уже говорил,
если они равны, значит кэш валиден.

198
00:13:58,500 --> 00:14:00,133
Там все хорошо.

199
00:14:00,133 --> 00:14:06,440
Если не равны, значит кэш не валиден,
его нужно перестроить.

200
00:14:06,440 --> 00:14:09,970
Допустим, кэш валиден.

201
00:14:09,970 --> 00:14:12,831
Кэш валиден.

202
00:14:12,831 --> 00:14:14,740
Хорошо.

203
00:14:14,740 --> 00:14:19,377
Теперь я должен

204
00:14:19,377 --> 00:14:23,910
распаковать данные этого кэша уже в

205
00:14:23,910 --> 00:14:28,440
реальные — в ту структуру,
которую я хочу видеть на выходе.

206
00:14:28,440 --> 00:14:31,510
Я не мог её распаковать раньше,
потому что я не знал,

207
00:14:31,510 --> 00:14:34,180
что там будет и надо ли
мне это распаковывать.

208
00:14:34,180 --> 00:14:37,537
Поэтому я её просто сохранил в Data.

209
00:14:37,537 --> 00:14:41,880
Теперь я беру эту Data и
передаю туда параметр,

210
00:14:41,880 --> 00:14:46,940
то есть тот, который мне пришел извне,
в который я хочу записать результат.

211
00:14:46,940 --> 00:14:51,124
В данном случае тут err ss и
json.Unmarshal за счет того,

212
00:14:51,124 --> 00:14:55,160
что он внутри работает
через reflect динамически,

213
00:14:55,160 --> 00:15:01,565
он пройдется по этим данным, структуры

214
00:15:01,565 --> 00:15:06,440
раньше которых я не знал, и сможет их уже
теперь записать туда, куда мне нужно.

215
00:15:06,440 --> 00:15:11,661
То есть я могу работать в данном случае,

216
00:15:11,661 --> 00:15:15,000
вообще, абсолютно с любыми данными,
которые я храню в кэше,

217
00:15:15,000 --> 00:15:19,980
используя всего лишь несколько
этапов просто распаковки.

218
00:15:19,980 --> 00:15:24,441
Первый раз я распаковываю
их в json.RawMessage.

219
00:15:24,441 --> 00:15:26,420
Там слайс байт будет.

220
00:15:26,420 --> 00:15:30,814
А второй раз я их распаковываю
уже в реальную переменную.

221
00:15:30,814 --> 00:15:35,386
Допустим, да, и сейчас все хорошо, то есть
кэш валиден и мне вернулся результат,

222
00:15:35,386 --> 00:15:37,020
я могу им дальше пользоваться.

223
00:15:37,020 --> 00:15:44,445
Теперь кэш не валиден и
мне нужно его перестроить.

224
00:15:44,445 --> 00:15:47,020
Как раз этим занимается функция rebuild.

225
00:15:47,020 --> 00:15:50,386
Ранее мы в нее не заходили,
а теперь зайдем.

226
00:15:50,386 --> 00:15:55,348
Да, я напоминаю, что я туда передаю ключ,
время жизни, переменную, куда я хочу

227
00:15:55,348 --> 00:16:00,355
записать результат, и callback,
который мне вернет реальные данные.

228
00:16:00,355 --> 00:16:01,410
Идем внутрь.

229
00:16:01,410 --> 00:16:07,309
Для начала я залочу кэш на перестроение

230
00:16:07,309 --> 00:16:12,190
— lockRebuild.

231
00:16:12,190 --> 00:16:17,760
Я буду в цикле несколько раз
пробовать делать add на запись.

232
00:16:17,760 --> 00:16:18,832
Почему add?

233
00:16:18,832 --> 00:16:20,099
Почему не set?

234
00:16:20,099 --> 00:16:23,431
Add добавляет запись,
только если её там нет.

235
00:16:23,431 --> 00:16:27,973
Это значит, что, если я в данном
случае делаю add и запись я не смог

236
00:16:27,973 --> 00:16:33,183
добавить — ErrNotStored,
то кто-то другой перестраивает эту запись.

237
00:16:33,183 --> 00:16:35,220
И мне нужно здесь немножко подождать.

238
00:16:35,220 --> 00:16:40,920
Я ставлю timeout — tt
Expiration на 3 секунды.

239
00:16:40,920 --> 00:16:43,676
Напомню, это учебный пример.

240
00:16:43,676 --> 00:16:47,657
Все цифры тут учебные, поэтому, возможно,

241
00:16:47,657 --> 00:16:51,960
у вас вы захотите настраивать
эти параметры или

242
00:16:51,960 --> 00:16:56,980
перестроить возможность для
залоченного кэша что-то делать.

243
00:16:56,980 --> 00:16:57,768
Хорошо.

244
00:16:57,768 --> 00:17:01,320
Допустим, я подождал, я дождался lock.

245
00:17:01,320 --> 00:17:04,265
То есть если я смог взять lock,
то, значит,

246
00:17:04,265 --> 00:17:07,655
что я смог успешно добавить
запись в memcache.

247
00:17:07,655 --> 00:17:09,203
Я дождался lock.

248
00:17:09,203 --> 00:17:14,676
Все, теперь я верну true, что все хорошо,
я взял lock на перестроение.

249
00:17:14,676 --> 00:17:16,420
Теперь я могу работать.

250
00:17:16,420 --> 00:17:21,450
И там сразу же я делаю
в defer unlockRebuild.

251
00:17:21,450 --> 00:17:24,156
Он просто удаляет запись из memcache.

252
00:17:24,156 --> 00:17:28,268
Кстати, обратите внимание,
я везде обращаюсь к методам

253
00:17:28,268 --> 00:17:33,460
memcache-клиента как к методам TCache,

254
00:17:33,460 --> 00:17:37,100
потому что memcache у меня
встроен как анонимная структура.

255
00:17:37,100 --> 00:17:39,148
Этот как раз композиция — то,

256
00:17:39,148 --> 00:17:45,130
каким образом вы можете
расширять свою структуру в Go.

257
00:17:45,130 --> 00:17:48,195
Rebuild, ладно.

258
00:17:48,195 --> 00:17:50,880
Мы залочились.

259
00:17:50,880 --> 00:17:52,216
Все хорошо.

260
00:17:52,216 --> 00:17:55,500
Мы взяли lock на перестроение.

261
00:17:55,500 --> 00:17:57,852
На самом деле, если бы у вас, например,

262
00:17:57,852 --> 00:18:02,710
только один сервис мог перестраивать этот
кэш, у вас могла бы быть локальная мапка.

263
00:18:02,710 --> 00:18:07,120
А если у вас много серверов,
которые могут перестраивать этот кэш,

264
00:18:07,120 --> 00:18:12,400
тогда мы сохраняем этот lock в том же
самом memcache, как в этом примере.

265
00:18:12,400 --> 00:18:13,527
Мы залочились.

266
00:18:13,527 --> 00:18:15,460
Теперь я вызываю callback.

267
00:18:15,460 --> 00:18:19,520
Теперь я вызываю callback,
который я тащил с самого начала.

268
00:18:19,520 --> 00:18:21,810
Он мне возвращает результат.

269
00:18:21,810 --> 00:18:24,370
Напомню, там пустой интерфейс.

270
00:18:24,370 --> 00:18:26,525
RebuildFunc.

271
00:18:26,525 --> 00:18:30,658
RebuildFunc я определил как отдельный тип,

272
00:18:30,658 --> 00:18:35,280
то есть он мне возвращает интерфейс,
слайс стрингов и ошибку.

273
00:18:35,280 --> 00:18:41,100
Теги, которые мне нужно будет сохранить,
и ошибку.

274
00:18:41,100 --> 00:18:42,918
Теперь немножко проверок.

275
00:18:42,918 --> 00:18:48,380
Я хочу убедиться, что то, что я запрашиваю
извне, куда я хочу записать результат,

276
00:18:48,380 --> 00:18:54,900
и тот результат, который мне вернул
callback, они имеют одинаковые типы.

277
00:18:54,900 --> 00:19:00,270
Согласитесь, будет очень странно, если вы
будете присваивать в разные типы данных.

278
00:19:00,270 --> 00:19:03,790
Я проверил через reflect.TypeOf.

279
00:19:03,790 --> 00:19:07,564
Он возвращает мне тип данных,
которые там находятся.

280
00:19:07,564 --> 00:19:11,948
В обоих из этих случаев будет *err ss.

281
00:19:11,948 --> 00:19:14,973
Дальше, напомню,

282
00:19:14,973 --> 00:19:19,954
что rebuildCb мне возвращает
теги в виде слайса строк.

283
00:19:19,954 --> 00:19:23,910
Я хочу их получить теперь,

284
00:19:23,910 --> 00:19:29,360
теперь их значения из memcache.

285
00:19:29,360 --> 00:19:32,061
Опять-таки все просто.

286
00:19:32,061 --> 00:19:35,050
У меня пришел слайс тегов.

287
00:19:35,050 --> 00:19:37,526
Я сделал GetMulti.

288
00:19:37,526 --> 00:19:40,300
Потом я получил мапу.

289
00:19:40,300 --> 00:19:45,877
И дальше я смотрю,
если у меня такая запись в memcache есть,

290
00:19:45,877 --> 00:19:50,555
я беру её значение, то,
которое реально в memcache.

291
00:19:50,555 --> 00:19:58,820
Если же записи у меня нет,
То есть нет такой записи в memcache еще,

292
00:19:58,820 --> 00:20:04,149
то я создаю, используя текущее время.

293
00:20:04,149 --> 00:20:08,860
И я получил map уже из текущих значений,

294
00:20:08,860 --> 00:20:12,460
которые лежат в memcache по тегам.

295
00:20:12,460 --> 00:20:16,298
То есть у меня это я либо
взял из memcache их реальные,

296
00:20:16,298 --> 00:20:19,200
либо их добавил,
и они тоже стали реальными.

297
00:20:19,200 --> 00:20:22,980
Пойдем дальше.

298
00:20:22,980 --> 00:20:28,820
Хорошо, я получил текущие теги в
виде мапки, теперь я хочу сохранить.

299
00:20:28,820 --> 00:20:33,070
Как выглядит структура,
которую я буду сериализовать в JSON?

300
00:20:33,070 --> 00:20:36,929
В качестве data там уже интерфейс, это
значит, что я могу туда присвоить любые

301
00:20:36,929 --> 00:20:43,345
данные, и когда я буду их сериализовать,
уже оно через reflect,

302
00:20:43,345 --> 00:20:49,190
или если вы там сгенерили маршалеры,
оно пройдется, и все сериализует.

303
00:20:49,190 --> 00:20:52,887
То есть я туда могу присваивать,
в эту структуру, в data, любые данные,

304
00:20:52,887 --> 00:20:55,190
и они сериализуются нормальными,
ну и теги.

305
00:20:55,190 --> 00:21:02,567
Отлично, замаршалили,
установили через set.

306
00:21:02,567 --> 00:21:07,571
Теперь, каким образом мне
нужно присвоить result?

307
00:21:07,571 --> 00:21:14,305
Конечно, изначально была идея,
что in = result, ну вот как-то так.

308
00:21:14,305 --> 00:21:17,730
На самом деле не сработает.

309
00:21:17,730 --> 00:21:23,490
Вот так тоже не сработает,
потому что там внутри интерфейс,

310
00:21:23,490 --> 00:21:27,960
и ему присвоится немножко не так,
как вы ожидаете.

311
00:21:27,960 --> 00:21:35,088
Поэтому тут дальше хитрое очень
такое присваивание будет.

312
00:21:35,088 --> 00:21:40,033
Поскольку это интерфейсы,
то я хочу достучаться до того значения,

313
00:21:40,033 --> 00:21:41,890
которое там лежит в глубине.

314
00:21:41,890 --> 00:21:48,925
Это можно было бы сделать, например,

315
00:21:48,925 --> 00:21:55,010
вот так in

316
00:21:55,010 --> 00:21:58,797
вот так,

317
00:21:58,797 --> 00:22:05,910
однако я не знаю,
какое там значение в реальности будет,

318
00:22:05,910 --> 00:22:11,994
поэтому вот следующей хитрой конструкцией
я, собственно, проверну примерно такую,

319
00:22:11,994 --> 00:22:18,546
ну да, val = result,
вот типа такого могло бы быть.

320
00:22:18,546 --> 00:22:21,620
Вот то, что я напишу снизу,
— это аналогичная конструкция.

321
00:22:21,620 --> 00:22:26,867
Так, я сначала получаю ValueOf,
той переменной,

322
00:22:26,867 --> 00:22:31,190
это уже reflect той переменной,
куда я хочу записать,

323
00:22:31,190 --> 00:22:37,452
я получаю Value той переменной,
что я хочу туда записать.

324
00:22:37,452 --> 00:22:42,500
Теперь, используя indirect,
то есть direct получает Value,

325
00:22:42,500 --> 00:22:46,565
куда указывает предыдущая Value.

326
00:22:46,565 --> 00:22:48,439
Это уже прямо магия.

327
00:22:48,439 --> 00:22:50,630
Я получаю оба значения,

328
00:22:50,630 --> 00:22:55,980
и теперь уже наконец я могу
сделать set у этого значения.

329
00:22:55,980 --> 00:23:00,329
Теперь наконец я достучался до
самых-самых-самых переменных,

330
00:23:00,329 --> 00:23:03,160
которые лежат за этим пустым интерфейсом,

331
00:23:03,160 --> 00:23:06,736
и я наконец могу присвоить их значение,
то есть это примерно,

332
00:23:06,736 --> 00:23:11,129
если бы я сделал вот так, если бы я знал
их типы, если бы я мог туда присвоить,

333
00:23:11,129 --> 00:23:16,082
а поскольку это пустой интерфейс,
то вот такая хитрая конструкция.

334
00:23:16,082 --> 00:23:20,287
Ну и в данном случае уже вот здесь,
вот в этой строчке,

335
00:23:20,287 --> 00:23:27,100
я записываю результат финальный, который
прокинется на самый верх и будет наружу.

336
00:23:27,100 --> 00:23:30,440
Давайте теперь это запустим.

337
00:23:30,440 --> 00:23:39,820
[БЕЗ_ЗВУКА] Отлично.

338
00:23:39,820 --> 00:23:45,502
В первый раз я запросил записи из
memcache, ее там не было вообще,

339
00:23:45,502 --> 00:23:49,554
я поэтому зафетчил сразу данные с Хабра.

340
00:23:49,554 --> 00:23:54,148
Второй раз я запросил, да, возвращается

341
00:23:54,148 --> 00:23:59,050
мне тут количество записей в rss и ошибка.

342
00:23:59,050 --> 00:24:02,603
Второй раз я запросил,
мне данные в memcache были,

343
00:24:02,603 --> 00:24:07,782
теперь я заинкременчу тег,
чтобы сбросить кэш.

344
00:24:07,782 --> 00:24:13,637
Обратите внимание, я сразу же
запустил асинхронное перестроение,

345
00:24:13,637 --> 00:24:18,529
тут будет немножко непонятно,
что к чему относится, ну ладно.

346
00:24:18,529 --> 00:24:24,733
Я запустил асинхронное перестроение и,
обратите внимание — тут нет записи,

347
00:24:24,733 --> 00:24:30,070
что record not found, значит,
она найдена, кэш не тот, и я делаю фетч.

348
00:24:30,070 --> 00:24:35,159
В то же время асинхронная запись,
асинхронное перестроение,

349
00:24:35,159 --> 00:24:41,402
оно пытается взять lock, и только после
этого, после того как оно дождется,

350
00:24:41,402 --> 00:24:46,550
когда кто-то отпустит запись,
оно пытается перестроить эту запись.

351
00:24:46,550 --> 00:24:48,457
Это тегированный кэш.

352
00:24:48,457 --> 00:24:53,221
Пример, конечно, сложный,
но зато тут демонстрируется

353
00:24:53,221 --> 00:24:57,109
довольно много возможностей самого языка.

354
00:24:57,109 --> 00:25:03,155
Сразу оговорюсь, именно этот код в
продакшене я никогда не использовал,

355
00:25:03,155 --> 00:25:09,508
это учебный пример,
подход рабочий, поэтому, возможно,

356
00:25:09,508 --> 00:25:15,190
вам стоит посмотреть на инвалидацию кэша,
немножко подобрать ее под себя.

357
00:25:15,190 --> 00:25:19,860
Например, если кэш не валиден,
то возвращать старые данные.

358
00:25:19,860 --> 00:25:25,270
Или, например, вы захотите
перестраивать кэш, просто запуская его,

359
00:25:25,270 --> 00:25:30,952
запуская функцию в отдельной горутине,
а те данные, которые есть,

360
00:25:30,952 --> 00:25:35,530
возвращать уже наверх, даже несмотря
на то, что они немножко устарели,

361
00:25:35,530 --> 00:25:38,540
вы будете просто знать,
что они там сейчас перестроятся.

362
00:25:38,540 --> 00:25:43,480
Вот пример использования memcache

363
00:25:43,480 --> 00:25:47,490
и еще куча возможностей Go.