1
00:00:00,000 --> 00:00:09,957
[БЕЗ_ЗВУКА] В этом видео
мы поговорим про RabbitMQ.

2
00:00:09,957 --> 00:00:13,650
Rabbit — это целая
платформа для построения,

3
00:00:13,650 --> 00:00:19,586
разного рода обмена
сообщениями и паттерна pub/sub,

4
00:00:19,586 --> 00:00:23,439
publisher-subscriber, ну
и разного рода очередей.

5
00:00:23,439 --> 00:00:27,000
Очередь — это очень частый
паттерн в системной архитектуре,

6
00:00:27,000 --> 00:00:31,778
который позволяет вынести разного
рода тяжелые операции из запроса

7
00:00:31,778 --> 00:00:36,364
пользователя в разного рода
оффлайн-скрипты, оффлайн-воркеры и

8
00:00:36,364 --> 00:00:40,469
не заставлять пользователя ждать,
пока завершится операция.

9
00:00:40,469 --> 00:00:45,078
Например, если пользователь загружает
видео, не будем же мы целый час его

10
00:00:45,078 --> 00:00:50,451
держать на связи,
крутя в него индикатор загрузки.

11
00:00:50,451 --> 00:00:54,671
Мы загрузим видео, положим его на диск
и скажем пользователю: ваше видео

12
00:00:54,671 --> 00:00:56,854
обрабатывается, подождите немножко.

13
00:00:56,854 --> 00:01:03,745
В это время видео попадает в очередь,
и когда до него доходит очередь,

14
00:01:03,745 --> 00:01:10,030
простите за тавтологию, уже другой скрипт,
другой процесс, который, скорее всего,

15
00:01:10,030 --> 00:01:13,920
работает даже на другом сервере,
начинает конвертировать это видео.

16
00:01:13,920 --> 00:01:17,222
В этом примере мы рассмотрим
операцию не такую тяжелую,

17
00:01:17,222 --> 00:01:21,090
как конвертация видео — мы будем
создавать превью для картинок.

18
00:01:21,090 --> 00:01:26,500
Давайте посмотрим сначала,
как это выглядит, а потом перейдем к коду.

19
00:01:26,500 --> 00:01:30,800
Итак, выберем изображение.

20
00:01:30,800 --> 00:01:34,022
У меня вот есть фотография.

21
00:01:34,022 --> 00:01:40,040
Загрузим и сразу же перейдем к просмотру
файлов, которые нам генерируются.

22
00:01:40,040 --> 00:01:42,628
Обратите внимание,
у меня файлы появляются один за другим,

23
00:01:42,628 --> 00:01:44,980
я специально там добавил задержку,
чтобы было видно.

24
00:01:44,980 --> 00:01:49,340
Вот получается,
что вот моя исходная загруженная картинка,

25
00:01:49,340 --> 00:01:51,816
а вот превьюшки разного размера,

26
00:01:51,816 --> 00:01:56,870
которые построились моим оффлайн-воркером

27
00:01:56,870 --> 00:02:01,682
для изменения размеров картинки.

28
00:02:01,682 --> 00:02:05,746
При этом обратите внимание,
что ответ мне дался сразу,

29
00:02:05,746 --> 00:02:08,140
сразу как только я загрузил картинку.

30
00:02:08,140 --> 00:02:13,890
Теперь рассмотрим код, в котором я
расскажу, каким образом все происходит.

31
00:02:13,890 --> 00:02:21,260
Для начала, для начала мы
выполняем подключение к Rabbit.

32
00:02:21,260 --> 00:02:25,023
Обратите внимание,
у меня вот здесь стоит равно — дело в том,

33
00:02:25,023 --> 00:02:30,377
что соединение к Rabbit у меня,
оно не локальная функция, она глобальная.

34
00:02:30,377 --> 00:02:34,433
Если я поставлю здесь точку с запятой,
то работать не будет,

35
00:02:34,433 --> 00:02:39,450
потому что создастся локальная
переменная в области видимости функции.

36
00:02:39,450 --> 00:02:44,368
И при попытке уже из другой функции
воспользоваться этим соединением,

37
00:02:44,368 --> 00:02:47,920
вы будете ловить панику,
потому что там nil внутри лежит.

38
00:02:47,920 --> 00:02:50,474
Такая проблема у людей бывает.

39
00:02:50,474 --> 00:02:53,885
Вот.
Создали соединение, все отлично.

40
00:02:53,885 --> 00:02:59,353
Теперь получаем канал,
с которым мы будем уже общаться с Rabbit.

41
00:02:59,353 --> 00:03:04,410
Попробуем определить там очередь
сообщений, которую мы хотим.

42
00:03:04,410 --> 00:03:08,151
Я не буду детально останавливаться на
параметрах, но просто если очереди нет,

43
00:03:08,151 --> 00:03:11,482
она создастся, если есть,
ничего не произойдет.

44
00:03:11,482 --> 00:03:12,082
Окей?

45
00:03:12,082 --> 00:03:18,915
Все, мы написали,
что очередь очередь создана,

46
00:03:18,915 --> 00:03:23,040
очередь имеет такое-то имя,
столько сообщений, столько консьюмеров.

47
00:03:23,040 --> 00:03:26,400
Вот эта строка,

48
00:03:26,400 --> 00:03:32,680
вот она — очередь создана,
там 0 сообщений и один консьюмер.

49
00:03:32,680 --> 00:03:37,888
Консьюмер — это мой оффлайн-воркер,
мой гошный сервис,

50
00:03:37,888 --> 00:03:42,991
который как раз таки принимает
эти задачи из очереди.

51
00:03:42,991 --> 00:03:47,530
Потом я стартанул сервер,
и вот пришло новое сообщение,

52
00:03:47,530 --> 00:03:49,296
которое я положил в очередь.

53
00:03:49,296 --> 00:03:51,920
Каким образом класть сообщение в очередь?

54
00:03:51,920 --> 00:03:57,780
Вернемся в нашу функцию,
тут есть много всякого интересного.

55
00:03:57,780 --> 00:04:03,736
Итак, для начала мы вычитаем
файл из ответа — напомню,

56
00:04:03,736 --> 00:04:06,345
что для этого у нас есть FormFile.

57
00:04:06,345 --> 00:04:10,480
Напечатаем какую-то информацию
на экран пользователю.

58
00:04:10,480 --> 00:04:14,419
Потом дело в том,

59
00:04:14,419 --> 00:04:20,326
что я не могу одновременно
сначала построить md5,

60
00:04:20,326 --> 00:04:24,425
потом построить еще что-то
— у меня нету еще имени.

61
00:04:24,425 --> 00:04:29,280
Использовать имя, которое передано
пользователям крайне небезопасно.

62
00:04:29,280 --> 00:04:32,980
Я генерирую случайную строку,
кладу во временный файл.

63
00:04:32,980 --> 00:04:35,326
Далее тут небольшой трюк.

64
00:04:35,326 --> 00:04:38,386
Я хочу одновременно в один проход,

65
00:04:38,386 --> 00:04:43,953
в одно чтение построить и md5 от файла,
и записать Fn на диск.

66
00:04:43,953 --> 00:04:46,604
Для этого есть TeeReader,

67
00:04:46,604 --> 00:04:52,473
куда можно передать еще один ридер,
куда дополнительно будет писаться.

68
00:04:52,473 --> 00:04:56,590
И, получается, в один проход я и
пишу файл, и строю хэш по нему.

69
00:04:56,590 --> 00:05:01,730
Так, окей, далее мы пишем
непосредственно файл на диск,

70
00:05:01,730 --> 00:05:08,140
флашим все, строим md5,
переименовываем картинку по реальному md5.

71
00:05:08,140 --> 00:05:13,871
Теперь создаем задачу: имя файла,

72
00:05:13,871 --> 00:05:18,404
md5 от этого файла,
чтобы знать к какому файлу обратиться.

73
00:05:18,404 --> 00:05:22,190
В реальной жизни у вас, скорее всего,
в эту задачу войдет адрес,

74
00:05:22,190 --> 00:05:26,445
куда была загружена картинка,
чтобы ваш фреймворк знал, куда идти,

75
00:05:26,445 --> 00:05:29,610
на каком хранилище сохранена она.

76
00:05:29,610 --> 00:05:33,132
Либо еще какая-то
дополнительная информация.

77
00:05:33,132 --> 00:05:35,477
Вот.
Дальше я ввожу сообщение,

78
00:05:35,477 --> 00:05:36,901
которое вы видели.

79
00:05:36,901 --> 00:05:45,222
И теперь теперь я уже публикую
это сообщение в мой в Rabbit.

80
00:05:45,222 --> 00:05:49,034
Собственно, я говорю,
в каком виде его доставить,

81
00:05:49,034 --> 00:05:51,760
какие там данные лежат, какое тело.

82
00:05:51,760 --> 00:05:58,043
Обратите внимание: rabbitChan
— это канал общения с Rabbit,

83
00:05:58,043 --> 00:06:02,720
это не канал, не гошный канал,
который для общения с горутинами.

84
00:06:02,720 --> 00:06:03,555
Ага, хорошо.

85
00:06:03,555 --> 00:06:05,871
Я опубликовал сообщение, все туда ушло.

86
00:06:05,871 --> 00:06:10,336
То есть, обратите внимание: я в
пользовательском запросе просто положил

87
00:06:10,336 --> 00:06:12,390
файл на диск и не я пережимал его.

88
00:06:12,390 --> 00:06:14,334
Я его, как есть, положил и все.

89
00:06:14,334 --> 00:06:18,520
И отправил сообщение в очередь,
что вот этот вот файл нужно пережать.

90
00:06:18,520 --> 00:06:21,740
Теперь рассмотрим очередь.

91
00:06:21,740 --> 00:06:27,086
Рассмотрим воркера,
который получает сообщение из очереди.

92
00:06:27,086 --> 00:06:30,230
Итак, там, ага.

93
00:06:30,230 --> 00:06:32,020
Вот он.

94
00:06:32,020 --> 00:06:34,308
Да, вот логи, смотрим логи.

95
00:06:34,308 --> 00:06:39,232
То есть worker started получил сообщение,
и вот вся информация,

96
00:06:39,232 --> 00:06:41,600
которая есть в этом сообщении.

97
00:06:41,600 --> 00:06:43,357
Так.

98
00:06:43,357 --> 00:06:46,356
Начинаем мы,

99
00:06:46,356 --> 00:06:49,706
как всегда с подключения к Rabbit — мы не
можем им пользоваться, не подключившись,

100
00:06:49,706 --> 00:06:54,107
либо [НЕРАЗБОРЧИВО], к сожалению,
подтягивается только из астрала.

101
00:06:54,107 --> 00:06:59,015
Так, опять получаем канал,
определяем очередь, устанавливаем,

102
00:06:59,015 --> 00:07:03,593
какое количество сообщений
мы хотим префечить,

103
00:07:03,593 --> 00:07:09,314
то есть подтягивать из
очереди просто в свою буфер,

104
00:07:09,314 --> 00:07:12,390
для того чтобы быстро их обрабатывать.

105
00:07:12,390 --> 00:07:16,520
Теперь получаем

106
00:07:16,520 --> 00:07:21,822
канал уже,
из которого мы будем читать сообщения,

107
00:07:21,822 --> 00:07:26,377
то есть в данном случае tasks — это
будет уже гошный канал, гошный канал.

108
00:07:26,377 --> 00:07:31,400
И по нему мы можем итерироваться уже,
используя for range или select.

109
00:07:31,400 --> 00:07:37,456
И в отдельной горутине я вызываю воркера,

110
00:07:37,456 --> 00:07:43,662
чтобы, собственно,
он работал над моими тасками.

111
00:07:43,662 --> 00:07:51,031
При этом я, конечно же, могу вызвать много
воркеров, я могу написать цикл от 1 до 10,

112
00:07:51,031 --> 00:07:57,372
например: := 0; i<+ 10; i++.

113
00:07:57,372 --> 00:08:02,427
И вот таким вот нехитрым
образом мы сразу же получили

114
00:08:02,427 --> 00:08:07,093
10 воркеров,
то есть мы смасштабировали нашу программу.

115
00:08:07,093 --> 00:08:12,878
Если у нас 10 ядер в процессоре,
то 10 воркеров займут все эти ядра.

116
00:08:12,878 --> 00:08:17,982
Картинки все-таки — операция,
которая сильно грузит процессор.

117
00:08:17,982 --> 00:08:18,670
Вот так.

118
00:08:18,670 --> 00:08:22,120
Так, допустим, вот начали воркера делать.

119
00:08:22,120 --> 00:08:27,996
Теперь мы просто итерируемся по этому
каналу, напоминаю, через for range.

120
00:08:27,996 --> 00:08:33,362
Я получаю какой-то таск — taskItem,
далее я распаковываю его.

121
00:08:33,362 --> 00:08:36,700
У меня в таске есть тело этого сообщения.

122
00:08:36,700 --> 00:08:41,342
Распаковываюсь, и не получилось —
сразу возвращаю его обратно в очередь,

123
00:08:41,342 --> 00:08:43,390
либо могу сказать, что просто удалить.

124
00:08:43,390 --> 00:08:48,261
А теперь я строю путь,

125
00:08:48,261 --> 00:08:52,390
который оригинальный, временный путь,
куда я положил данные.

126
00:08:52,390 --> 00:08:58,012
И теперь для нескольких размеров картинок
я буду вызывать функцию ResizeImage,

127
00:08:58,012 --> 00:09:01,269
куда буду передавать оригинальный путь,
новый путь для картинки и размер,

128
00:09:01,269 --> 00:09:02,330
который нужно создать.

129
00:09:02,330 --> 00:09:02,912
Все.

130
00:09:02,912 --> 00:09:07,696
То есть фактически,
посмотрите: задача сводится

131
00:09:07,696 --> 00:09:11,650
буквально к тому,
чтобы просто читать из канала.

132
00:09:11,650 --> 00:09:14,380
То есть если бы это было на одном сервере,

133
00:09:14,380 --> 00:09:17,270
я мог бы обойтись
каналами внутри Go прямо.

134
00:09:17,270 --> 00:09:25,174
И, действительно, картинки пережимались
бы в фоне от пользовательских запросов.

135
00:09:25,174 --> 00:09:29,228
Но в реальность, если у вас есть
потребность пережимать картинки через

136
00:09:29,228 --> 00:09:34,165
очередь, скорее всего, этих картинок у
вас много, серверов у вас тоже много.

137
00:09:34,165 --> 00:09:39,068
И вы не можете себе позволить
такую роскошь как грузить сервера,

138
00:09:39,068 --> 00:09:43,447
которые обрабатывают пользовательские
запросы, еще и ресайзом картинок.

139
00:09:43,447 --> 00:09:46,210
Поэтому это выносится на отдельный сервер.

140
00:09:46,210 --> 00:09:47,979
Собственно, вот и все.

141
00:09:47,979 --> 00:09:51,270
Еще можно рассмотреть функцию ResizeImage.

142
00:09:51,270 --> 00:09:56,810
Я использую внешнюю библиотеку,
я также открываю картинку,

143
00:09:56,810 --> 00:10:01,032
вычитываю файл jpeg,

144
00:10:01,032 --> 00:10:06,775
получаю структуру «картинка
из стандартной библиотеки».

145
00:10:06,775 --> 00:10:10,960
И использую функцию Resize — это уже,
к сожалению внешняя библиотека.

146
00:10:10,960 --> 00:10:16,640
И сохраняю ее по новому пути,
который мне передался.

147
00:10:16,640 --> 00:10:21,528
Вот и все, буквально в несколько
сотен строчек мы получили систему,

148
00:10:21,528 --> 00:10:28,820
которая принимает пользовательские
запросы, кладет их в очередь и в оффлайне,

149
00:10:28,820 --> 00:10:33,980
то есть каким-то внешним сервисом, уже
выполняет операции над этими запросами.

150
00:10:33,980 --> 00:10:37,130
И в этом нам помог Rabbit.