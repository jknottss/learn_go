[НЕТ_ЗВУКА] В этом видео мы поговорим про
использование MongoDB в Go. MongoDB относится к
классу Document storage, то есть это уже не SQL-система,
скорее это поколение no-SQL. Mongo примечательно тем,
что в базе данных, которая там есть, нет схемы никакой. Все данные хранятся в виде BSON —
это байнари такой бинарный JSON. То есть вы можете добавлять туда
любые поля, удалять любые поля, при этом вы можете по полям,
которые там есть, строить индекс. В целом, если у вас очень
много различных атрибутов, которые абсолютно новые
для разных записей, то MongoDB вполне видится вариантом. Рассмотрим, как работать с Mongo. Вот уже знакомая вам страница. Единственное, что вместо
красивого автоинкрементного ID тут монговский встроенный Object ID. Автоинкремента там из коробки нету,
но есть сторонний модуль, и можно доставить и будет
тоже автоинкремент. Поэтому я везде передаю
его прямо в хэш виде. Попробуем добавить новую запись. Отлично. Submit — и вот добавилась
моя запись новая. Опять редактирование,
видим хэш еще какой-то другой, и теперь rvasily прописался
после апдейта уже. Посмотрим код. хм... Mongo — это, как я уже говорил, не SQL. То есть драйвер может
быть совсем не похож, а может быть и похож на то, что вы видели. Для начала коннектимся к хосту, создаем
сессию, я коннекчусь к локал-хосту. Дальше я коннекчусь к базе. Причем, если нету,
то там вам все автоматически создастся. Создаю там коллекцию айтемов. В Mongo нету красивого такого дампа,
как в SQL, который я показал — и было все хорошо. Поэтому я просто изначально проверяю,
сколько записей в коллекции, если там нет, я создаю какие-то демо-данные,
просто делаю insert. По сравнению с предыдущей записью, у нас
есть уже знакомая вам структура — item, однако, objectID тут теперь уже не не int, который автоинкрементится,
а bson objectID. И в bson'е прописано спецполе,
что подчеркивание id там это как раз-таки означает id'шник. Отлично. Я создам две записи. Я просто создаю объект и делаю insert. Теперь я сразу в handler передаю уже
не сессию, а уже конкретную коллекцию. И теперь рассмотрим все основные операции. Выбрать все. Я воспользуюсь методом find,
передам туда пустой bson. M — это message, ну и выберу все, что мне нашлось по этому критерию
и запишу это в мой слайс item'ов. Дальше вам уже знакомо: экспайтим шаблон,
передаем туда наши item'ы. Добавляем. В отличие от SQL, когда вы можете передать
пустую строку в автоинкрементное поле, тут так нельзя, поэтому я изначально
создаю запись и делаю insert. Или можно попробовать заинсертить
по-другому, например, вот так. [НЕТ_ЗВУКА] bson M Поля — но теперь это уже должны быть поля которые называются так, как у меня они мапятся на структуру. И я могу создать теперь вот таким образом. Давайте перезапустим программу. [НЕТ_ЗВУКА] [НЕТ_ЗВУКА] [НЕТ_ЗВУКА] Запустилось. Создадим еще раз — так. Submit. И добавился мой новый item. То есть я уже не привязан
к жесткой структуре, я могу добавлять тут любые поля. Я могу, например, сделать вот так. И это поле действительно добавится. Естественно, когда я выбираю, я тоже могу
выбирать сразу в bson, а не в структуру, которая у меня есть, и получать значения. Это удобно, если у вас очень много
динамики, но порой это бывает тяжело поддерживать, когда схемы нет,
и оно все разлезается. Поэтому все-таки я предпочитаю
иметь дело со структурами. То есть инсертить можно
сразу отдельную структуру, можно создать bson руками
и заинсертить его. Update. Редактирование. Основное, что нужно знать: если
я попытаюсь получить objectIDHex от какой-то неправильной строки,
то будет паника. Поэтому вначале проверяем, действительно
ли айдишник, который я передал, он действительно валидный,
он действительно это objectIDHex, и только после этого я создаю уже
нужную мне структуру, и делаю find. Ранее у нас был для поиска всех вот
такой запрос, теперь — вот такой. То есть я указываю поле,
id и указываю значение. Я выбираю единичную запись, кладу ее в пост и передаю
дальше в шаблон для экспанда. Update — собственно, все просто. Так же как insert вы можете
заапдейтить следующим образом, то есть передать туда уже структуру. Либо же вы можете передать туда
абсолютно произвольный JSON, который заапдейтит все данные. Единственное, что... будьте аккуратны. Если напишете вот так, то это будет
уже совершенно другое поле, не то, которое мапится в вашу структуру. Update. То есть тоже все резиновое,
вот можно добавить новое поле. Удаление. Тут мы тоже проверяем,
действительно ли это objectIDHex, и вызываем метод Remove, куда передаем
опять-таки bson с номером поля. Вот все. То есть Mongo, конечно, не похоже на работу с SQL в чистом виде. Однако, если вы использовали, например, Gorun, то более-менее похоже.