[БЕЗ_ЗВУКА] В предыдущем видео мы рассматривали,
каким образом можно руками работать с SQL. Иногда это бывает очень неудобно, особенно когда у нас в какой-то админке
нужно много-много обновлять записи. Поэтому возникает желание
сделать какую-то обертку, которая будет при помощи какой-то
магии скрывать от нас всю эту работу и, короче, обновлять все это,
используя просто одну функцию. Да, такая возможность есть в Go — при
помощи внешних библиотек, конечно. Работают они так же,
как encoding/json: либо через рефлексию, либо через кодогенерацию. Через рефлексию это будет гибче,
но это будет какой-то небольшой overhead. Через кодогенерацию будет быстрее, но на каждое изменение
нужно будет перезапускать. Какие еще есть недостатки
у такого подхода? Почему query-билдеры вообще не заполонили весь мир и мы еще пишем
иногда SQL-запрос руками? Дело в том, что SQL — он очень гибок, вы можете там делать подзапросы,
какие-то делать очень хитрые джойны. ORM и Active Record и прочее и
прочее — они этого всего не умеют. То есть, скорее всего, вы упретесь в то, что вы банально не сможете сделать то,
что вы хотите, используя, короче, эту обертку,
и вам все равно придется писать руками. Либо это будет огромное
количество костылей, и быстрее все равно будет написать руками. Итак, в этом видео мы
рассмотрим библиотеку gorm, которая как оборачивает
всю работу SQL в себя. Смотрим код. Начнем с подключения. Вызываем gorm.Open,
который подключается через MySQL. Внутри себя он оборачивает все тот же SQL,
но уже создает свою базу. Вот эта первая db — это db орма. Дальше я подключаюсь уже и пингую. Вот. То есть изменений не очень много —
изменили одну строчку на другую. А теперь давайте смотреть,
как выбирать записи и с ними работать. Сначала выбираем. Я хочу найти просто все записи. Я обращаюсь к db, и говорю Find, и туда передаю слайс-структуру,
куда мне все это записать. Вот все. Если раньше мне нужно было писать
SQL-запрос, что-то выбирать, потом еще распаковывать это руками,
то вот одна простая функция. Правда, она выберет все, вообще все. И если там будут какие-то очень поля
тяжелые, то она их тоже выберет. Поэтому нужно это дело
как-то ограничивать. Окей. Создание записи. Создаем структуру и вызываем метод Create,
куда передаем новосозданную структуру. Вот. Теперь каким образом нам
получить RowsAffected и LastId. LastId сразу запишется в поле нужное. Да, я пометил при помощи тегов структуры, что это SQL-автоикремент, что для горма
это primary_key, что вот, пожалуйста, в это поле LastId записать нужно. Updated — я пометил, что это поле может
быть null, на это не надо падать, он его корректно запишет. Да, вы тут получите пустую строку,
если там был null. Там есть много вариантов. Да, еще возможность указать таблицу,
то есть переопределить таблицу для этой структуры, и навешать разные триггер,
в данном случае, например, этот триггер будет вызван
пересохранением результата. Итак, поехали дальше: Create. Передаем туда новую структуру, нам возвращается каждая из этих
функций: Create, Find и прочее. Она возвращает нам объект горма, но в текущем [НЕРАЗБОРЧИВО],
которым мы его вызвали. Что это значит? Из него мы можем получить
Error и RowsAffected. То есть нам же нужно узнать,
что там что-то пошло не так, база отвалилась внезапно. Поэтому RowsAffected можно получить
вот так, а Id сразу запишется. То есть кода стало поменьше,
он стал попроще. Редактирование. Вот таким образом я могу найти одну
запись: Find и пожалуйста — указываю, куда мне это записать и
какой Id мне нужно найти. И также я проверяю ошибки, проверяю на то,
что запись не найдена, и все. То есть раньше я руками указывал все поля,
доставал, распаковывал. Здесь — нет, все проще. Update, то же самое — Update. Единственное что — я сначала
достаю эту структуру, чтобы какие-то поля не перезаписать,
потом обновляю нужные мне поля, и потом вызываю функцию Save. Все. Удаление — тоже функция Delete,
куда я передаю структуру, уже структуру, уже не единичное поле,
не просто идентификатор, а структуру, чтобы gorm знал,
вообще из какой таблицы это удалять. Вот.
Это были очень простые операции — у горма возможностей гораздо-гораздо больше. Он может и джойны делать, и валидацию
проверять, и триггеров у него много. Но вам приходится платить
за — как я уже говорил, вы получите небольшой
overhead на рефлексию, за счет которой все это выполняется. Также вы где-то будете выбирать
лишние поля и где-то вы не сможете вообще выполнить средствами самого горма
запрос — вам придется писать его руками. Но в случае если какая-то более-менее
простая админка и вы просто часто апдейтите записи, это может быть
вполне подходящим вариантом для работы. Но для хай-лоада я всегда
предпочту писать запросы руками.