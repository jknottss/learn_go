1
00:00:00,000 --> 00:00:06,830
[БЕЗ_ЗВУКА] В этом видео мы

2
00:00:06,830 --> 00:00:11,860
будем рассматривать, каким образом можно
работать с SQL базами данных и с Go.

3
00:00:11,860 --> 00:00:15,162
Для начала посмотрим на эту страницу.

4
00:00:15,162 --> 00:00:19,359
Тут мы видим простой список
каких-то элементов с

5
00:00:19,359 --> 00:00:23,987
возможностью создания новых,
редактирования и удаления.

6
00:00:23,987 --> 00:00:28,710
Все это в данном уроке реализовано
через MySQL, для Postgres отличия будут

7
00:00:28,710 --> 00:00:33,503
очень незначительные, и файлы для него
вы можете найти в файлах к уроку.

8
00:00:33,503 --> 00:00:37,440
Итак, сначала посмотрим на схему данных.

9
00:00:37,440 --> 00:00:44,670
Вот у нас есть таблица, items: есть id,
title, desctiption и поле updated.

10
00:00:44,670 --> 00:00:49,410
Обратите внимание,
что поле updated у нас может быть NULL.

11
00:00:49,410 --> 00:00:53,125
Это важный момент,
про это я буду рассказывать.

12
00:00:53,125 --> 00:00:55,520
И ставим несколько элементов.

13
00:00:55,520 --> 00:01:02,882
Хорошо, схема базы простая,
ничего сложного в ней нету.

14
00:01:02,882 --> 00:01:08,050
Теперь просмотрим, каким образом
начать работать с этим с кода.

15
00:01:08,050 --> 00:01:14,279
В стандартной библиотеке Go нету
встроенного драйвера никакого,

16
00:01:14,279 --> 00:01:19,250
однако авторы стандартной библиотеки
поступили очень мудро и сделали интерфейс.

17
00:01:19,250 --> 00:01:23,040
Называется он database/sql.

18
00:01:23,040 --> 00:01:27,930
И этот интерфейс уже могут
реализовывать разные базы данных,

19
00:01:27,930 --> 00:01:33,980
за счет чего вы сможете более или
менее одинаково работать с MySQL,

20
00:01:33,980 --> 00:01:39,700
Postgres, Oracle,
SQL и какими-нибудь другими базами данных.

21
00:01:39,700 --> 00:01:45,075
То есть для того чтобы использовать SQL,
вам нужно подрубить его для начала.

22
00:01:45,075 --> 00:01:51,175
Теперь я подключаю драйвер,
в данном случае это драйвер MySQL.

23
00:01:51,175 --> 00:01:55,230
Обратите внимание: я подключаю его
с использованием пустой переменной.

24
00:01:55,230 --> 00:01:56,654
Для чего это надо?

25
00:01:56,654 --> 00:02:01,015
Дело в том, что сам драйвер
он не экспортирует, по сути,

26
00:02:01,015 --> 00:02:05,485
никакие функции,
и я не буду им пользоваться в коде.

27
00:02:05,485 --> 00:02:08,590
Я буду пользоваться везде
через database/sql.

28
00:02:08,590 --> 00:02:13,348
Однако драйвер внутри себя
через функцию init регистрирует

29
00:02:13,348 --> 00:02:16,731
обработчик MySQL,
который будет вызван далее.

30
00:02:16,731 --> 00:02:21,470
Но подчеркивание, чтобы компилятор Go
не ругался на неиспользуемый пакет.

31
00:02:21,470 --> 00:02:22,363
Вот.

32
00:02:22,363 --> 00:02:27,740
И рассматривать мы будем наш item,

33
00:02:27,740 --> 00:02:33,270
который мапится из строчки MySQL
вот в такую структуру: есть id,

34
00:02:33,270 --> 00:02:38,200
title, description и поле updated,
которое представлено каким-то

35
00:02:38,200 --> 00:02:41,712
полем NullString,
об этом я буду рассказывать.

36
00:02:41,712 --> 00:02:44,400
Итак, теперь начнем с подключения к базе.

37
00:02:44,400 --> 00:02:49,830
Подключение к базе
осуществляется через формат dsm.

38
00:02:49,830 --> 00:02:54,987
Итак, имя пользователя,
тут может быть пароль, например,

39
00:02:54,987 --> 00:03:00,750
потом формат, по которому мы подключаемся
— может быть TCP, может быть UNIX-сокет.

40
00:03:00,750 --> 00:03:04,170
Собственно, адрес сервера
и имя базы данных.

41
00:03:04,170 --> 00:03:08,939
Теперь я указываю уже в
параметрах — по сути,

42
00:03:08,939 --> 00:03:12,070
это query-параметры, charset-кодировка.

43
00:03:12,070 --> 00:03:17,690
И параметр interpolateParams,
который отключит не prepare a statement,

44
00:03:17,690 --> 00:03:22,825
а будет сразу подставлять
параметры в [НЕРАЗБОРЧИВО].

45
00:03:22,825 --> 00:03:25,506
Окей, я создал строчку для подключения.

46
00:03:25,506 --> 00:03:28,990
Теперь я подключаюсь — обратите внимание,
я не использую ни MySQL, ничего.

47
00:03:28,990 --> 00:03:33,960
Я использую функцию SQL из пакета
database/sql, там использую Open.

48
00:03:33,960 --> 00:03:38,967
И вот тут уже я указываю MySQL,
то есть я говорю, что мне,

49
00:03:38,967 --> 00:03:43,464
пожалуйста, подключись к этой базе данных,
используя вот этот обработчик.

50
00:03:43,464 --> 00:03:45,319
Окей, подключились.

51
00:03:45,319 --> 00:03:48,480
Следующая строка: SetMaxOpenConns.

52
00:03:48,480 --> 00:03:52,005
Что это такое и зачем это надо?

53
00:03:52,005 --> 00:03:56,362
Дело в том, что MySQL имеет
полностью синхронный протокол,

54
00:03:56,362 --> 00:04:00,420
то есть пока один запрос не отработал, вы
не можете отправлять туда никакой другой.

55
00:04:00,420 --> 00:04:05,840
Для того чтобы в Go как-то с этим
работать, отправлять много запросов,

56
00:04:05,840 --> 00:04:09,387
внутри там создается
несколько подключений.

57
00:04:09,387 --> 00:04:15,379
И как раз количество этих подключений,
оно регулируется вот этим методом.

58
00:04:15,379 --> 00:04:21,530
Теперь выполним пингование нашей
базы данных, то есть подключимся.

59
00:04:21,530 --> 00:04:26,610
sql.Open — он не создает
подключения сразу,

60
00:04:26,610 --> 00:04:30,372
он только инициализирует сам объект,

61
00:04:30,372 --> 00:04:35,590
а уже db.Ping уже реально
подключается к базе данных.

62
00:04:35,590 --> 00:04:39,770
Поэтому если там случится ошибка,
она случится вот здесь.

63
00:04:39,770 --> 00:04:44,668
Например, логин-пароль неправильный,
либо база недоступна.

64
00:04:44,668 --> 00:04:46,170
Так, идем далее.

65
00:04:46,170 --> 00:04:50,575
Я использовал Gorilla mux-роутер,

66
00:04:50,575 --> 00:04:54,980
для того чтобы удобно обрабатывать get,
post, delete-запросы.

67
00:04:54,980 --> 00:04:59,815
Я создаю handler,
туда передаю базу данных,

68
00:04:59,815 --> 00:05:04,535
туда передаю шаблоны, с которыми
буду работать, чтобы не использовать

69
00:05:04,535 --> 00:05:10,081
глобальные переменные — у меня
в рамках одного вот хендлера.

70
00:05:10,081 --> 00:05:10,937
Отлично.

71
00:05:10,937 --> 00:05:15,673
Регистрация хендлеров — тут
ничего сложного нету, какие-то

72
00:05:15,673 --> 00:05:19,000
методы доступны через get, какие-то
— через post, и один — через delete.

73
00:05:19,000 --> 00:05:21,743
Можно было бы обойтись
меньшим количеством,

74
00:05:21,743 --> 00:05:27,254
просто зарегистрировав один
метод для любого типа,

75
00:05:27,254 --> 00:05:33,116
но в этом примере будем
использовать прямо по отдельности.

76
00:05:33,116 --> 00:05:34,010
Хорошо.

77
00:05:34,010 --> 00:05:36,030
Рассмотрим список.

78
00:05:36,030 --> 00:05:40,150
Вот у меня есть несколько элементом,
есть поле edited.

79
00:05:40,150 --> 00:05:43,800
Как его вывести,
как вообще сделать select в базу?

80
00:05:43,800 --> 00:05:47,660
Начинаем, смотрим.

81
00:05:47,660 --> 00:05:54,924
Для начала я создаю слайс своих
объектов для общего списка.

82
00:05:54,924 --> 00:05:59,823
Теперь, смотрите: я обращаюсь к объекту DB

83
00:05:59,823 --> 00:06:04,272
в моем хендлере — вот он объект,
DB вот здесь.

84
00:06:04,272 --> 00:06:09,990
И я выполняю метод Query,
он принимает в себя первым аргументом

85
00:06:09,990 --> 00:06:14,770
SQL-запрос, в котором
могут быть плейсхолдеры,

86
00:06:14,770 --> 00:06:19,230
и следующими аргументами — уже
значения для плейсхолдеров.

87
00:06:19,230 --> 00:06:23,466
В данном случае этого нету,
мы это посмотрим позже.

88
00:06:23,466 --> 00:06:29,500
Так, отлично, нам вернулись наши строки,
теперь мы по ним проитерируемся.

89
00:06:29,500 --> 00:06:34,480
И теперь, чтобы распаковать из
бинарного формата MySQL, у rows,

90
00:06:34,480 --> 00:06:38,790
моего объекта, есть функция Scan.

91
00:06:38,790 --> 00:06:44,286
В Scan вам надо передать ваши

92
00:06:44,286 --> 00:06:49,364
параметры, в которые будет
распаковано это значение.

93
00:06:49,364 --> 00:06:52,300
Соответственно, значение
должно быть подходящего типа.

94
00:06:52,300 --> 00:06:58,290
Id — это int, Title — это string,
а вот Updated,

95
00:06:58,290 --> 00:07:02,490
Updated — он у нас имеет тип NullString.

96
00:07:02,490 --> 00:07:04,170
Зачем это надо?

97
00:07:04,170 --> 00:07:08,630
Я вам напомню,
что поле Updated у нас может иметь внутри,

98
00:07:08,630 --> 00:07:11,547
то есть там может не прийти значение.

99
00:07:11,547 --> 00:07:16,407
Поэтому, когда Scan попытается его
распаковать, там будет внутри nil.

100
00:07:16,407 --> 00:07:19,580
И если я nil попробую присвоить в строку,
будет ошибка.

101
00:07:19,580 --> 00:07:25,170
Соответственно, нужен способ,

102
00:07:25,170 --> 00:07:29,440
каким образом можно проверять,
есть ли там значение NULL или нет.

103
00:07:29,440 --> 00:07:33,436
В пакете database/sql есть NullString,

104
00:07:33,436 --> 00:07:38,822
NullInt и еще несколько полей,
которые имеют

105
00:07:38,822 --> 00:07:44,517
поле Valid, в котором находится
булевый флаг — там NULL или не NULL,

106
00:07:44,517 --> 00:07:49,440
— и уже String, который нам будет
говорить, какое там реальное значение.

107
00:07:49,440 --> 00:07:52,615
Можно обойтись другим способом,

108
00:07:52,615 --> 00:07:57,792
можно сделать вот так, и тогда вы
тоже сможете его успешно распаковать,

109
00:07:57,792 --> 00:08:02,410
потому что если там будет nil, оно
спокойно в nil присвоится и тут будет nil.

110
00:08:02,410 --> 00:08:03,359
Все честно.

111
00:08:03,359 --> 00:08:04,566
Итак, хорошо.

112
00:08:04,566 --> 00:08:10,400
Мы распаковали, ошибки у нас нет,
добавили в общий список.

113
00:08:10,400 --> 00:08:15,655
В данном случае в данном примере
я пользуюсь небольшим хелпером,

114
00:08:15,655 --> 00:08:20,254
который у меня паникует на каждую ошибку,
но это сделано просто для упрощения кода.

115
00:08:20,254 --> 00:08:22,780
Вы так не делайте,
обрабатывайте все ошибки нормально.

116
00:08:22,780 --> 00:08:23,685
Хорошо.

117
00:08:23,685 --> 00:08:29,720
Теперь, когда я полностью вычитал
все записи из из запроса своего,

118
00:08:29,720 --> 00:08:32,260
мне обязательно нужно его закрыть.

119
00:08:32,260 --> 00:08:35,930
Если мы не будем его закрывать,
то начнет течь.

120
00:08:35,930 --> 00:08:39,197
Поэтому всегда про это думайте.

121
00:08:39,197 --> 00:08:46,361
Окей, ну и дальше я делаю expand шаблона,
для того чтобы показать вам это.

122
00:08:46,361 --> 00:08:49,120
Собственно, вот результат.

123
00:08:49,120 --> 00:08:55,510
Обратите внимание: edited есть
у одного поля, у поста № 2,

124
00:08:55,510 --> 00:09:01,755
вот этого — edited нету,
там на самом деле внутри находится NULL.

125
00:09:01,755 --> 00:09:08,840
То есть поле Valid у у String — оно
выставлено на false, я его не вывожу.

126
00:09:08,840 --> 00:09:14,330
С NULL-полями, конечно,
немножко замороченно работать.

127
00:09:14,330 --> 00:09:18,804
Вот простой SQL-запрос,
который мы вычитываем.

128
00:09:18,804 --> 00:09:24,221
Конечно, вы можете использовать не не
поля структуры, а какие-то временные

129
00:09:24,221 --> 00:09:28,584
переменные, которые вы можете создавать
прямо здесь, но это не очень важно.

130
00:09:28,584 --> 00:09:34,861
Вот.
Теперь попробуем добавить запись: New,

131
00:09:34,861 --> 00:09:38,846
и у меня есть два поля для ввода.

132
00:09:38,846 --> 00:09:43,890
Например, test, example description.

133
00:09:43,890 --> 00:09:49,090
Нажимаем Submit,
поле у нас появилось за номером 3.

134
00:09:49,090 --> 00:09:51,850
Рассмотрим, как это происходит.

135
00:09:51,850 --> 00:09:56,946
Просто пока с формой тут работы с SQL нет,

136
00:09:56,946 --> 00:10:00,979
я просто сразу Отлично,

137
00:10:00,979 --> 00:10:06,544
теперь как сделать insert.

138
00:10:06,544 --> 00:10:12,650
Через функцию query не получится,
она возвращает нам данные.

139
00:10:12,650 --> 00:10:18,930
Для работы с insert,
update есть функция exec.

140
00:10:18,930 --> 00:10:23,950
Я туда передаю, собственно, мой sql-запрос

141
00:10:23,950 --> 00:10:29,985
и передаю прямо сразу,
как пришло несколько значений.

142
00:10:29,985 --> 00:10:33,530
Обратите внимание,
я использую placeholder, знак вопроса.

143
00:10:33,530 --> 00:10:39,530
Значение туда будет сразу
поставлено с нужным эскейпингом.

144
00:10:39,530 --> 00:10:44,306
В данном примере я не делаю никакой
валидации, нет ни авторизации,

145
00:10:44,306 --> 00:10:50,998
защиты от серф-токенов, вам они,
конечно же, в продакшене будут нужны.

146
00:10:50,998 --> 00:10:56,098
Итак, exec, поле для insert,
поле раз — вот для этого placeholder,

147
00:10:56,098 --> 00:10:58,670
поле два — вот для этого placeholder.

148
00:10:58,670 --> 00:11:03,980
Идем прямо из формы, то что нам пришло.

149
00:11:03,980 --> 00:11:09,612
Окей, RowsAffected —
это количество записей,

150
00:11:09,612 --> 00:11:12,070
с которыми было какое-то обновление,

151
00:11:12,070 --> 00:11:16,540
LastInsertId сразу можно
выгрести из result,

152
00:11:16,540 --> 00:11:21,760
и сразу мы получим номер вставленной
записи, ну а дальше я делаю redirect.

153
00:11:21,760 --> 00:11:26,930
То есть ничего сложного, никакой магии.

154
00:11:26,930 --> 00:11:30,850
Теперь редактирование записи.

155
00:11:30,850 --> 00:11:34,425
Допустим, у меня есть тест,

156
00:11:34,425 --> 00:11:39,120
я жму edit и попробую
сделать что-нибудь такое.

157
00:11:39,120 --> 00:11:46,443
[БЕЗ_ЗВУКА] Я

158
00:11:46,443 --> 00:11:50,848
попробую ввести туда какой-то
тег и посмотрим, что получится.

159
00:11:50,848 --> 00:11:56,831
Нажимаем submit, и обратите внимание
— у нас это не превратилось в тег.

160
00:11:56,831 --> 00:11:58,150
Почему так?

161
00:11:58,150 --> 00:12:05,176
Template html автоматически
делает эскейпинг,

162
00:12:05,176 --> 00:12:09,010
это шаблонизатор, который учитывает
контекст, в котором вы вводите переменную,

163
00:12:09,010 --> 00:12:13,220
поэтому в данном случае,
если бы я использовал текст html,

164
00:12:13,220 --> 00:12:16,591
тут был бы тег,
и было бы подсвечено жирным.

165
00:12:16,591 --> 00:12:24,324
Ну хорошо, я обновил запись,
то есть я выбрал какую-то запись,

166
00:12:24,324 --> 00:12:29,911
мне нужно выбрать сначала ее из базы,
чтобы подставить форму.

167
00:12:29,911 --> 00:12:31,929
Как выбирается?

168
00:12:31,929 --> 00:12:33,680
Да все просто.

169
00:12:33,680 --> 00:12:37,659
Обратите внимание на url items 3,

170
00:12:37,659 --> 00:12:42,837
то есть у меня прямо параметры
использованы через переменные роутера,

171
00:12:42,837 --> 00:12:49,858
получаю ее через mux.Vars и конвертирую
в id, ну так, на всякий случай.

172
00:12:49,858 --> 00:12:56,488
Выбираю запись,
используя уже не query, а QueryRow.

173
00:12:56,488 --> 00:13:01,363
QueryRow сам за меня выберет эту запись,
закроет connect, все хорошо,

174
00:13:01,363 --> 00:13:04,490
то есть QueryRow нужен для
работы с единичными записями.

175
00:13:04,490 --> 00:13:07,441
Я перечислил поля,
я указал один placeholder и,

176
00:13:07,441 --> 00:13:11,547
собственно, значение
для этого placeholder.

177
00:13:11,547 --> 00:13:17,876
Отсканировал их все в переменную моей
структуры и передал ее уже в форму.

178
00:13:17,876 --> 00:13:21,110
Опять-таки стандартный sql.

179
00:13:21,110 --> 00:13:23,756
Теперь update.

180
00:13:23,756 --> 00:13:30,470
Когда я нажимаю форму submit,
что-то происходит.

181
00:13:30,470 --> 00:13:36,023
В апдейте я тоже конструирую
sql-запрос: update,

182
00:13:36,023 --> 00:13:39,580
title, description updated.

183
00:13:39,580 --> 00:13:44,190
Я точно так же беру эти значения сразу
из формы, никакой валидации, ничего.

184
00:13:44,190 --> 00:13:45,803
Не делайте так.

185
00:13:45,803 --> 00:13:50,298
Description, и я для
каждого поля прописываю

186
00:13:50,298 --> 00:13:53,104
updates на какое-то статичное значение.

187
00:13:53,104 --> 00:13:56,228
Допустим, здесь мог бы
подставляться пользователь,

188
00:13:56,228 --> 00:13:57,960
от имени которого был update.

189
00:13:57,960 --> 00:14:03,704
Ну и последним параметром
идет Id вот это вот,

190
00:14:03,704 --> 00:14:08,770
то есть я говорю,
у какой записи я хочу это удалить.

191
00:14:08,770 --> 00:14:16,110
Отлично, запись прошла, ошибки обработали,
и в результате у меня есть RowsAffected,

192
00:14:16,110 --> 00:14:21,160
то есть сколько записей было
изменено этим запросом.

193
00:14:21,160 --> 00:14:26,784
Ну и опять redirect, ничего супернового.

194
00:14:26,784 --> 00:14:30,690
Передали в функцию sql-запрос и
параметры для этого sql-запроса.

195
00:14:30,690 --> 00:14:35,240
Удаление.

196
00:14:35,240 --> 00:14:37,315
В удалении тоже все просто.

197
00:14:37,315 --> 00:14:40,260
Передали sql-запрос и один параметр.

198
00:14:40,260 --> 00:14:44,780
Обратите внимание,
я нигде не использую ручное добавление,

199
00:14:44,780 --> 00:14:48,200
конкатенацию самих
параметров в базу данных.

200
00:14:48,200 --> 00:14:52,235
Всегда пользуйтесь placeholder.

201
00:14:52,235 --> 00:14:56,270
Если вы попробуете через sprintf или еще
как-то руками конструировать запросы,

202
00:14:56,270 --> 00:14:59,676
где-то вы это проглядите
и будет sql-инъекция.

203
00:14:59,676 --> 00:15:04,701
Sql-инъекция — это неприятно, и это очень
частая причина взломов ваших сайтов,

204
00:15:04,701 --> 00:15:07,690
поэтому placeholder,
placeholder, placeholder.

205
00:15:07,690 --> 00:15:11,430
Удаление.

206
00:15:11,430 --> 00:15:14,600
Опять-таки RowsAffected,

207
00:15:14,600 --> 00:15:19,723
в данном случае этот конец вызывается
через JSON, если я нажму на кнопку delete,

208
00:15:19,723 --> 00:15:22,400
он мне скажет да, я говорю да,
и он у меня удаляет.

209
00:15:22,400 --> 00:15:23,520
Всё.

210
00:15:23,520 --> 00:15:26,880
Вот работа с sql.

211
00:15:26,880 --> 00:15:31,020
Как я сказал, для [НЕРАЗБОРЧИВО] там
будут очень незначительные отличия,

212
00:15:31,020 --> 00:15:35,550
вы можете ознакомиться с
примерами в файлах к уроку.

213
00:15:35,550 --> 00:15:41,580
Что можно сказать про работу с sql?

214
00:15:41,580 --> 00:15:46,185
Иногда, конечно,
бывает неудобно руками распаковывать все

215
00:15:46,185 --> 00:15:50,870
это дело, и для этого есть средства.

216
00:15:50,870 --> 00:15:54,270
Их мы рассмотрим далее, мы посмотрим,

217
00:15:54,270 --> 00:15:59,021
каким образом можно использовать пакеты,

218
00:15:59,021 --> 00:16:04,210
которые представляют
нам обертки для этого.