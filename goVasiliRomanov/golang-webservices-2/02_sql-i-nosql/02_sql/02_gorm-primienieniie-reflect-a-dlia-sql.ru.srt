1
00:00:00,000 --> 00:00:05,872
[БЕЗ_ЗВУКА] В

2
00:00:05,872 --> 00:00:11,580
предыдущем видео мы рассматривали,
каким образом можно руками работать с SQL.

3
00:00:11,580 --> 00:00:13,953
Иногда это бывает очень неудобно,

4
00:00:13,953 --> 00:00:19,340
особенно когда у нас в какой-то админке
нужно много-много обновлять записи.

5
00:00:19,340 --> 00:00:23,288
Поэтому возникает желание
сделать какую-то обертку,

6
00:00:23,288 --> 00:00:29,430
которая будет при помощи какой-то
магии скрывать от нас всю

7
00:00:29,430 --> 00:00:35,560
эту работу и, короче, обновлять все это,
используя просто одну функцию.

8
00:00:35,560 --> 00:00:42,730
Да, такая возможность есть в Go — при
помощи внешних библиотек, конечно.

9
00:00:42,730 --> 00:00:47,616
Работают они так же,
как encoding/json: либо через рефлексию,

10
00:00:47,616 --> 00:00:49,680
либо через кодогенерацию.

11
00:00:49,680 --> 00:00:54,280
Через рефлексию это будет гибче,
но это будет какой-то небольшой overhead.

12
00:00:54,280 --> 00:00:56,635
Через кодогенерацию будет быстрее,

13
00:00:56,635 --> 00:00:59,880
но на каждое изменение
нужно будет перезапускать.

14
00:00:59,880 --> 00:01:04,870
Какие еще есть недостатки
у такого подхода?

15
00:01:04,870 --> 00:01:10,323
Почему query-билдеры вообще не заполонили

16
00:01:10,323 --> 00:01:15,775
весь мир и мы еще пишем
иногда SQL-запрос руками?

17
00:01:15,775 --> 00:01:18,972
Дело в том, что SQL — он очень гибок,

18
00:01:18,972 --> 00:01:23,670
вы можете там делать подзапросы,
какие-то делать очень хитрые джойны.

19
00:01:23,670 --> 00:01:28,970
ORM и Active Record и прочее и
прочее — они этого всего не умеют.

20
00:01:28,970 --> 00:01:32,757
То есть, скорее всего, вы упретесь в то,

21
00:01:32,757 --> 00:01:37,820
что вы банально не сможете сделать то,
что вы хотите,

22
00:01:37,820 --> 00:01:42,620
используя, короче, эту обертку,
и вам все равно придется писать руками.

23
00:01:42,620 --> 00:01:47,133
Либо это будет огромное
количество костылей,

24
00:01:47,133 --> 00:01:50,316
и быстрее все равно будет написать руками.

25
00:01:50,316 --> 00:01:53,667
Итак, в этом видео мы
рассмотрим библиотеку gorm,

26
00:01:53,667 --> 00:01:56,460
которая как оборачивает
всю работу SQL в себя.

27
00:01:56,460 --> 00:01:58,412
Смотрим код.

28
00:01:58,412 --> 00:02:01,670
Начнем с подключения.

29
00:02:01,670 --> 00:02:08,210
Вызываем gorm.Open,
который подключается через MySQL.

30
00:02:08,210 --> 00:02:14,335
Внутри себя он оборачивает все тот же SQL,
но уже создает свою базу.

31
00:02:14,335 --> 00:02:16,765
Вот эта первая db — это db орма.

32
00:02:16,765 --> 00:02:19,646
Дальше я подключаюсь уже и пингую.

33
00:02:19,646 --> 00:02:20,194
Вот.

34
00:02:20,194 --> 00:02:26,560
То есть изменений не очень много —
изменили одну строчку на другую.

35
00:02:26,560 --> 00:02:31,050
А теперь давайте смотреть,
как выбирать записи и с ними работать.

36
00:02:31,050 --> 00:02:32,400
Сначала выбираем.

37
00:02:32,400 --> 00:02:35,544
Я хочу найти просто все записи.

38
00:02:35,544 --> 00:02:38,805
Я обращаюсь к db, и говорю Find,

39
00:02:38,805 --> 00:02:44,392
и туда передаю слайс-структуру,
куда мне все это записать.

40
00:02:44,392 --> 00:02:45,210
Вот все.

41
00:02:45,210 --> 00:02:48,651
Если раньше мне нужно было писать
SQL-запрос, что-то выбирать,

42
00:02:48,651 --> 00:02:52,591
потом еще распаковывать это руками,
то вот одна простая функция.

43
00:02:52,591 --> 00:02:55,292
Правда, она выберет все, вообще все.

44
00:02:55,292 --> 00:02:59,350
И если там будут какие-то очень поля
тяжелые, то она их тоже выберет.

45
00:02:59,350 --> 00:03:05,502
Поэтому нужно это дело
как-то ограничивать.

46
00:03:05,502 --> 00:03:06,430
Окей.

47
00:03:06,430 --> 00:03:07,795
Создание записи.

48
00:03:07,795 --> 00:03:14,120
Создаем структуру и вызываем метод Create,
куда передаем новосозданную структуру.

49
00:03:14,120 --> 00:03:14,870
Вот.

50
00:03:14,870 --> 00:03:21,173
Теперь каким образом нам
получить RowsAffected и LastId.

51
00:03:21,173 --> 00:03:24,225
LastId сразу запишется в поле нужное.

52
00:03:24,225 --> 00:03:29,830
Да, я пометил при помощи тегов структуры,

53
00:03:29,830 --> 00:03:34,535
что это SQL-автоикремент, что для горма
это primary_key, что вот, пожалуйста,

54
00:03:34,535 --> 00:03:36,524
в это поле LastId записать нужно.

55
00:03:36,524 --> 00:03:40,913
Updated — я пометил, что это поле может
быть null, на это не надо падать,

56
00:03:40,913 --> 00:03:42,530
он его корректно запишет.

57
00:03:42,530 --> 00:03:47,560
Да, вы тут получите пустую строку,
если там был null.

58
00:03:47,560 --> 00:03:49,381
Там есть много вариантов.

59
00:03:49,381 --> 00:03:54,460
Да, еще возможность указать таблицу,
то есть переопределить таблицу для

60
00:03:54,460 --> 00:03:59,708
этой структуры, и навешать разные триггер,
в данном случае, например,

61
00:03:59,708 --> 00:04:05,062
этот триггер будет вызван
пересохранением результата.

62
00:04:05,062 --> 00:04:07,801
Итак, поехали дальше: Create.

63
00:04:07,801 --> 00:04:10,180
Передаем туда новую структуру,

64
00:04:10,180 --> 00:04:15,424
нам возвращается каждая из этих
функций: Create, Find и прочее.

65
00:04:15,424 --> 00:04:18,109
Она возвращает нам объект горма,

66
00:04:18,109 --> 00:04:22,666
но в текущем [НЕРАЗБОРЧИВО],
которым мы его вызвали.

67
00:04:22,666 --> 00:04:23,970
Что это значит?

68
00:04:23,970 --> 00:04:29,510
Из него мы можем получить
Error и RowsAffected.

69
00:04:29,510 --> 00:04:32,219
То есть нам же нужно узнать,
что там что-то пошло не так,

70
00:04:32,219 --> 00:04:33,560
база отвалилась внезапно.

71
00:04:33,560 --> 00:04:41,000
Поэтому RowsAffected можно получить
вот так, а Id сразу запишется.

72
00:04:41,000 --> 00:04:45,720
То есть кода стало поменьше,
он стал попроще.

73
00:04:45,720 --> 00:04:47,437
Редактирование.

74
00:04:47,437 --> 00:04:53,894
Вот таким образом я могу найти одну
запись: Find и пожалуйста — указываю,

75
00:04:53,894 --> 00:04:57,670
куда мне это записать и
какой Id мне нужно найти.

76
00:04:57,670 --> 00:05:02,585
И также я проверяю ошибки, проверяю на то,
что запись не найдена, и все.

77
00:05:02,585 --> 00:05:07,500
То есть раньше я руками указывал все поля,
доставал, распаковывал.

78
00:05:07,500 --> 00:05:11,385
Здесь — нет, все проще.

79
00:05:11,385 --> 00:05:13,826
Update, то же самое — Update.

80
00:05:13,826 --> 00:05:16,256
Единственное что — я сначала
достаю эту структуру,

81
00:05:16,256 --> 00:05:21,249
чтобы какие-то поля не перезаписать,
потом обновляю нужные мне поля,

82
00:05:21,249 --> 00:05:24,172
и потом вызываю функцию Save.

83
00:05:24,172 --> 00:05:24,740
Все.

84
00:05:24,740 --> 00:05:29,280
Удаление — тоже функция Delete,
куда я передаю структуру,

85
00:05:29,280 --> 00:05:34,038
уже структуру, уже не единичное поле,
не просто идентификатор,

86
00:05:34,038 --> 00:05:38,610
а структуру, чтобы gorm знал,
вообще из какой таблицы это удалять.

87
00:05:38,610 --> 00:05:42,457
Вот.
Это были очень простые операции — у горма

88
00:05:42,457 --> 00:05:45,930
возможностей гораздо-гораздо больше.

89
00:05:45,930 --> 00:05:52,730
Он может и джойны делать, и валидацию
проверять, и триггеров у него много.

90
00:05:52,730 --> 00:05:57,581
Но вам приходится платить
за — как я уже говорил,

91
00:05:57,581 --> 00:06:02,228
вы получите небольшой
overhead на рефлексию,

92
00:06:02,228 --> 00:06:05,970
за счет которой все это выполняется.

93
00:06:05,970 --> 00:06:13,108
Также вы где-то будете выбирать
лишние поля и где-то вы не сможете

94
00:06:13,108 --> 00:06:18,580
вообще выполнить средствами самого горма
запрос — вам придется писать его руками.

95
00:06:18,580 --> 00:06:23,740
Но в случае если какая-то более-менее
простая админка и вы просто

96
00:06:23,740 --> 00:06:29,510
часто апдейтите записи, это может быть
вполне подходящим вариантом для работы.

97
00:06:29,510 --> 00:06:35,620
Но для хай-лоада я всегда
предпочту писать запросы руками.